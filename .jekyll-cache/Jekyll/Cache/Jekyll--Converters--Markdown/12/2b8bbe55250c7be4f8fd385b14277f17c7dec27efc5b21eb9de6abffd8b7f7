I"R
<hr />

<h1 id="nosql基础">NoSQL基础</h1>

<h2 id="什么是nosql">什么是NoSQL？</h2>

<blockquote>
  <p>NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关联式数据库的数据库管理系统的统称。（注依据Martin Fowler，NoSQL 不是英文Not Only SQL, 因为这会是NOSQL 而不是NoSQL)
两者存在许多显著的不同点，其中最重要的是NoSQL不使用SQL作为查询语言。其数据存储可以不需要固定的表格模式，也经常会避免使用SQL的JOIN操作，一般有水平可扩展性的特征。NoSQL的实现具有二个特征：使用硬盘，或者把随机存储器作存储载体。</p>
</blockquote>

<h2 id="关系型数据库的优势和不足">关系型数据库的优势和不足？</h2>

<p>关系型数据库的优点：</p>

<blockquote>
  <p>传统的关系数据库具有不错的性能，高稳定型，久经历史考验，而且使用简单，功能强大，同时也积累了大量的成功案例。</p>
</blockquote>

<ul>
  <li>容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</li>
  <li>使用方便：通用的SQL语言使得操作关系型数据库非常方便</li>
  <li>易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率</li>
</ul>

<p>传统SQL数据库为了实现ACID(atomicity, consistency, isolation, durability)，往往需要频繁应用文件锁，这使得其在现代的web2.0应用中越来越捉襟见肘。现在SNS网站每一个点击都是一条/多条查询，对数据库写的并发要求非常之高，而传统数据库无法很好地应对这种需求。而仔细想来SNS中大部分需求并不要求ACID，比如Like/Unlike投票等等。</p>

<h2 id="为什么要使用nosql数据库">为什么要使用NoSQL数据库？</h2>

<p>在互联网，大部分的MySQL都应该是IO密集型的，事实上，如果你的MySQL是个CPU密集型的话，那么很可能你的MySQL设计得有性能问题，需要优化了。大数据量高并发环境下的MySQL应用开发越来越复杂，也越来越具有技术挑战性。分表分库的规则把握都是需要经验的。虽然有像淘宝这样技术实力强大的公司开发了透明的中间件层来屏蔽开发者的复杂性，但是避免不了整个架构的复杂性。分库分表的子库到一定阶段又面临扩展问题。还有就是需求的变更，可能又需要一种新的分库方式。</p>

<p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。</p>

<p>关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</p>

<h2 id="nosql的优势和不足">NoSQL的优势和不足？</h2>

<p>易扩展</p>

<p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p>

<p>大数据量，高性能</p>

<p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。</p>

<p>灵活的数据模型</p>

<p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的web2.0时代尤其明显。</p>

<p>高可用</p>

<p>NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。比如Cassandra，HBase模型，通过复制模型也能实现高可用。</p>

<h2 id="什么是io的五分钟法则">什么是I/O的五分钟法则？</h2>

<p>如果一条记录频繁被访问，就应该放到内存里，否则的话就应该待在硬盘上按需要再访问。这个临界点就是五分钟。看上去像一条经验性的法则，实际上五分钟的评估标准是根据投入成本判断的，根据当时的硬件发展水准，在内存中保持 1KB 的数据成本相当于硬盘中存储同样大小数据 400 秒的开销(接近五分钟)。</p>

<h2 id="什么是分布式数据系统的cap定理">什么是分布式数据系统的CAP定理？</h2>

<p>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：[1][2]</p>

<ul>
  <li>一致性（Consistency)（等同于所有节点访问同一份最新的数据副本）</li>
  <li>可用性（Availability）（对数据更新具备高可用性）</li>
  <li>容忍网络分区（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择[3]。）</li>
</ul>

<hr />

<h1 id="memchache相关">Memchache相关</h1>

<h2 id="什么是memcache">什么是Memcache</h2>

<p>memcached是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用。这是一套开放源代码软件，以BSD license授权发布。</p>

<h2 id="memcache有哪些特点">Memcache有哪些特点？</h2>

<p><strong>Free &amp; open source, high-performance, distributed memory object caching system</strong></p>

<ul>
  <li>协议简单</li>
  <li>基于libevent的事件处理</li>
  <li>内置内存存储方式</li>
  <li>memcached不互相通信的分布式</li>
</ul>

<h2 id="memcache有哪些启动参数">Memcache有哪些启动参数？</h2>

<ul>
  <li>-p 指定端口号（默认11211）</li>
  <li>-U <num> UDP监听端口 (默认: 11211, 0 时关闭)</num></li>
  <li>-s <file>     用于监听的UNIX套接字路径（禁用网络支持）</file></li>
  <li>-a <mask>     UNIX套接字访问掩码，八进制数字（默认：0700）</mask></li>
  <li>-m 指定最大使用内存大小（默认64MB）</li>
  <li>-t 线程数（默认4）</li>
  <li></li>
  <li>-l <ip_addr> 绑定地址 (默认:所有都允许,无论内外网或者本机更换IP，有安全隐患，若设置为127.0.0.1就只能本机访问)</ip_addr></li>
  <li>-d start 启动memcached服务</li>
  <li>-d restart 重起memcached服务</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>-d stop</td>
          <td>shutdown 关闭正在运行的memcached服务</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>-u <username> 绑定使用指定用于运行进程 <username>  （只有root用户可以使用这个参数）</username></username></li>
  <li>-P <file> 将PID写入文件<file>，这样可以使得后边进行快速进程终止, 需要与 -d 一起使用</file></file></li>
  <li>-m 最大内存使用，单位MB。默认64MB     www.2cto.com</li>
  <li></li>
  <li>-M 内存耗尽时返回错误，而不是删除项</li>
  <li>-c 最大同时连接数，默认是1024</li>
  <li>-f 块大小增长因子，默认是1.25</li>
  <li>-n <bytes>最小分配空间，key+value+flags默认是48</bytes></li>
  <li>-k锁定所有内存页。注意你可以锁定的内存上限。试图分配更多内存会失败的，所以留意启动守护进程时所用的用户可分配的内存上限。（不是前面的 -u <username> 参数；在sh下，使用命令"ulimit -S -l NUM_KB"来设置。）</username></li>
  <li>-v 提示信息（在事件循环中打印错误/警告信息。）</li>
  <li>-vv 详细信息（还打印客户端命令/响应）</li>
  <li>-vvv 超详细信息（还打印内部状态的变化）</li>
  <li>-h 打印这个帮助信息并退出。</li>
  <li>-i  打印memcached和libevent的许可。</li>
  <li>-L 尝试使用大内存页（如果可用的话）。提高内存页尺寸可以减少”页表缓冲（TLB）”丢失次数，提高运行效率。为了从操作系统获得大内存页，memcached会把全部数据项分配到一个大区块。</li>
  <li>-D <char>     使用 <char> 作为前缀和ID的分隔符。这个用于按前缀获得状态报告。默认是":"（冒号）。如果指定了这个参数，则状态收集会自动开启；如果没指定，则需要用命令"stats detail on"来开启。</char></char></li>
  <li>-t <num>      使用的线程数（默认：4）</num></li>
  <li>-R 每个连接可处理的最大请求数。</li>
  <li>-C 禁用CAS。</li>
  <li>-b 设置后台日志队列的长度（默认：1024）</li>
  <li>-B 绑定协议 - 可能值：ascii,binary,auto（默认）</li>
  <li>-I 重写每个数据页尺寸。调整数据项最大尺寸。</li>
</ul>

<h2 id="memcache如何存储session">Memcache如何存储session？</h2>

<p>memcached提供了一个自定义的session处理器可以被用于存储用户session数据到memcached服务端。 一个完全独立的memcached实例将会在内部使用，因此如果需要您可以设置一个不同的服务器池。session的 key被存储在前缀memc.sess.key.之下，因此, 如果你对session和通常的缓存使用了 同样的服务器池，请注意这一点。 译注：另外一个session和通常缓存分离的原因是当通常的缓存占满了memcached服务端后，可能会导致你的session被 从缓存中踢除，导致用户莫名的掉线。</p>

<p>session.save_handler string<br />
设置为memcached开启memcached的session处理器。</p>

<p>session.save_path string<br />
定义一个逗号分隔的hostname:port样式的session缓存服务器池，例如： “sess1:11211, sess2:11211”.</p>

<h2 id="什么是一致性哈希算法">什么是一致性哈希算法？</h2>

<blockquote>
  <p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。</p>
</blockquote>

<p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p>

<ol>
  <li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>
  <li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</li>
  <li>分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li>
  <li>负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>
</ol>

<p>一致哈希将每个对象映射到圆环边上的一个点，系统再将可用的节点机器映射到圆环的不同位置。查找某个对象对应的机器时，需要用一致哈希算法计算得到对象对应圆环边上位置，沿着圆环边上查找直到遇到某个节点机器，这台机器即为对象应该保存的位置。 当删除一台节点机器时，这台机器上保存的所有对象都要移动到下一台机器。添加一台机器到圆环边上某个点时，这个点的下一台机器需要将这个节点前对应的对象移动到新机器上。 更改对象在节点机器上的分布可以通过调整节点机器的位置来实现。</p>

<h2 id="如何提高memcache缓存命中率">如何提高Memcache缓存命中率？</h2>

<p>应用缓存的命中率取决于很多的因素：</p>

<ol>
  <li>应用场景<br />
是OLTP还是OLAP应用，即使是OLTP，也要看访问的频度，一个极少被访问到的缓存等于没有什么效果。一般来说，互联网网站是非常适合缓存应用的场景。</li>
  <li>缓存的粒度<br />
毫无疑问，缓存的粒度越小，命中率就越高，对象缓存是目前缓存粒度最小的，因此被命中的几率更高。举个例子来说吧：你访问当前这个页面，浏览帖子，那么对于ORM来说，需要发送n条SQL，取各自帖子user的对象。很显然，如果这个user在其他帖子里面也跟贴了，那么在访问那个帖子的时候，就可以直接从缓存里面取这个user对象了。</li>
  <li>架构的设计<br />
架构的设计对于缓存命中率也有至关重要的影响。例如你应该如何去尽量避免缓存失效的问题，如何尽量提供频繁访问数据的缓存问题，这些都是考验架构师水平的地方。再举个例子来说，对于论坛，需要记录每个topic的浏览次数，所以每次有人访问这个topic，那么topic表就要update一次，这意味着什么呢？对于topic的对象缓存是无效的，每次访问都要更新缓存。那么可以想一些办法，例如增加一个中间变量记录点击次数，每累计一定的点击，才更新一次数据库，从而减低缓存失效的频率。</li>
  <li>缓存的容量和缓存的有效期<br />
缓存太小，造成频繁的LRU，也会降低命中率，缓存的有效期太短也会造成缓存命中率下降。</li>
</ol>

<p>LRU是Least Recently Used 近期最少使用算法。
内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，Oracle会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。</p>

<hr />

<h1 id="redis相关">Redis相关</h1>

<h2 id="什么是redis">什么是Redis？</h2>

<blockquote>
  <p>Redis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写。</p>
</blockquote>

<h2 id="redis有哪些特点">Redis有哪些特点？</h2>

<ul>
  <li>性能极高 – Redis能支持超过 100K+ 每秒的读写频率。</li>
  <li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
  <li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
  <li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>

<h2 id="redis有哪些数据类型">Redis有哪些数据类型？</h2>

<ul>
  <li>二进制安全的 字符串 string</li>
  <li>二进制安全的 字符串列表 list of string</li>
  <li>二进制安全的 字符串集合 set of string，换言之：它是一组无重复未排序的element。可以把它看成Ruby中的 hash–其key等于element，value都等于’true‘。</li>
  <li>有序集合sorted set of string，类似于集合set，但其中每个元素都和一个浮点数score（评分）关联。element根据score排序。可以把它看成Ruby中的 hash–其key等于element，value等于score，但元素总是按score的顺序排列，无需额外的排序操作。</li>
</ul>

<h2 id="redis如何存储session">Redis如何存储session？</h2>

<h2 id="redis的持久化规则是">Redis的持久化规则是？</h2>

<p>Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。</p>

<p>Redis支持2种持久化策略：snapshot方式和commandlog方式，前者通过将当前内存数据快照周期性写入RDB文件来实现；后者通过在log中记录Redis进程收到的写操作来实现，下次Redis重启时，回放commandlog来恢复数据状态。</p>

<p>根据实际需求，用户可以选择完全禁用持久化，也可以在同一个Redis实例中同时启用RDB和AOF。特别注意：如果部署方式为主从，则不同实例的持久化时机最好错开！避免master和slaves同时进入后台持久化，这可能会降低系统的性能。</p>

<h2 id="如何用reids实现一个优先级队列">如何用Reids实现一个优先级队列？</h2>

<p><code>sorted set</code></p>

<h2 id="如何配置reids主从复制">如何配置Reids主从复制？</h2>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>slaveof 192.168.77.211 12002 # slaveof master的ip master的端口
</pre></div>
</div>
</div>

<h2 id="如何用redis实现访问频率控制如每ip每分钟请求不能超过20次">如何用Redis实现访问频率控制，如每IP每分钟请求不能超过20次？</h2>

<p><code>sorted set</code></p>

<p>频率控制在需求上分为两种:</p>

<p>1、以自然时间单位控制，如自然天，自然月…,日历或钟表上的单位</p>

<p>2、以持续时间控制，比如从第一次操作后的1个小时或一天（24小时）；</p>

<hr />

<h1 id="mongodb相关">MongoDb相关</h1>

<h2 id="什么是mongodb">什么是MongoDB？</h2>

<blockquote>
  <p>MongoDB是一种文件导向数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。</p>
</blockquote>

<h2 id="为什么要使用mongodb">为什么要使用MongoDB？</h2>

<ol>
  <li>弱一致性（最终一致），更能保证用户的访问速度</li>
  <li>文档结构的存储方式，能够更便捷的获取数据。</li>
  <li>内置GridFS，支持大容量的存储。</li>
  <li>内置Sharding。</li>
  <li>第三方支持丰富。(这是与其他的NoSQL相比，MongoDB也具有的优势)</li>
  <li>性能优越</li>
</ol>

<h2 id="mongodb的启动参数有哪些">MongoDB的启动参数有哪些？</h2>

<h2 id="如何配置mongodb的主从复制">如何配置MongoDB的主从复制？</h2>

<div class="language-plaintext highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>slave=true
source=192.168.2.2:27017
</pre></div>
</div>
</div>

<h2 id="如何配置mongodb副本集">如何配置MongodB副本集？</h2>

<p>mongoDB的副本也是这个，主从模式其实就是一个单副本的应用，没有很好的扩展性和容错性。而副本集具有多个副本保证了容错性，就算一个副本挂掉了还有很多副本存在，并且解决了上面第一个问题“主节点挂掉了，整个集群内会自动切换”</p>

<hr />

<h1 id="参考">参考</h1>
<p><a href="http://www.infoq.com/cn/news/2011/01/nosql-why">NoSQL开篇——为什么要使用NoSQL</a><br />
<a href="http://dbanotes.net/arch/five-minute_rule.html">关于 I/O 的五分钟法则(Five-Minute Rule)</a><br />
<a href="http://www.akkadia.org/drepper/cpumemory.pdf">What every programmer should know about memory</a><br />
<a href="http://www.cnblogs.com/jiunadianshi/articles/2429125.html">Memcache内存临界测试</a><br />
<a href="http://blog.csdn.net/yunhua_lee/article/details/7599671">缓存淘汰算法系列之1——LRU类</a><br />
<a href="http://blog.nosqlfan.com/html/3139.html">Redis系统性介绍</a><br />
<a href="http://simplapi.wordpress.com/2012/04/13/php-and-node-js-session-share-redi/">PHP and Node.JS session share using Redis</a><br />
<a href="http://cfwlxf.blog.51cto.com/3966339/1433637">构建高性能数据库缓存之redis主从复制</a><br />
<a href="http://coolshell.cn/articles/5826.html">千万别用MongoDB？真的吗？！</a><br />
<a href="搭建高可用mongodb集群（二）—— 副本集">搭建高可用mongodb集群（二）—— 副本集</a></p>
:ET