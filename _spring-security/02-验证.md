---
title: 验证
tags:
- Java
- Spring
- Spring Security
toc: true
last_modified_at: '2020-08-18'
excerpt: Spring boot Security 架构组件和验证机制
---

## 架构组件

* SecurityContextHolde
* SecurityContext
* Authentication
* GrantedAuthority
* AuthenticationManager
* ProviderManager
* AuthenticationProvider
* Request Credentials with AuthenticationEntryPoint
* AbstractAuthenticationProcessingFilter

## 验证机制

* Username and Password
* OAuth 2.0 Login
* SAML 2.0 Login
* Central Authentication Server (CAS
* Remember Me
* JAAS Authentication
* OpenID
* Pre-Authentication Scenarios
* X509 Authentication

## SecurityContextHolder
`SecurityContextHolder`是Spring Security验证模型的核心，它包含`SecurityContext`
![]({{ 'assets/image/spring-security/securitycontextholder.png' | relative_url }})

```
SecurityContext context = SecurityContextHolder.createEmptyContext(); 
Authentication authentication =
    new TestingAuthenticationToken("username", "password", "ROLE_USER"); 
context.setAuthentication(authentication);

SecurityContextHolder.setContext(context);
```
* `SecurityContextHolder.createEmptyContext()` 可以避免线程竞争带来的问题：当重新使用池中的线程时，线程中仍可能存在任何线程本地数据
* `SecurityContextHolder.setContext(context)` 把`SecurityContext`保存在`SecurityContextHolder`中，之后用于授权


访问当前已验证的用户
```
SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
String username = authentication.getName();
Object principal = authentication.getPrincipal();
Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
```
* `SecurityContextHolder.MODE_THREADLOCAL` ：默认情况下，`SecurityContextHolder`使用`ThreadLocal`保存， `FilterChainProxy`确保`SecurityContext`总是被清除
* `SecurityContextHolder.MODE_GLOBAL`：Java虚拟机中的所有线程使用相同的安全上下文，如：Swing客户端
* `SecurityContextHolder.MODE_INHERITABLETHREADLOCAL` 子线程继承父线程安全标识

配置：`-Dspring.security.strategy=MODE_GLOBAL`

## SecurityContext
`SecurityContext`包含 `Authentication` 对象

## Authentication

## AuthenticationManager
`AuthenticationManager`是 Spring Security Filter进行验证的抽象，它只定义了一个方法：
```
public interface AuthenticationManager {
    Authentication authenticate(Authentication var1) throws AuthenticationException;
}
```
如果不集成 Spring Security Filter，可以绕过`AuthenticationManager`，直接设置`SecurityContextHolder`。Spring Security提供了通用的实现：`ProviderManager`

## ProviderManager
