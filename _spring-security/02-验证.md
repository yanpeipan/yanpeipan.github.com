---
title: 验证
tags:
- Java
- Spring
- Spring Security
toc: true
last_modified_at: '2020-08-18'
excerpt: Spring boot Security 架构组件和验证机制
---

## 架构组件

* SecurityContextHolde
* SecurityContext
* Authentication
* GrantedAuthority
* AuthenticationManager
* ProviderManager
* AuthenticationProvider
* Request Credentials with AuthenticationEntryPoint
* AbstractAuthenticationProcessingFilter

## 验证机制

* Username and Password
* OAuth 2.0 Login
* SAML 2.0 Login
* Central Authentication Server (CAS
* Remember Me
* JAAS Authentication
* OpenID
* Pre-Authentication Scenarios
* X509 Authentication

## SecurityContextHolder
`SecurityContextHolder`是Spring Security验证模型的核心，它包含`SecurityContext`
![]({{ 'assets/image/spring-security/securitycontextholder.png' | relative_url }})

```
SecurityContext context = SecurityContextHolder.createEmptyContext(); 
Authentication authentication =
    new TestingAuthenticationToken("username", "password", "ROLE_USER"); 
context.setAuthentication(authentication);

SecurityContextHolder.setContext(context);
```
* `SecurityContextHolder.createEmptyContext()` 可以避免线程竞争带来的问题：当重新使用池中的线程时，线程中仍可能存在任何线程本地数据
* `SecurityContextHolder.setContext(context)` 把`SecurityContext`保存在`SecurityContextHolder`中，之后用于授权


访问当前已验证的用户
```
SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
String username = authentication.getName();
Object principal = authentication.getPrincipal();
Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
```
* `SecurityContextHolder.MODE_THREADLOCAL` ：默认情况下，`SecurityContextHolder`使用`ThreadLocal`保存， `FilterChainProxy`确保`SecurityContext`总是被清除
* `SecurityContextHolder.MODE_GLOBAL`：Java虚拟机中的所有线程使用相同的安全上下文，如：Swing客户端
* `SecurityContextHolder.MODE_INHERITABLETHREADLOCAL` 子线程继承父线程安全标识

配置：`-Dspring.security.strategy=MODE_GLOBAL`

## SecurityContext
`SecurityContext`包含 `Authentication` 对象

## Authentication
是授予用户的高级许可，如：roles、scopes

## GrantedAuthority
## AuthenticationManager
`AuthenticationManager`是 Spring Security Filter进行验证的抽象，它只定义了一个方法：
```
public interface AuthenticationManager {
    Authentication authenticate(Authentication var1) throws AuthenticationException;
}
```
如果不集成 Spring Security Filter，可以绕过`AuthenticationManager`，直接设置`SecurityContextHolder`。Spring Security提供了通用的实现：`ProviderManager`

## ProviderManager
![]({{ 'assets/image/spring-security/providermanager.png' | relative_url }})
`ProviderManager`委托给一组`AuthenticationProvider`，每个`AuthenticationProvider`都有机会表明验证成功、失败，或者无法验证，并交由下游。如果没有配置`AuthenticationProvider`则抛出`ProviderNotFoundException`

每个`AuthenticationProvider`执行特定类型的验证，因此`AuthenticationManager`可以支持多种类型验证
![]({{ 'assets/image/spring-security/providermanager-parent.png' | relative_url }})

`ProviderManager`可以配置父`AuthenticationManager`，当无法身份验证时，可以咨询父`AuthenticationManager`。通常它是一个`ProviderManager`实例。

![]({{ 'assets/image/spring-security/providermanagers-parent.png' | relative_url }})

`ProviderManager`多个实例可以共享一个父`AuthenticationManager`，这在多个`SecurityFilterChain`实例的场景中比较常见。

默认情况下，ProviderManager将尝试从成功的身份验证请求返回的身份验证对象中清除任何敏感凭据信息。当使用缓存时，那么将不再可能根据缓存的值进行身份验证。解决方法：

* 提前做数据备份，在缓存实现中，或者在`AuthenticationProvider`创建返回`Authentication`对象中
* 禁用`ProviderManager`的属性`eraseCredentialsAfterAuthentication`

## AuthenticationProvider
多个`AuthenticationProvider`被注入到`ProviderManager`，每个可以执行特定类型的验证。如：`DaoAuthenticationProvider`  `JwtAuthenticationProvider`

## AuthenticationEntryPoint
被用于从客户端请求用户凭证，`AuthenticationEntryPoint`可能是跳转到登录页，或者响应`WWW-Authenticate`头


## AbstractAuthenticationProcessingFilter
`AbstractAuthenticationProcessingFilter`是个基础的`Filter`，用来验证客户端提交的用户凭证。

![]({{ 'assets/image/spring-security/abstractauthenticationprocessingfilter.png' | relative_url }})

1. `AbstractAuthenticationProcessingFilter`从`HttpServletRequest`中创建`Authentication`，具体依赖子类实现。如：`UsernamePasswordAuthenticationFilter`创建`UsernamePasswordAuthenticationToken`
2. `Authentication`传递给`AuthenticationManager`去验证
3. 如果验证失败
* `SecurityContextHolder`被清除
* `RememberMeServices.loginFail`被调用
* `AuthenticationFailureHandler`被调用
4. 如果验证成功
* `SessionAuthenticationStrategy`会话验证策略被通知有个新登录
* `Authentication`保存到`SecurityContextHolder`，之后 `SecurityContextPersistenceFilter` 保存 `SecurityContext` 到 `HttpSession`
* `RememberMeServices.loginSuccess`
* `ApplicationEventPublisher` 发布 `InteractiveAuthenticationSuccessEvent`事件
