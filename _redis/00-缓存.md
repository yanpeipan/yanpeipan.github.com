---
title: 缓存
---

缓存一致性、缓存击穿、缓存雪崩

## 缓存读取

## 缓存更新

数据库的分布式事务的问题，需要处理数据可靠性的挑战，并发更新带来的隔离性挑战，和数据更新原子性的挑战。

### 数据可靠性

* 先更新成功存储，再更新缓存；
* 先更新成功缓存，再跟新存储，如果存储更新失败，删除缓存；
* 操作隔离性。

一条数据的更新涉及到存储和缓存两套系统，如果多个线程同时操作一条数据，并且没有方案保证多个操作之间的有序执行，就可能会发生更新顺序错乱导致数据不一致的问题。

### 更新原子性

#### 业务层缓存更新方案


* Step1：更新存储，保证数据可靠性；
* Step2：更新缓存，2 个策略怎么选：
* 惰性更新：删除缓存，等待下次读 MISS 再缓存（推荐方案）；
* 积极更新：将最新的值更新到缓存（不推荐）；

#### 外部组件更新缓存
缓存 MISS 处理方案

* 第一：需要监控存储的日志，或者通过 Triger 来监控存储数据的变更，需要对存储系统非常熟悉；
* 第二：需要对更新进行过滤，我们的目的是缓存热数据，但是像 DDL、批量更新这一系列的操作是不需要更新缓存的，要把非业务更新操作过滤；
* 第三：同步组件需要理解数据，不通用；
* 先更新存储，由第三方组件异步更新缓存；

其他缓存更新方案
在实际的生产中，我们还会看到很多先更新缓存，然后通过第三方组件更新存储的场景，但是这个方案也会面临数据一致性和数据可靠性的挑战，虽然不推荐，但是确实还是能看到有在使用这个方案的，我们拿出来探讨下。

* 这个场景数据可靠性，不及先更新存储的方案，但是写入性能高，延迟低；
* 这个方案 APP 和第三方组件都会更新 Cache，会存在数据一致性的问题，因为很难保障两个组件更新的时序。

## 缓存淘汰
* 主动淘汰，这是推荐的方式，我们通过对 Key 设置 TTL 的方式来让 Key 定期淘汰，以保障冷数据不会长久的占有内存。TTL 的策略可以保证冷数据一定被淘汰，但是没有办法保障热数据始终在内存，这个我们在后面会展开；
* 被动淘汰，这个是保底方案，并不推荐，Redis 提供了一系列的 Maxmemory 策略来对数据进行驱逐，触发的前提是内存要到达 maxmemory（内存使用率 100%），在 maxmemory 的场景下缓存的质量是不可控的，因为每次缓存一个 Key 都可能需要去淘汰一个 Key。
