

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>大规模Web服务开发技术 &larr; </title>
  <meta name="author" content="Yan Peipan" />
  <link rel="start" href="/" />
  
  
  
  <!-- syntax highlighting CSS -->
  <link rel="stylesheet" href="/assets/themes/mark-reid/css/syntax.css" type="text/css" />
  <!-- Homepage CSS -->
  <link rel="stylesheet" href="/assets/themes/mark-reid/css/screen.css" type="text/css" />
</head>
<body id="">
  <div id="site">
    <div id="header">
      <h1>
        <a href="/" title="Yan">Yan</a>
        <span class="byline">&larr; <a href="/">Yan Peipan</a></span>
      </h1>
      <ul class="nav">
        <li><a href="/" class="home">Home</a></li>
        <li><a href="/archive.html">Archive</a></li>
        <li><a href="/pages.html">Pages</a></li>
        <li><a href="/categories.html">Categories</a></li>
        <li><a href="/tags.html">Tags</a></li>
      </ul>
    </div>
    

<div id="page">
  <h1 class="emphnext">大规模Web服务开发技术</h1>
  <ul class="tag_box inline">
    
    

  
    
  



  </ul>
  
<hr />

<h1 id="大规模web服务的开发定位掌握整体">大规模Web服务的开发定位——掌握整体</h1>

<h2 id="大规模和小规模服务">大规模和小规模服务</h2>

<ul>
  <li>Alexa排名</li>
  <li>服务规模可以大致通过服务器数量来把握， 从这个观点来说， 上百台至几千台左右可以称为大规模。</li>
</ul>

<h4 id="小规模服务和大规模服务的区别">小规模服务和大规模服务的区别</h4>

<ol>
  <li>保证可扩展性， 负载均衡的必要性
    <ul>
      <li>横向扩展（scale out）：通过增加服务器数量来提高系统整体的处理能力并分担负载。</li>
      <li>纵向扩展（scale up）：通过提高硬件性能来提高处理能力。</li>
    </ul>
  </li>
  <li>保证冗余性</li>
  <li>低成本运维的重要性</li>
  <li>开发人数和开发方法的变化</li>
</ol>

<h3 id="应对大规模数据量">应对大规模数据量</h3>

<p>现代计算机的特点， 就是各层之间的速度差异非常大。即使操作系统和中间件再努力，也是有极限的。数据量增大， 就会经常发生缓存不命中， 结果就要多次访问低速磁盘。进入磁盘I/O（输入输出）等待队列的程序在等待读取完成之时，即使其他资源空闲， 也无法进行下一步处理。这就会导致系统整体的速度下降。</p>

<hr />

<h2 id="持续增长的服务和大规模化的障碍">持续增长的服务和大规模化的障碍</h2>

<h3 id="系统增长战略最小化开端-预见变化的管理和设计">系统增长战略——最小化开端， 预见变化的管理和设计</h3>

<ol>
  <li>事先考虑到未来系统规模会变大，从而一开始就建立完善的负载均衡系统的话，成本实在是太高了。</li>
  <li>不假思索地开始也是欠考虑的。数据规模增大引起的I/O负载上升并不是平滑增加。从缓存不命中开始只需片刻， 问题就会急剧显露出来， 引起人们注意时， 系统速度就已经开始下降了——这种事情是极其常见的。</li>
  <li>最小化开端， 在关键的地方为将来的增长做好规划， 又不致花费过多的开销。</li>
</ol>

<hr />

<h1 id="大规模数据处理入门内存和磁盘web应用程序和负载">大规模数据处理入门——内存和磁盘，Web应用程序和负载</h1>

<h2 id="大规模数据处理的难点内存和磁盘">大规模数据处理的难点——内存和磁盘</h2>

<h3 id="为何处理大规模数据如此困难因为无法在内存中计算">为何处理大规模数据如此困难——因为无法在内存中计算</h3>

<p>无法在内存中计算的话， 就必须搜索磁盘上的数据， 但是磁盘十分缓慢， I/O十分耗费时间。</p>

<h3 id="内存和磁盘的速度差异内存要快105-106倍">内存和磁盘的速度差异——内存要快10^5-10^6倍</h3>

<p>内存比磁盘快10w-100w倍。</p>

<h3 id="操作系统层的加速处理">操作系统层的加速处理</h3>

<p>操作系统将连续的数据放在同一处， 一次性读取4KB（kilobytes）左右。其结果就是将磁盘旋转次数降到最低。这种处理尽量减少磁盘旋转。尽管如此， 旋转一次也需要花费毫秒级，所以与内存的速度差异还是不可避免的。</p>

<h3 id="传输速度和总线的速度差异">传输速度和总线的速度差异</h3>

<p>内存的搜索速度是磁盘的10^5-10^6倍以上， 不论内存还是磁盘， 都用总线与CPU连接。 这些总线的传输速度也有差异。连接内存和CPU的总线相当快，能达到7.5G/s， 但磁盘只能达到58M/s。SSD（solid State Drive， 固态硬盘）不需要物理旋转即可进行高速搜索， 但由于总线速度的瓶颈以及其他结构的影响， 其速度还是无法与内存相比。</p>

<p>在现代计算机上编写应用程序时， 必须考虑到内存和磁盘的速度差异。这是考虑可扩展性（scalability)时及其主要的一点， 也是非常困难的一点。</p>

<h3 id="不要推测-要测量将一台服务器的性能发挥到极致">不要推测， 要测量——将一台服务器的性能发挥到极致</h3>

<p>负载均衡也不例外。通过测量找出系统的瓶颈，然后努力消除瓶颈以发挥性能。</p>

<h3 id="寻找瓶颈的基本流程">寻找瓶颈的基本流程</h3>

<ul>
  <li>查看平均负载（load average）</li>
  <li>确认CPU，I/O有无瓶颈</li>
</ul>

<h3 id="查看平均负载">查看平均负载</h3>

<ul>
  <li>首先， 确认负载的第一步就是top， uptime等命令显示的平均负载（load average）。但是， 仅通过平均负载是无法判断瓶颈原因的。 应该从平均负载数值处着手， 开始调查瓶颈。</li>
  <li>负载很低， 但系统的吞吐量无法提高的现象也时有发生。这种情况下应该检查软件设置是否正常， 检查网络和远程主机是否存在故障。</li>
</ul>

<h3 id="查找cpu和io的瓶颈">查找CPU和I/O的瓶颈</h3>

<p>平均负载过高时， 要在CPU或者I/O中寻找原因。sar或vmstate可以查看CPU使用情况和I/O等待率随着时间的推移情况，作为参考。</p>

<p>“CPU负载”过高时， 用以下流程寻找原因：</p>

<ul>
  <li>确认是用户程序处理的瓶颈，还是系统程序的原因</li>
  <li>再通过ps可查看进程的状态和CPU使用时间等， 确定导致问题的进程</li>
  <li>确定进程之后， 想要进一步寻找原因的话， 可以通过strace追踪， 或oprofile进行刨测， 以确定瓶颈所在。</li>
</ul>

<p>“I/O负载”过高， 多半是程序发出的I/O请求过多导致负载过高， 或是发生页面交换导致频繁访问磁盘。</p>

<p>如果是发生页面交换的情况， 应该从以下几点着手调查：</p>

<ul>
  <li>用Ps确认是否有进程消耗了大量的内存</li>
  <li>如果由于程序故障造成内存消耗过大， 应改进程序</li>
  <li>如果是因为内存不足， 就要增加内存。 无法增加内存时考虑分布式。</li>
</ul>

<p>如果是没有交换发生， 而且磁盘I/O频繁的情况， 可能是用于缓存的内存不足。 根据服务器拥有的数据量和可增加的内存量， 按照一下步骤选择应对方法：</p>

<ul>
  <li>如果通过增加内存可以扩大缓存， 就增加内存</li>
  <li>如果增加内存还不够用， 就考虑分散存储数据， 或增加缓存服务器等。</li>
</ul>

<h3 id="操作系统调优-就是找出负载原因并去除之">操作系统调优， 就是找出负载原因并去除之</h3>

<p>调优的真正含义是 “找到瓶颈并去除之”</p>

<hr />

<h2 id="可扩展性的要点">可扩展性的要点</h2>

<h3 id="扩展和可扩展性">扩展和可扩展性</h3>

<p>将大量廉价的， 性能一般的硬件放在一起以提升系统性能的“横向扩展”（scale out）方案流行。因为它更适合大多数Web服务，虽然原因多种多样，但价格低廉和系统结构灵活是最重要的原因。</p>

<h3 id="可扩展性的要点cpu负载和io负载">可扩展性的要点——CPU负载和I/O负载</h3>

<p>代理服务器或应用服务器，基本上只消耗CPU。相反，数据库服务器需要较多I/O资源。</p>

<h3 id="web应用程序和负载的关系">Web应用程序和负载的关系</h3>

<p>CPU负载服务器， 只须增加与原有服务器结构完全相同的服务器， 负载均衡器（load balancer）负责均匀的分发请求， 这样就OK了。</p>

<h3 id="数据库的可扩展性很难保证">数据库的可扩展性很难保证</h3>

<p>大规模环境中产生I/O负载的服务器本来就很难分散， 再加上频繁产生的磁盘I/O， 很容易导致服务器变慢， 这才是本质的问题。</p>

<h3 id="两种负载与web应用程序">两种负载与Web应用程序</h3>

<ol>
  <li>CPU负载 程序的处理速度依赖于CPU的计算速度。也称为“计算密集型程序”（CPU bound）</li>
  <li>I/O负载 程序的处理速度依赖于磁盘的读取速度， 即依赖于输入/输出。这种给I/O加上负载的程序成为“I/O密集型程序”</li>
</ol>

<h3 id="多任务操作系统和负载">多任务操作系统和负载</h3>

<p>top的输出结果包含为“load average”（平均负载）的数字。平均负载从左到右分别为1分钟，5分钟， 15分钟内单位时间中处于等待状态的任务数。平均负载高， 说明有相应数量的任务在等待， 可以认为运行有延迟， 也就是负载过高。</p>

<h3 id="平均负载揭示的实际负载状况">平均负载揭示的实际负载状况</h3>

<p>硬件每隔一定周期给CPU发送中断信号。每次发生中断时， CPU就会进行与时间相关的处理。平均负载就是在每次定时器中断（Timer Interrupt）发生时计算的。</p>

<p>平均负载中的负载的意思就是：</p>

<ul>
  <li>等待赋予CPU的执行权限的进程</li>
  <li>等待磁盘I/O完成的进程</li>
</ul>

<p>平均负载本身是将两种负载综合的结果， 单凭该数字无法判断是CPU负载高， 还是I/O负载高。</p>

<hr />

<h2 id="处理大规模数据的基础知识">处理大规模数据的基础知识</h2>

<h3 id="面向程序员的大规模数据的基础">面向程序员的大规模数据的基础</h3>

<ol>
  <li>处理大规模数据的三个重点——写程序的技巧
    <ul>
      <li>能在内存中完成多少？ 将磁盘寻道次数降到最低。实现分布式， 有效利用局部性。</li>
      <li>能应对数据量增加的算法和数据结构 例如：线性搜索-&gt;二叉树搜索</li>
      <li>数据压缩， 信息搜索技术</li>
    </ul>
  </li>
  <li>处理大规模数据之前的三大前提知识——程序开发的底层基础
    <ul>
      <li>操作系统的缓存</li>
      <li>以分布式为前提的RDBMS应用</li>
      <li>算法和数据结构</li>
    </ul>
  </li>
</ol>

<h3 id="平均负载之后是cpu使用率和io等待率">平均负载之后是CPU使用率和I/O等待率</h3>

<p>负载过大而导致性能下降的原因绝大多数都是CPU或I/O某个出了问题， 可以按照以下方法调查哪个出了问题。</p>

<ol>
  <li>通过sar查看CPU使用率和I/O等待率 <code>%user</code>是CPU在用户模式下的使用率， <code>%system</code>为系统模式下的使用率</li>
  <li>I/O密集型场合的sar状态 <code>%iowait</code> 是I/O等待率</li>
  <li>多CPU与CPU使用率 <code>sar -P ALL</code></li>
</ol>

<hr />

<h1 id="操作系统的缓存和分布式高效处理大规模数据的原则">操作系统的缓存和分布式——高效处理大规模数据的原则</h1>

<h2 id="操作系统的缓存机制">操作系统的缓存机制</h2>

<h3 id="在理解操作系统缓存的基础上编写应用程序页面缓存">在理解操作系统缓存的基础上编写应用程序——页面缓存</h3>

<p>Linux上有页面缓存（page cache），文件缓存（file cache），缓存区缓存（buffer cache）这些机制。</p>

<h3 id="虚拟内存机制">虚拟内存机制</h3>

<p>由于操作系统将物理硬件抽象化， 因此才产生了虚拟内存。</p>

<ul>
  <li>具有让进程更容易地访问内存等好处</li>
  <li>操作系统在内核中将内存抽象化</li>
  <li>操作系统以页面为单位分配物理内存并管理</li>
</ul>

<h3 id="linux页面缓存原理">Linux页面缓存原理</h3>

<p>内核分配过的内存不会释放， 而是一直保留下来（即页面缓存）</p>

<h3 id="vfs">VFS</h3>

<p>磁盘缓存就是像这样由页面缓存实现的， 但实际上操作磁盘的设备驱动程序和操作系统之间还夹着一层文件系统VFS（Virtual File System， 虚拟文件系统）， 负责将不同实现方式的文件系统抽象化。</p>

<h3 id="linux以页面为单位缓存磁盘">Linux以页面为单位缓存磁盘</h3>

<p>操作系统以块为单位读出缓存的内存， 所以只能对文件某一部分， 或读出部分缓存。</p>

<p>页面=虚拟内存的最小单位</p>

<p>LRU(Least Recently Used)， 放弃最老的内容， 留下最新的内容。</p>

<p>Linux使用inode编号来识别文件， 以文件的inode编号和表示内容在文件中位置的偏移量两个值作为键进行缓存。操作系统内部使用了名为Radix Tree的数据结构， 保证缓存的搜索速度不会降低。</p>

<h3 id="内存空闲时就缓存通过sar确认">内存空闲时就缓存——通过sar确认</h3>

<p>Linux会把全部空闲内存用于缓存， 通过<code>sar -r</code>。<code>kbcached</code>为<code>kilo byte cached</code>的省略， 即用于缓存的容量。</p>

<h3 id="增加内存降低io负载">增加内存降低I/O负载</h3>

<h3 id="页面缓存是透明的">页面缓存是透明的</h3>

<h2 id="降低io负载的策略">降低I/O负载的策略</h2>

<h3 id="以缓存为前提的降低io负载的策略">以缓存为前提的降低I/O负载的策略</h3>

<ol>
  <li>如果数据规模小于物理内存， 就全部缓存;
    <ul>
      <li>以缓存为前提的降低I/O负载的策略是有效的</li>
      <li>大规模数据处理时数据压缩很重要， 比如一般的压缩算法如LZ算法等， 对于文本文件能压缩到一半左右</li>
    </ul>
  </li>
  <li>考虑与经济成本的平衡性
    <ul>
      <li>选择性能上最为经济的服务器</li>
      <li>硬件成本突然增加时，改进软件更合适</li>
    </ul>
  </li>
</ol>

<h3 id="扩展到多台服务器无法全部缓存的情况">扩展到多台服务器——无法全部缓存的情况</h3>

<ul>
  <li>CPU负载分散只需简单的增加</li>
  <li>I/O分散需要考虑局部性</li>
</ul>

<h3 id="单纯增加数量无法保证可扩展性">单纯增加数量无法保证可扩展性</h3>

<p>无法缓存的比例依然不变， 立即再次成为瓶颈</p>

<h3 id="降低io负载和页面缓存">降低I/O负载和页面缓存</h3>

<p>Linux以4KB的小块来管理内存空间， 这种4KB的块成为“页面”。</p>

<ol>
  <li>页面缓存起到的降低I/O负载的效果</li>
  <li>要先读取一次磁盘才会页面缓存</li>
</ol>

<hr />

<h2 id="利用局部性的分布式">利用局部性的分布式</h2>

<ol>
  <li>根据访问模式实施分布式</li>
  <li>不再有无法缓存的数据</li>
</ol>

<h3 id="partitioning考虑局部性的分布式">Partitioning——考虑局部性的分布式</h3>

<p>Partitioning  就是将一个数据库分割到多台服务器上。</p>

<ol>
  <li>以RDBMS的表为单位分割</li>
  <li>从数据中间分割</li>
  <li>根据用途将系统分成不同的“岛”</li>
</ol>

<h3 id="根据访问模式分割成岛考虑局部性的分布式">根据访问模式分割成“岛”——考虑局部性的分布式</h3>

<p>一般请求， 爬虫和图像分别分到不同的“岛”上。</p>

<h3 id="以页面缓存为前提的基本应用规则">以页面缓存为前提的基本应用规则</h3>

<ul>
  <li>操作系统刚启动时不要将服务器投入到生产环境</li>
  <li>性能测试要在缓存优化后进行</li>
</ul>

<hr />

<h1 id="数据库的横向扩展策略以分布式为基础的mysql应用">数据库的横向扩展策略——以分布式为基础的MySQL应用</h1>

<h2 id="正确应用索引分布式mysql应用的打前提">正确应用索引——分布式MySQL应用的打前提</h2>

<h3 id="分布式mysql应用的三大要点">分布式MySQL应用的三大要点</h3>

<ul>
  <li>灵活应用操作系统缓存</li>
  <li>正确设置索引</li>
  <li>以横向扩展为前提的设计</li>
</ul>

<h3 id="灵活应用操作系统缓存">灵活应用操作系统缓存</h3>

<ol>
  <li>考虑全部数据量
    <ul>
      <li>保持数据量小于物理内存</li>
      <li>内存不足时增加内存等</li>
    </ul>
  </li>
  <li>考虑表结构设计对数据大小的影响（亿条数据， 表结构稍有错误， 数据量就会以GB为单位增减）</li>
</ol>

<h3 id="索引的重点b树">索引的重点——B树</h3>

<ol>
  <li>index=索引</li>
  <li>B+树
    <ul>
      <li>搜索外部存储设备时能将寻道次数最小化的树结构（可以将各节点的大小设定在一个合适的范围内——4KB左右</li>
      <li>搜索复杂度：O(n) -&gt; O(logn)</li>
    </ul>
  </li>
</ol>

<h3 id="索引的效果">索引的效果</h3>

<p>不仅能改善复杂度， 还能改善磁盘寻道次数。这是B树与其他复杂度同样是O（logn)的树的区别</p>

<h3 id="确认索引是否有效的方法explain命令">确认索引是否有效的方法——explain命令</h3>

<hr />

<h2 id="mysql的分布式以扩展为前提的系统设计">MySQL的分布式——以扩展为前提的系统设计</h2>

<h3 id="mysql的replication功能">MySQL的replication功能</h3>

<ol>
  <li>master/slave的架构</li>
  <li>查询发给slave， 更新发给master
    <ul>
      <li>通过ORM来控制</li>
    </ul>
  </li>
</ol>

<h3 id="masterslave的特性对参照系进行扩展-更新类不扩展">master/slave的特性——对参照系进行扩展， 更新类不扩展</h3>

<ol>
  <li>查询可以扩展
    <ul>
      <li>只需增加服务器即可</li>
      <li>但是， 在增加服务器之前要先安装适当的内存</li>
    </ul>
  </li>
  <li>master无法扩展
    <ul>
      <li>更新类的查询增加后情况更加严峻</li>
      <li>但是， Web应用程序多数情况下90%都是读取查询</li>
      <li>master的负载通过表分割或更换实现方法来解决</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="mysql的横向扩展和partitioning">MySQL的横向扩展和Partitioning</h2>

<h3 id="mysql的横向扩展策略">MySQL的横向扩展策略</h3>

<p>若无法增加内存就用Partitioning</p>

<h3 id="关于partitioning表分割的补充">关于Partitioning（表分割）的补充</h3>

<p>Partitioning就是充分利用局部性进行分散， 提高缓存利用效率。</p>

<h3 id="以partitioning为前提的设计">以Partitioning为前提的设计</h3>

<p>避免JOIN——利用where…in…</p>

<h3 id="partitioning的代价">Partitioning的代价</h3>

<ul>
  <li>运维变得复杂</li>
  <li>故障率上升</li>
</ul>

<h3 id="实现冗余化需要几台服务器">实现冗余化需要几台服务器</h3>

<p>master1台+slave2台的话， 假设某台slave发生故障， 而准备好新的数据库服务器要复制数据， 但要复制数据， 就必须把剩下的那台slave停机（停止master无法写入， 停止slave无法读取）</p>

<p>要想完美的冗余化， 4台1组是必要的</p>

<h3 id="partitiong的代价">Partitiong的代价</h3>

<ol>
  <li>优点
    <ul>
      <li>降低负载</li>
      <li>增加局部性， 提高缓存效果</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>运维变得复杂后， 经济成本也会上升</li>
      <li>故障率上升</li>
    </ul>
  </li>
  <li>Partitioning毕竟只是杀手锏</li>
</ol>

<hr />

<h1 id="大规模数据处理实践入门">大规模数据处理“实践”入门</h1>

<h2 id="特殊用途索引处理大规模数据">特殊用途索引——处理大规模数据</h2>

<p>超出RDBMS处理器能力时怎么办？</p>

<ul>
  <li>用批处理取出数据</li>
  <li>创建专用索引服务器， 通过Web API等进行转换</li>
</ul>

<h2 id="特殊用途索引使用调优后的数据结构">特殊用途索引——使用调优后的数据结构</h2>

<ol>
  <li>搜索用的逆向索引</li>
  <li>关键字用的Trie
    <ul>
      <li>正则表达式拥有自动机中的NFA（Nondeterministic Finite Automaton， 非确定性有限自动机）， 用OR链接之后， 匹配时的计算量就会迅速膨胀</li>
      <li>Trie和Common Prefix Search（公共前缀搜索）的组合才是王道</li>
      <li>实现Common PrefixSearch有Aho-Corasick， Double Array Trie</li>
    </ul>
  </li>
  <li>文本分类器
    <ul>
      <li>Complement Naive Bytes 自动进行机器学习并分类</li>
    </ul>
  </li>
  <li>全文索引</li>
</ol>

<hr />

<h1 id="压缩数据考虑数据大小和io加速之间的关系">压缩数据——考虑数据大小和I/O加速之间的关系</h1>

<h2 id="以紧凑简洁方式保存整数数据">以紧凑，简洁方式保存整数数据</h2>

<h3 id="可变字节码用紧凑格式保存整数数据">可变字节码——用紧凑格式保存整数数据</h3>

<p>可变字节码（variable Byte Code）中， 各字节的8比特的最高位1比特为标志位， 因此表示整数的只有7比特。第一字节的低7比特表示0-127, 高位字节表示128×(1-127)， 更高位表示128^2(1-127)</p>

<h3 id="用差存储已排序整数">用“差”存储已排序整数</h3>

<ol>
  <li>求出与前一个数值之差</li>
  <li>数值分布变成大量较小的数值和少量较大的数值
    <ul>
      <li>将结果用可变字节码编码， 压缩效果来源于偏离分布</li>
    </ul>
  </li>
</ol>

<h3 id="压缩的基础">压缩的基础</h3>

<ol>
  <li>根据符号的概率分布， 给出现频率较高的分配较短的编码， 出现频率低的分配较长的编码</li>
</ol>

<h3 id="压缩对象是整形的情形背景理论">压缩对象是整形的情形——背景理论</h3>
<ol>
  <li>压缩对象本身就有整数的含义</li>
  <li>巧妙的利用整数的特征进行压缩</li>
</ol>

<h2 id="可变字节吗和速度的感觉">可变字节吗和速度的感觉</h2>

<hr />

<h1 id="算法实用化从身边的例子来看理论研究的实践投入">算法实用化——从身边的例子来看理论，研究的实践投入</h1>

<h2 id="算法和算法评测">算法和算法评测</h2>

<h3 id="数据规模和复杂度的差异">数据规模和复杂度的差异</h3>

<h3 id="学习算法的意义计算机资源有限-工程师的通用语言">学习算法的意义——计算机资源有限， 工程师的通用语言</h3>

<h3 id="灵活应用第三方实现cpan等">灵活应用第三方实现——CPAN等</h3>

<hr />

<h2 id="hatena-diary的关键字链接">Hatena Diary的关键字链接</h2>

<h3 id="用模式匹配实现关键字链接的问题">用模式匹配实现关键字链接的问题</h3>

<p>Perl的正则表达式采用的是NFA（Nondeterministic Finite Automata， 非确定性有穷自动机）</p>

<h3 id="从正则表达式到trie改变匹配的实现方式">从正则表达式到Trie——改变匹配的实现方式</h3>

<ul>
  <li>用树结构高效存储字符串集合</li>
  <li>其树结构可以将搜索对象数据的公共前缀综合到一起</li>
</ul>

<h3 id="aho-corasick算法">Aho-Corasick算法</h3>

<hr />

<h2 id="hatena-bookmark的文章分类">Hatena Bookmark的文章分类</h2>

<h3 id="什么是文章分类">什么是文章分类</h3>

<p>用贝叶斯过滤器判断类别</p>

<h3 id="机器学习和大规模数据">机器学习和大规模数据</h3>

<h3 id="贝叶斯过滤器的原理">贝叶斯过滤器的原理</h3>

<ol>
  <li>贝叶斯过滤器的核心是朴素贝叶斯算法</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>页贝斯公式 P(B</td>
          <td>A)=P(A</td>
          <td>B)P(B)/P(A)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h3 id="拼写错误改正功能的制作方法">拼写错误改正功能的制作方法</h3>

<ol>
  <li>使用正确数据字典, 可以下载Wikipedia等的数据</li>
  <li>计算搜索查询与字典中语句的编辑距离， 定量衡量错误程度——Levenshtein</li>
  <li>以一定的错误程度为基准， 从字典中找出某个单词作为候补正确答案——使用n-gram缩小比较对象， 之后逐个计算编辑距离（常用的是二元的Bi-Gram和三元的Tri-Gram）</li>
  <li>将候补正确答案以文章中的单词使用频率为基准，按照正确的可能性排列</li>
  <li>将使用频率最高的单词作为正确答案提示给用户</li>
</ol>

<hr />

<h1 id="挑战全文搜索技术各种各样的大规模数据处理经验技巧">挑战全文搜索技术——各种各样的大规模数据处理经验技巧</h1>

<h2 id="搜索系统的架构">搜索系统的架构</h2>

<p>搜索引擎中最重要的元素之一——逆向索引（inverted index）， 由Dicitionary（字典文件）和Postings（置入文件）两个基本要素组成。</p>

<h2 id="搜索系统的架构-1">搜索系统的架构</h2>

<h3 id="搜索系统所需的步骤">搜索系统所需的步骤</h3>

<ol>
  <li>爬行， 存储， 建立索引， 搜索， 评分， 结果显示</li>
  <li>6个阶段分别有各自的课题</li>
</ol>

<h3 id="全文搜索的种类">全文搜索的种类</h3>

<ol>
  <li>grep类型——grep， Shunsaku
    <ul>
      <li>从头开始读取搜索对象</li>
      <li>即时性良好， 搜索无遗漏，并行化，查询扩展很容易</li>
      <li>朴素算法——O(mn), text:m, word:n</li>
      <li>KMP(Knuth-Morris-Pratt)算法——O(m+n)</li>
      <li>BM算法(Boyer-Moore)——最坏情况(mn), 最好情况O(n/m)</li>
    </ul>
  </li>
  <li>后缀类型——Sedue
    <ul>
      <li>用可搜索的形式存储搜索对象的全文</li>
      <li>数据结构有：Trie, Suffix Tree, Suffix Array, Compressed Suffix Array</li>
      <li>理论上可能</li>
      <li>信息量过大，难以实现</li>
    </ul>
  </li>
  <li>逆向索引类型(Inverted Index，倒排索引)——主流（Google）
    <ul>
      <li>建立term(单词)和文档的关系</li>
      <li>平衡性良好的架构——实际系统大多使用逆向索引</li>
      <li>即时性不佳，可能有搜索遗漏</li>
    </ul>
  </li>
</ol>

<h2 id="搜索引擎的内部结构">搜索引擎的内部结构</h2>

<h3 id="逆向索引的结构dicitonarypostings">逆向索引的结构——Dicitonary+Postings</h3>

<ol>
  <li>term和文档的关系</li>
  <li>term
    <ul>
      <li>文档中的单词</li>
      <li>所有term的集合称为Dictionary</li>
    </ul>
  </li>
  <li>逆向索引=Dictionary+Postings
    <ul>
      <li>能够即时发现包含在term中的文档</li>
    </ul>
  </li>
</ol>

<h3 id="dictionary的创建方法逆向索引的创建方法">Dictionary的创建方法——逆向索引的创建方法</h3>

<ol>
  <li>将单词当作term处理
    <ul>
      <li>字典+Aho-Corasick算法切分单词</li>
      <li>使用语素分析——（MeCab日文分词器,MMSEG中文分词器</li>
    </ul>
  </li>
  <li>将n-gram当作term处理
    <ul>
      <li>将n-gram作为term处理会存在错误搜索的问题（查准率降低），因此对搜索结果配合过滤比较好，但是当搜索文档内容较多时，全文匹配搜索花费时间多，不太适用。解决方法是同时使用单词逆向索引和N-gram逆向索引。正文使用单词逆向索引，标题、评价、url等使用N-gram逆向索引。</li>
      <li>扫描搜索结果进行确认</li>
      <li>对象过大时计算量大——对象越小越好</li>
    </ul>
  </li>
  <li>查全率和查准率
    <ul>
      <li>搜索的恰当性的评测标准</li>
      <li>差准率=正确结果数/返回总数</li>
      <li>查全率=正确结果数/相关结果数</li>
    </ul>
  </li>
</ol>

<h3 id="postings的创建方法逆向索引的创建方法">Postings的创建方法——逆向索引的创建方法</h3>

<ol>
  <li>同时保存出现位置
    <ul>
      <li>Full Inverted Index</li>
      <li>很容易实现snippet，评分， 过滤</li>
    </ul>
  </li>
  <li>只保存文档ID
    <ul>
      <li>Inverted File Index</li>
      <li>索引较小，容易实现</li>
    </ul>
  </li>
</ol>

<h4 id="postings和数据结构">Postings和数据结构</h4>

<ol>
  <li>文档ID顺序
    <ul>
      <li>排序——可变字节码</li>
      <li>较好的压缩比和快速压缩解压性能</li>
    </ul>
  </li>
  <li>结构：term——压缩后的Posting List
    <ul>
      <li>适合使用key-value存储</li>
    </ul>
  </li>
</ol>

<hr />

<h1 id="支持大规模数据处理的服务器基础设施入门web服务的后台">支持大规模数据处理的服务器/基础设施入门——Web服务的后台</h1>

<h2 id="企业软件vs-web服务应用范围上的差异">企业软件vs Web服务——应用范围上的差异</h2>

<ol>
  <li>Web服务的流量更大</li>
  <li>Web服务可能发生爆炸性增长</li>
  <li>Web服务有时允许暂时的不一致</li>
</ol>

<h2 id="web服务的基础设施三个重点">Web服务的基础设施——三个重点</h2>

<ol>
  <li>低成本，高效率
    <ul>
      <li>不应当追求100%可靠性</li>
    </ul>
  </li>
  <li>设计很重要
    <ul>
      <li>可扩展性，响应性很重要</li>
    </ul>
  </li>
  <li>开发速度很重要
    <ul>
      <li>应当为服务提供灵活的资源</li>
    </ul>
  </li>
</ol>

<h2 id="云vs自行构建基础设施">云Vs.自行构建基础设施</h2>

<h3 id="云计算仍处于过渡期">云计算仍处于过渡期？</h3>

<ol>
  <li>优点
    <ul>
      <li>价格便宜，灵活的可扩展性</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>统一的主机规格</li>
      <li>模糊不清的负载均衡器</li>
      <li>时常停机</li>
    </ul>
  </li>
</ol>

<h3 id="自行构建基础设施的优点">自行构建基础设施的优点：</h3>

<ul>
  <li>灵活的硬件配置</li>
  <li>灵活应对服务要求</li>
  <li>可以控制瓶颈</li>
</ul>

<hr />

<h1 id="保证可扩展性的必要思路规模扩大和系统扩展">保证可扩展性的必要思路——规模扩大和系统扩展</h1>

<h2 id="层和可扩展性">层和可扩展性</h2>

<ol>
  <li>应用的程序服务器
    <ul>
      <li>配置相同，不持有状态——扩展容易</li>
    </ul>
  </li>
  <li>数据源（数据库，文件服务器等
    <ul>
      <li>read分布式——比较容易</li>
      <li>write分布式——难</li>
    </ul>
  </li>
</ol>

<h2 id="掌握负载均衡进行调优">掌握负载均衡进行调优</h2>

<h3 id="掌握负载可视化的管理界面">掌握负载——可视化的管理界面</h3>

<h3 id="测量负载的指标平均负载内存和cpu相关信息">测量负载的指标——平均负载，内存和CPU相关信息</h3>

<h3 id="根据用途进行调优面向用户的服务器和面向爬虫的服务器">根据用途进行调优——面向用户的服务器和面向爬虫的服务器</h3>

<h3 id="应用程序服务器数据库服务器的调优策略和服务器数量">应用程序服务器，数据库服务器的调优策略和服务器数量</h3>

<h3 id="服务规模和调优">服务规模和调优</h3>

<h3 id="保证可扩展性">保证可扩展性</h3>

<hr />

<h1 id="保证冗余性和系统的稳定化实现100在效率的原理">保证冗余性和系统的稳定化——实现100%在效率的原理</h1>

<p>最重要的就是去除SPOF（single point of failure）， 即单点故障</p>

<h2 id="保证冗余性">保证冗余性</h2>

<h3 id="保证冗余性应用程序服务器">保证冗余性——应用程序服务器</h3>

<ol>
  <li>增加服务器数量, 即使一两台停机也能保证充足的处理能力</li>
  <li>用负载均衡实现失败转移(failover)和失败恢复(failback)</li>
</ol>

<h3 id="保证冗余性数据库服务器">保证冗余性——数据库服务器</h3>

<ol>
  <li>Multi-master, 服务器用VRRP协议（Virtual Router Redundancy Protocol， 虚拟路由器冗余协议）互相监视， 一旦通过VRRP发现对方停机， 就将自己提升为Active master</li>
  <li>互相replication</li>
  <li>切换时会有不同步的风险， 有问题时人工恢复</li>
</ol>

<h3 id="保证冗余性存储服务器">保证冗余性——存储服务器</h3>

<h2 id="系统稳定化">系统稳定化</h2>

<h3 id="保持系统稳定的权衡">保持系统稳定的权衡</h3>

<ol>
  <li>内存只使用7成左右， CPU只使用7成左右</li>
</ol>

<h3 id="不稳定的因素负载增大">不稳定的因素——负载增大</h3>

<ol>
  <li>功能增加， 内存泄漏， 地雷， 用户访问模式， 数据量增加， 外部关联程序增加
    <ul>
      <li>地雷：某些URL一旦读取（踩到）就无法返回应答</li>
      <li>slashdot效应， digg效应等， 链接被贴到著名网站上， 被大量用户访问导致系统停机</li>
    </ul>
  </li>
  <li>硬件的不稳定定因素——性能下降
    <ul>
      <li>内存，硬盘，网卡故障</li>
    </ul>
  </li>
</ol>

<h2 id="系统稳定对策">系统稳定对策</h2>

<h3 id="实际的系统稳定对策维持适当余量消灭不稳定因素">实际的系统稳定对策——维持适当余量，消灭不稳定因素</h3>

<ol>
  <li>维持适当余量（buffer）
    <ul>
      <li>内存容量，CPU负载——使用极限的7成</li>
    </ul>
  </li>
  <li>去除不稳定因素
    <ul>
      <li>规定SQL负载上限——必要时将负载过高的SQL移到其他主机上</li>
      <li>减少内存泄漏</li>
    </ul>
  </li>
  <li>异常行为的自主判断/自动控制
    <ul>
      <li>自动Dos判断（mod_dossdetector）</li>
      <li>自动重启</li>
      <li>自动终止耗时查询（KILL掉耗时过长的SQL</li>
    </ul>
  </li>
</ol>

<hr />

<h1 id="提高效率提高硬件资源的使用率">提高效率——提高硬件资源的使用率</h1>

<h2 id="虚拟化技术">虚拟化技术</h2>

<h3 id="引入虚拟化技术">引入虚拟化技术</h3>

<ol>
  <li>可扩展性
    <ul>
      <li>将额外开销降至最低</li>
    </ul>
  </li>
  <li>性价比
    <ul>
      <li>提高资源使用率</li>
      <li>提高运维的灵活程度</li>
    </ul>
  </li>
  <li>高可用性
    <ul>
      <li>环境隔离</li>
    </ul>
  </li>
</ol>

<h3 id="虚拟化技术的效果">虚拟化技术的效果</h3>

<ol>
  <li>掩盖硬件差异（环境抽象化</li>
  <li>使用准虚拟化（para Virtualization</li>
  <li>控制资源消耗</li>
</ol>

<h3 id="虚拟服务器的构建策略">虚拟服务器的构建策略</h3>

<ol>
  <li>提高硬件资源的利用率
    <ul>
      <li>加入能主要利用空闲资源的虚拟化操作系统（DomU</li>
      <li>CPU空闲——Web服务器</li>
      <li>I/O空闲——数据库服务器</li>
      <li>内存空闲——缓存服务器</li>
    </ul>
  </li>
  <li>避免在一起的组合
    <ul>
      <li>资源消耗倾向相同， 且负载较高的同类服务器应避免放在一起</li>
    </ul>
  </li>
  <li>不使用中央存储设备</li>
</ol>

<h3 id="总结虚拟化的优势">总结虚拟化的优势</h3>

<ol>
  <li>解除物理的资源限制
    <ul>
      <li>动态更改资源</li>
      <li>VM的迁移和复制</li>
    </ul>
  </li>
  <li>软件层面更强大的主机控制
    <ul>
      <li>异常行为局部化</li>
      <li>主机控制更容易</li>
    </ul>
  </li>
</ol>

<h2 id="硬件和提高效率实现低成本的关键技术">硬件和提高效率——实现低成本的关键技术</h2>

<h3 id="提高处理器性能">提高处理器性能</h3>

<h3 id="有效利用廉价硬件">有效利用廉价硬件</h3>

<ol>
  <li>最低限度的管理功能</li>
  <li>多核CPU</li>
  <li>大量内存</li>
  <li>灵活的I/O性能
    <ul>
      <li>无盘</li>
      <li>硬件RAID-10</li>
      <li>SSD RAID-0</li>
    </ul>
  </li>
</ol>

<h3 id="ssd">SSD</h3>

<ol>
  <li>良好的随机访问性能</li>
  <li>内存&gt;SSD&gt;HHD RAID-0/10&gt;HDD RAID-1</li>
  <li>SSD损耗程度的指标是S.M.A.R.T值中的E9（media wearout indicator）项目， 随着平均擦除次数的增加， 该值会从100减少到0（smartctl命令获得</li>
</ol>

<hr />

<h1 id="web服务和网络通过网络看服务增长">Web服务和网络——通过网络看服务增长</h1>

<h2 id="网络的分界点">网络的分界点</h2>

<ol>
  <li>超过1Gbps（300kpps）——PC路由器的极限（成品路由器</li>
  <li>超过500台主机——一个子网的极限</li>
  <li>全球化——一个数据中心的极限（可选CDN</li>
</ol>

<h2 id="挑战更高的极限">挑战更高的极限</h2>

<p>超越10Gbps的世界</p>

<ol>
  <li>获取AS编号</li>
  <li>连接IX进行流量交换</li>
  <li>用BGP控制路由</li>
</ol>

<hr />

<h1 id="当前构建web服务需要的实践技术应对大规模web服务须知">当前构建Web服务需要的实践技术——应对大规模Web服务须知</h1>

<h2 id="作业队列系统theschwartz-gearman">作业队列系统TheSchwartz， Gearman</h2>

<ol>
  <li>客户端放入作业</li>
  <li>作业队列存储队列</li>
  <li>worker访问作业队列，取出未运行的作业并加以运行</li>
</ol>

<h3 id="gearman">Gearman</h3>

<ol>
  <li>轻量作业队列， 不用RDBMS， 而是采用自带的守护进程（daemon）作业信息保存在内存中， 以保证性能</li>
  <li>三种模式
    <ul>
      <li>同步的顺序处理</li>
      <li>同步的并行处理</li>
      <li>异步的后台处理</li>
    </ul>
  </li>
</ol>

<h2 id="存储方式的选择-rdbms还是key-value存储">存储方式的选择 RDBMS还是key-value存储</h2>

<h3 id="分布式文件系统">分布式文件系统</h3>

<ol>
  <li>MogileFS</li>
</ol>

<h2 id="缓存系统squidvarnish">缓存系统——Squid，Varnish</h2>

<h2 id="计算集群hadoop">计算集群——Hadoop</h2>

<hr />


  <address class="signature">
    <a class="author" href="/">Yan Peipan</a>
    <span class="date">26 February 2015</span>
    <span class="location"></span>
  </address>
  <div class="prev-next">
    
    <a href="/2015/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.html" class="next" title="深入理解计算机系统">Next Post &rarr;</a>
    
    
    <a href="/2015/01/25/%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF.html" class="prev" title="大规模网站开发技术">&larr; Earlier Post</a>
    
  </div>
</div><!-- End Page -->




    <div id="footer">
      <address>
        <span class="copyright">
          Content by <a href="/sitemap.txt">Yan Peipan</a>.
        </span>
        <span class="engine">
          Powered by <a href="http://github.com/mojombo/jekyll/" title="A static, minimalist CMS">Jekyll</a>
        </span>
      </address>
    </div>
  </div>
  <!--[if IE 6]>
  <script type="text/javascript">
  /*Load jQuery if not already loaded*/ if(typeof jQuery == 'undefined'){ document.write("<script type=\"text/javascript\"   src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js\"></"+"script>"); var __noconflict = true; }
  var IE6UPDATE_OPTIONS = {
  icons_path: "http://static.ie6update.com/hosted/ie6update/images/"
}
</script>
<script type="text/javascript" src="http://static.ie6update.com/hosted/ie6update/ie6update.js"></script>
<![endif]-->


</body>
</html>

