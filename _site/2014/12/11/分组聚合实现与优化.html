

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>分组聚合实现与优化 &larr; </title>
  <meta name="author" content="Yan Peipan" />
  <link rel="start" href="/" />
  
  
  
  <!-- syntax highlighting CSS -->
  <link rel="stylesheet" href="/assets/themes/mark-reid/css/syntax.css" type="text/css" />
  <!-- Homepage CSS -->
  <link rel="stylesheet" href="/assets/themes/mark-reid/css/screen.css" type="text/css" />
</head>
<body id="">
  <div id="site">
    <div id="header">
      <h1>
        <a href="/" title="Yan">Yan</a>
        <span class="byline">&larr; <a href="/">Yan Peipan</a></span>
      </h1>
      <ul class="nav">
        <li><a href="/" class="home">Home</a></li>
        <li><a href="/archive.html">Archive</a></li>
        <li><a href="/pages.html">Pages</a></li>
        <li><a href="/categories.html">Categories</a></li>
        <li><a href="/tags.html">Tags</a></li>
      </ul>
    </div>
    

<div id="page">
  <h1 class="emphnext">分组聚合实现与优化</h1>
  <ul class="tag_box inline">
    
    

  
    
    	<li><a href="/tags.html#MySQL-ref">MySQL <span>3</span></a></li>
    
    	<li><a href="/tags.html#数据聚合-ref">数据聚合 <span>1</span></a></li>
    
  



  </ul>
  
<hr />

<h1 id="一个通用问题">一个通用问题</h1>

<p>如何查找所有频道正在播出的节目？ 如何查找所有分类下最热门的内容？ 如何查找所有运动员的最好成绩？<br />
这些问题都可以抽象为：如何取分组的最值？</p>

<hr />

<h1 id="sql">SQL</h1>

<p>数据库：MySQL</p>

<h2 id="基于sql的几种实现">基于SQL的几种实现</h2>

<p>任务：为每件物品找到标价最高的经销商</p>

<h3 id="关联子查询">关联子查询</h3>

<p>最好理解， 一般情况下，应该避免子查询，效率非常低。</p>

<pre><code>SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article);
</code></pre>

<h3 id="非关联子查询">非关联子查询</h3>

<pre><code>SELECT s1.article, dealer, s1.price
FROM shop s1
JOIN (
  SELECT article, MAX(price) AS price
  FROM shop
  GROUP BY article) AS s2
  ON s1.article = s2.article AND s1.price = s2.price;
</code></pre>

<h3 id="左关联">左关联</h3>

<pre><code>SELECT s1.article, s1.dealer, s1.price
FROM shop s1
LEFT JOIN shop s2 ON s1.article = s2.article AND s1.price &lt; s2.price
WHERE s2.article IS NULL;
</code></pre>

<hr />

<h2 id="名词解释">名词解释</h2>

<ul>
  <li>
    <p>B+树
B+树是一种经典的数据结构，由平衡树和二叉查找树结合产生，它是为磁盘或其它直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有的记录节点都是按键值大小顺序存放在同一层的叶节点中，叶节点间用指针相连，构成双向循环链表，非叶节点（根节点、枝节点）只存放键值，不存放实际数据。</p>
  </li>
  <li>
    <p>覆盖索引
包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)。</p>
  </li>
  <li>松散索引扫描
当 MySQL 完全利用索引扫描来实现 <code>GROUP BY</code> 的时候，并不需要扫描所有满足条件的索引键即可完成操作得出结果。<br />
要利用到松散索引扫描实现GROUP BY，需要至少满足以下几个条件：
    <ol>
      <li>GROUP BY 条件字段必须在同一个索引中最前面的连续位置；</li>
      <li>在使用GROUP BY 的同时，只能使用MAX 和MIN 这两个聚合函数；</li>
      <li>如果引用到了该索引中GROUP BY 条件之外的字段条件的时候，必须以常量形式存在；</li>
    </ol>
  </li>
  <li>紧凑索引扫描
紧凑索引扫描实现GROUP BY 和松散索引扫描的区别主要在于他需要在扫描索引的时候，读取所有满足条件的索引键，然后再根据读取的数据来完成GROUP BY 操作得到相应结果。</li>
</ul>

<h2 id="实例优化">实例优化</h2>

<h3 id="查找所有频道正在播出的节目">查找所有频道正在播出的节目</h3>

<p>表结构：</p>

<pre><code>CREATE TABLE `pt_l_program` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `lid` int(11) unsigned NOT NULL COMMENT '频道ID',
  `starttime` timestamp DEFAULT '0' COMMENT '节目开始时间',
  `program` varchar(255) DEFAULT '' COMMENT '节目单',
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique` (`lid`,`starttime`),
) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='节目单';
</code></pre>

<p>SQL：</p>

<pre><code>select SQL_SMALL_RESULT SQL_NO_CACHE  p1.id, p1.program, p1.starttime, p1.lid  from pt_l_program p1 inner join 
(select  max(starttime) as starttime,lid from pt_l_program where starttime&lt;=UNIX_TIMESTAMP()  group by lid order by null) p2 
on p1.lid=p2.lid and p1.starttime=p2.starttime;
</code></pre>

<p>索引：</p>

<pre><code>CREATE  INDEX Group_Search ON pt_l_program (lid,starttime,id,program);
</code></pre>

<p>Explain:<br />
分组时使用松散索引扫描，聚合数据时使用覆盖索引，完全避免了磁盘IO。如果需要考虑插入性能，则可以去掉<code>Group_Search</code>。
<img src="/assets/image/20141214001406.png" alt="" /></p>

<h2 id="问题扩展">问题扩展</h2>

<h3 id="分组取前n条值分组取第n条值">分组取前n条值/分组取第n条值</h3>

<p>问题有点难度，但SQL还是可以实现：</p>

<pre><code>set @num :=0, @lid := '';
select id, program,from_unixtime( starttime),channel_id  from (
	select id, program,starttime,
      @num := if(@lid = lid, @num + 1, 1) as row_number,
      @lid := lid as channel_id
  from pt_l_program
	where   starttime&lt;=unix_timestamp()
  order by lid, starttime desc 
) as p where p.row_number &lt;= 2;
</code></pre>

<p>利用Having过滤：</p>

<pre><code>set @num :=0, @lid := '', @now := 0;
desc select id, program,from_unixtime(starttime),
      @num := if(@lid = lid and @now&lt;starttime, @num + 1, 1) as row_number,
      @lid := lid as channel_id
from pt_l_program
where starttime&lt;=unix_timestamp() group by lid, starttime desc having row_number&lt;=2;
</code></pre>

<hr />

<h1 id="nosql">NoSQL</h1>

<p>数据库：MongoDB</p>

<h2 id="名词解释-1">名词解释</h2>

<p>聚合管道：管道是MongoDB2.2版本引入新的功能 ，它是数据聚合的一个新框架，其概念类似于数据处理的管道。</p>

<h2 id="导入数据">导入数据</h2>

<pre><code>mongoimport --type csv --file ~/program.csv --db pt --collection program --fields id,lid,starttime,program
</code></pre>

<h2 id="聚合">聚合</h2>

<pre><code>db.program.aggregate(
[
{$match:{}},
{ $project : { id : 1 , lid : 1, program:1, starttime:{$multiply:["$starttime", 1000]} } },
{$sort:{"lid":-1, "starttime":1}},
{$group : { _id :"$lid", program:{$first:"$program"}, starttime:{$first:"$starttime"  }}}
],
{explain:true}
)
</code></pre>

<hr />

<h1 id="参考">参考</h1>
<p><a href="http://www.xaprb.com/blog/2006/12/07/how-to-select-the-firstleastmax-row-per-group-in-sql/">How to select the first/least/max row per group in SQL</a><br />
<a href="http://www.51testing.com/html/52/n-229952.html">详解MySQL分组查询Group By实现原理</a><br />
<a href="http://www.cnmiss.cn/?p=373">MySQL优化GROUP BY－松散索引扫描与紧凑索引扫描</a><br />
<a href="http://www.iteedu.com//database/mysql/mysqlmanualcn/optimization/group-by-optimization.php">MySQL如何优化GROUP BY</a><br />
<a href="http://www.coder4.com/archives/1344">松散的索引扫描(Loose index scan)</a><br />
<a href="http://blog.csdn.net/dbanote/article/details/9083109">[MySQL] 索引与性能（1）- 索引类型</a><br />
<a href="http://www.cnblogs.com/Arlen/articles/1751227.html">MyISAM 索引结构了解 – MyISAM Index Structure</a><br />
<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p>


  <address class="signature">
    <a class="author" href="/">Yan Peipan</a>
    <span class="date">11 December 2014</span>
    <span class="location"></span>
  </address>
  <div class="prev-next">
    
    <a href="/2014/12/18/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAphp%E6%95%B0%E7%BB%84.html" class="next" title="深入浅出PHP数组">Next Post &rarr;</a>
    
    
    <a href="/2014/12/08/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8A%BD%E5%A5%96.html" class="prev" title="高并发抽奖">&larr; Earlier Post</a>
    
  </div>
</div><!-- End Page -->




    <div id="footer">
      <address>
        <span class="copyright">
          Content by <a href="/sitemap.txt">Yan Peipan</a>.
        </span>
        <span class="engine">
          Powered by <a href="http://github.com/mojombo/jekyll/" title="A static, minimalist CMS">Jekyll</a>
        </span>
      </address>
    </div>
  </div>
  <!--[if IE 6]>
  <script type="text/javascript">
  /*Load jQuery if not already loaded*/ if(typeof jQuery == 'undefined'){ document.write("<script type=\"text/javascript\"   src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js\"></"+"script>"); var __noconflict = true; }
  var IE6UPDATE_OPTIONS = {
  icons_path: "http://static.ie6update.com/hosted/ie6update/images/"
}
</script>
<script type="text/javascript" src="http://static.ie6update.com/hosted/ie6update/ie6update.js"></script>
<![endif]-->


</body>
</html>

