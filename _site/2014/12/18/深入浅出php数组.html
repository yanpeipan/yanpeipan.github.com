

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>深入浅出PHP数组 &larr; </title>
  <meta name="author" content="Yan Peipan" />
  <link rel="start" href="/" />
  
  
  
  <!-- syntax highlighting CSS -->
  <link rel="stylesheet" href="/assets/themes/mark-reid/css/syntax.css" type="text/css" />
  <!-- Homepage CSS -->
  <link rel="stylesheet" href="/assets/themes/mark-reid/css/screen.css" type="text/css" />
</head>
<body id="">
  <div id="site">
    <div id="header">
      <h1>
        <a href="/" title="Yan">Yan</a>
        <span class="byline">&larr; <a href="/">Yan Peipan</a></span>
      </h1>
      <ul class="nav">
        <li><a href="/" class="home">Home</a></li>
        <li><a href="/archive.html">Archive</a></li>
        <li><a href="/pages.html">Pages</a></li>
        <li><a href="/categories.html">Categories</a></li>
        <li><a href="/tags.html">Tags</a></li>
      </ul>
    </div>
    

<div id="page">
  <h1 class="emphnext">深入浅出PHP数组</h1>
  <ul class="tag_box inline">
    
    

  
    
    	<li><a href="/tags.html#PHP-ref">PHP <span>9</span></a></li>
    
  



  </ul>
  
<h1 id="数组的表达方式">数组的表达方式</h1>

<h2 id="构造数组的几种方法">构造数组的几种方法</h2>
<blockquote>
  <p>可以用 array() 语言结构来新建一个数组。它接受任意数量用逗号分隔的 键（key） =&gt; 值（value）对。</p>
</blockquote>

<blockquote>
  <p>自 5.4 起可以使用短数组定义语法，用 [] 替代 array()。</p>
</blockquote>

<h2 id="数组key和value的限制条件">数组key和value的限制条件</h2>

<blockquote>
  <p>key 可以是 integer 或者 string。value 可以是任意类型。</p>
</blockquote>

<blockquote>
  <p>此外 key 会有如下的强制转换：</p>
</blockquote>

<ul>
  <li>包含有合法整型值的字符串会被转换为整型。例如键名 “8” 实际会被储存为 8。但是 “08” 则不会强制转换，因为其不是一个合法的十进制数值。</li>
  <li>浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。</li>
  <li>布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。</li>
  <li>Null 会被转换为空字符串，即键名 null 实际会被储存为 ““。</li>
  <li>数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。</li>
</ul>

<blockquote>
  <p>如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。</p>
</blockquote>

<h2 id="php-predefined-interfaces-and-classes-预订义接口">PHP Predefined Interfaces and Classes 预订义接口</h2>

<h3 id="traversable遍历接口">Traversable（遍历）接口</h3>
<blockquote>
  <p>检测一个类是否可以使用 foreach 进行遍历的接口。
无法被单独实现的基本抽象接口。相反它必须由 IteratorAggregate 或 Iterator 接口实现。
这个接口没有任何方法，它的作用仅仅是作为所有可遍历类的基本接口。
PHP 已经提供了一些用于日常任务的迭代器。 详细列表参见 <a href="http://php.net/manual/zh/spl.iterators.php">SPL 迭代器</a>。</p>
</blockquote>

<h3 id="iteratoraggregate聚合式迭代器接口">IteratorAggregate（聚合式迭代器）接口</h3>
<blockquote>
  <p>创建外部迭代器的接口。</p>
</blockquote>

<h3 id="iterator迭代器接口">Iterator（迭代器）接口</h3>
<blockquote>
  <p>可在内部迭代自己的外部迭代器或类的接口。</p>
</blockquote>

<h3 id="arrayaccess数组式访问接口">ArrayAccess（数组式访问）接口</h3>
<blockquote>
  <p>提供像访问数组一样访问对象的能力的接口。</p>
</blockquote>

<h3 id="序列化接口">序列化接口</h3>
<blockquote>
  <p>自定义序列化的接口。实现此接口的类将不再支持 __sleep() 和 __wakeup()。不论何时，只要有实例需要被序列化，serialize 方法都将被调用。它将不会调用 __destruct() 或有其他影响，除非程序化地调用此方法。当数据被反序列化时，类将被感知并且调用合适的 unserialize() 方法而不是调用 __construct()。如果需要执行标准的构造器，你应该在这个方法中进行处理。</p>
</blockquote>

<h3 id="closure-类">Closure 类</h3>
<blockquote>
  <p>用于代表 匿名函数 的类.
匿名函数（在 PHP 5.3 中被引入）会产生这个类型的对象。在过去，这个类被认为是一个实现细节，但现在可以依赖它做一些事情。自 PHP 5.4 起，这个类带有一些方法，允许在匿名函数创建后对其进行更多的控制。
除了此处列出的方法，还有一个 __invoke 方法。这是为了与其他实现了 __invoke()魔术方法 的对象保持一致性，但调用匿名函数的过程与它无关。</p>
</blockquote>

<h2 id="实现php数组式访问接口">实现PHP数组式访问接口</h2>
<pre><code>class Test implements Iterator{
    private $item = array('a' =&gt; 4, 1, 2, 3);

    public function rewind() {
        reset($this-&gt;item);
    }

    public function current() {
        return current($this-&gt;item);
    }

    public function key() {
        return key($this-&gt;item);
    }

    public function next() {
        return next($this-&gt;item);
    }

    public function valid() {
        return($this-&gt;current() !== false);
    }
 }

 $t = new Test;
 foreach($t as $k =&gt; $v){
     var_dump($k, $v);
 }
</code></pre>

<h2 id="php目前有哪些预订义数组各是什么用途">PHP目前有哪些预订义数组，各是什么用途？</h2>

<h3 id="globals">$GLOBALS</h3>
<p>引用全局作用域中可用的全部变量</p>

<h3 id="_server">$_SERVER</h3>
<p>$HTTP_SERVER_VARS [已弃用] — 服务器和执行环境信息<br />
$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。这也就意味着大量的此类变量都会在» CGI 1.1 规范中说明，所以应该仔细研究一下。</p>

<h3 id="_get">$_GET</h3>
<p>$_GET – $HTTP_GET_VARS [已弃用] — HTTP GET 变量</p>

<h3 id="_post">$_POST</h3>
<p>$_POST – $HTTP_POST_VARS [已弃用] — HTTP POST 变量</p>

<h3 id="_files">$_FILES</h3>
<p>HTTP 文件上传变量</p>

<h3 id="_cookie">$_COOKIE</h3>
<p>HTTP Cookies</p>

<h3 id="_session">$_SESSION</h3>
<p>Session 变量</p>

<h3 id="_request">$_REQUEST</h3>
<p>默认情况下包含了 $_GET，$_POST 和 $_COOKIE 的数组。</p>

<h3 id="_env">$_ENV</h3>
<p>$_ENV – $HTTP_ENV_VARS [已弃用] — 环境变量
通过环境方式传递给当前脚本的变量的数组。</p>

<p>这些变量被从 PHP 解析器的运行环境导入到 PHP 的全局命名空间。很多是由支持 PHP 运行的 Shell 提供的，并且不同的系统很可能运行着不同种类的 Shell，所以不可能有一份确定的列表。请查看你的 Shell 文档来获取定义的环境变量列表。<br />
其他环境变量包含了 CGI 变量，而不管 PHP 是以服务器模块还是 CGI 处理器的方式运行。<br />
$HTTP_ENV_VARS 包含相同的信息，但它不是一个超全局变量。 (注意 $HTTP_ENV_VARS 和 $_ENV 是不同的变量，PHP 处理它们的方式不同)</p>

<h2 id="_evn是什么如何让_evn有效">$_EVN是什么，如何让$_EVN有效？</h2>

<hr />

<h1 id="数组类型转换">数组类型转换</h1>

<h2 id="其它数据类型转换为数组有什么规律">其它数据类型转换为数组有什么规律？</h2>

<blockquote>
  <p>对于任意 integer，float，string，boolean 和 resource 类型，如果将一个值转换为数组，将得到一个仅有一个元素的数组，其下标为 0，该元素即为此标量的值。换句话说，(array)$scalarValue 与 array($scalarValue) 完全一样。<br />
如果一个 object 类型转换为 array，则结果为一个数组，其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 ‘*’ 做前缀。这些前缀的前后都各有一个 NULL 字符。这会导致一些不可预知的行为<br />
将 NULL 转换为 array 会得到一个空的数组。</p>
</blockquote>

<h2 id="有哪些方法可以实现数组的串行化">有哪些方法可以实现数组的串行化？</h2>

<p><code>serialize</code> <code>unserialize</code><br />
<code>json_encode</code> <code>json_decode</code><br />
<code>implode</code> <code>explode</code><br />
<code>CJSON</code></p>

<hr />

<h1 id="数组的遍历">数组的遍历</h1>

<h2 id="遍历数组有多少种方法如何选用这些方法">遍历数组有多少种方法，如何选用这些方法？</h2>

<ul>
  <li>for</li>
  <li>foreach</li>
  <li>list each</li>
  <li>array_walk</li>
  <li>array_map</li>
  <li>end current next pos prev reset</li>
</ul>

<h2 id="array_walk-与-array_map-有什么不同"><code>array_walk</code> 与 <code>array_map</code> 有什么不同？</h2>

<p><strong>array array_map ( callable $callback , array $arr1 [, array $… ] )</strong></p>

<blockquote>
  <p>array_map() 返回一个数组，该数组包含了 arr1 中的所有单元经过 callback 作用过之后的单元。callback 接受的参数数目应该和传递给 array_map() 函数的数组数目一致。</p>
</blockquote>

<p><strong>bool array_walk ( array &amp;$array , callable $funcname [, mixed $userdata = NULL ] )</strong></p>

<blockquote>
  <p>array_walk() 不会受到 array 内部数组指针的影响。array_walk() 会遍历整个数组而不管指针的位置。将用户自定义函数 funcname 应用到 array 数组中的每个单元。</p>
</blockquote>

<h2 id="for-和-foreach-谁更快呢为什么"><code>for</code> 和 <code>foreach</code> 谁更快呢？为什么？</h2>

<blockquote>
  <p>有很多关于PHP数组的遍历效率的误解。我打算尽量揭开它的神秘面纱。</p>
</blockquote>

<p>测试分为两个部分：</p>

<ol>
  <li>读：只遍历数组，不修改数组</li>
  <li>写：遍历数组，并修改数组</li>
</ol>

<p>测试版本：PHP 5.5.9-1ubuntu4.5 (cli) (built: Oct 29 2014 11:59:10)<br />
测试数组：<code>$array = range(1, 1000000);</code></p>

<p><strong>测试读</strong></p>

<pre><code>$start = microtime(true);
foreach($array as $value){$value;};
printf('%.6f' . PHP_EOL, microtime(true) - $start);

$start = microtime(true);
$count = count($array);
for($i=0;$i&lt;$count;$i++){$array[$i];}
printf('%.6f' . PHP_EOL, microtime(true) - $start);
</code></pre>

<p>常见错误：</p>

<ol>
  <li>比较两个空循环：<code>foreach($array as $value);</code> <code>for($i=0;$i&lt;$count;$i++);</code> <code>for-loop</code>根本没有遍历数组，因此结果没有多少参考价值。</li>
  <li><code>for($i=0;$i&lt;count($array);$i++)</code> PHP每次循环都会重新计算<code>count($array)</code>的值，虽然时间复杂度为1，但仍会对结果产生影响。</li>
</ol>

<p>结果分析：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">foreach</th>
      <th style="text-align: left"> </th>
      <th>for</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">0.040372</td>
      <td style="text-align: left"> </td>
      <td>0.063877</td>
    </tr>
  </tbody>
</table>

<p>结果分析：
PHP数组内部指针(Bucket *pInternalPointer)指向当前数组元素(Bucket)，当前数组元素保存着指向下一元素的指针(struct bucket *pListNext)，<code>foreach</code>能用到这个结构快速遍历整个数组。
<code>for-loop</code>的开销在于哈希算法，以及哈希冲突时遍历整个Bucket（PHP中的哈希表是使用拉链法来解决冲突的，具体点讲就是使用链表来存储哈希到同一个槽位的数据， Zend为了保存数据之间的关系使用了双向列表来链接元素)</p>

<p><strong>测试写</strong></p>

<pre><code>$start = microtime(true);
foreach($array as $key =&gt; $value) {
	$array[$key] += 1;
}
printf('%.6f' . PHP_EOL, microtime(true) - $start);

$start = microtime(true);
$count = count($array);
for($i=0;$i&lt;$count;$i++) {
	$array[$i] += 1;
}
printf('%.6f' . PHP_EOL, microtime(true) - $start);
</code></pre>

<p>常见错误：</p>

<ol>
  <li>只测试读性能，忽略写性能</li>
  <li>测试写的代码本身有个问题，待会再说</li>
</ol>

<p>结果分析：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">foreach</th>
      <th style="text-align: left"> </th>
      <th>for</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">0.299544</td>
      <td style="text-align: left"> </td>
      <td>0.077412</td>
    </tr>
  </tbody>
</table>

<p><code>foreach</code>循环性能下降很快，主要性能消耗在执行变量分离（PHP的COW机制（copy on write 写时复制)，遍历时<code>$value</code> and <code>$array[$key]</code>共同指向一个<code>Bucket</code>, 所以性能损耗很小，但当其中一个值改变时，则需要执行变量分离)</p>

<p>*这也是测试代码的问题所在，<code>foreach</code>不仅执行了哈希查找，还进行了变量分离，有个办法可以避免这个问题，但很少人用：</p>

<pre><code>foreach($array as &amp;$value) {
    $value += 1;
}
unset($value);
</code></pre>

<h2 id="php数组在底实现上是什么数据结构">PHP数组在底实现上是什么数据结构？</h2>

<p>PHP中的哈希表实现在Zend/zend_hash.c中， PHP使用如下两个数据结构来实现哈希表，HashTable结构体用于保存整个哈希表需要的基本信息， 而Bucket结构体用于保存具体的数据内容</p>

<pre><code>typedef struct _hashtable { 
    uint nTableSize;        // hash Bucket的大小，最小为8，以2x增长。
    uint nTableMask;        // nTableSize-1 ， 索引取值的优化
    uint nNumOfElements;    // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 
    ulong nNextFreeElement; // 下一个数字索引的位置
    Bucket *pInternalPointer;   // 当前遍历的指针（foreach比for快的原因之一）
    Bucket *pListHead;          // 存储数组头元素指针
    Bucket *pListTail;          // 存储数组尾元素指针
    Bucket **arBuckets;         // 存储hash数组
    dtor_func_t pDestructor;    // 在删除元素时执行的回调函数，用于资源的释放
    zend_bool persistent;       //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。
    unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归）
    zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次
#if ZEND_DEBUG
    int inconsistent;
#endif
} HashTable;
</code></pre>

<p><strong>数据容器：槽位</strong></p>

<pre><code>typedef struct bucket {
    ulong h;            // 对char *key进行hash后的值，或者是用户指定的数字索引值
    uint nKeyLength;    // hash关键字的长度，如果数组索引为数字，此值为0
    void *pData;        // 指向value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr
    void *pDataPtr;     //如果是指针数据，此值会指向真正的value，同时上面pData会指向此值
    struct bucket *pListNext;   // 整个hash表的下一元素
    struct bucket *pListLast;   // 整个哈希表该元素的上一个元素
    struct bucket *pNext;       // 存放在同一个hash Bucket内的下一个元素
    struct bucket *pLast;       // 同一个哈希bucket的上一个元素
    // 保存当前值所对于的key字符串，这个字段只能定义在最后，实现变长结构体
    char arKey[1];              
} Bucket;
</code></pre>

<p><img src="/assets/image/arrays.png" alt="" /></p>

<h2 id="如何用指针函数操作php数组">如何用指针函数操作PHP数组？</h2>

<pre><code>reset($array);
while(list($key, $value) = each($array));

$value = reset($array);
do {
} while($value = next($array));
</code></pre>

<h2 id="使用foreach时应该注意什么问题">使用<code>foreach</code>时应该注意什么问题？</h2>

<ol>
  <li>foreach 依赖内部数组指针，在循环中修改其值将可能导致意外的行为。</li>
  <li>当 foreach 开始执行时，数组内部的指针会自动指向第一个单元。这意味着不需要在 foreach 循环之前调用 reset()。</li>
  <li>数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用 unset() 来将其销毁。</li>
  <li>foreach 不支持用“@”来抑制错误信息的能力。</li>
  <li>foreach 结束循环时， 数组内部指针会指向下一个单元。</li>
</ol>

<h3 id="思考会输出什么结果为什么">思考，会输出什么结果？为什么？</h3>

<p>1.</p>

<pre><code>$array = array(1,2,3,4);
echo next($array);

foreach ($array as $value) {
  if (!next($array)) reset($array);
}

echo current($array);
</code></pre>

<p>2.</p>

<pre><code>$array = array(1,2,3,4);
foreach($array as $key =&gt; $value) {
	$array[$key] = &amp;$value;	
}
</code></pre>

<p>3.</p>

<pre><code>$array = array(1,2,3,4);
foreach($array as $key =&gt; $value) {
	$value = &amp;$array[$key];	
}
</code></pre>

<hr />

<h1 id="数组元素查找">数组元素查找</h1>

<h2 id="如何判断数组中key是否存在">如何判断数组中key是否存在？</h2>

<ol>
  <li><code>array_key_exists</code> 检查给定的键名或索引是否存在于数组中。</li>
  <li><code>isset</code> 检测变量是否设置，并且不是 NULL。</li>
</ol>

<h2 id="如何判断数组中值是否存在">如何判断数组中值是否存在？</h2>

<ol>
  <li><code>in_array</code>  检查数组中是否存在某个值</li>
  <li><code>array_search</code> 在数组中搜索给定的值，如果成功则返回相应的键名</li>
  <li><code>array_keys</code> 返回数组中所有的键名，如果指定了可选参数 search_value，则只返回该值的键名。否则 input 数组中的所有键名都会被返回。</li>
</ol>

<h2 id="如何依据数组的key返回值">如何依据数组的key返回值？</h2>

<p><code>$array[$key]</code></p>

<h2 id="如何依据数组的值返回key">如何依据数组的值返回key？</h2>

<ol>
  <li><code>array_flip</code></li>
  <li><code>array_search</code> 在数组中搜索给定的值，如果成功则返回相应的键名</li>
  <li><code>array_keys</code> 返回数组中所有的键名，如果指定了可选参数 search_value，则只返回该值的键名。否则 input 数组中的所有键名都会被返回。</li>
</ol>

<h2 id="如何依据给定值在数组进行模糊查找">如何依据给定值在数组进行模糊查找？</h2>

<pre><code>$array = array(599 =&gt; 'PHP', 'JAVA');
$search = 'P';
$result = array_filter(array_map(function($value) use ($search) {
		return is_numeric(strpos($value, $search)) ? $value :  false;
}, $array));
</code></pre>

<h2 id="二维或者多维数组数据处理有什么技巧">二维或者多维数组数据处理有什么技巧？</h2>

<pre><code>    $grade = array("score" =&gt; array(70, 95, 70.0, 60, "70"),
                   "name" =&gt; array("Zhang San", "Li Si", "Wang Wu",
                                   "Zhao Liu", "Liu Qi"));
    array_multisort($grade["score"], SORT_NUMERIC, SORT_DESC,
                    // 将分数作为数值，由高到低排序
                    $grade["name"], SORT_STRING, SORT_ASC);
                    // 将名字作为字符串，由小到大排序
</code></pre>

<pre><code>$data[] = array('volume' =&gt; 67, 'edition' =&gt; 2);
$data[] = array('volume' =&gt; 86, 'edition' =&gt; 1);
$data[] = array('volume' =&gt; 85, 'edition' =&gt; 6);
$data[] = array('volume' =&gt; 98, 'edition' =&gt; 2);
$data[] = array('volume' =&gt; 86, 'edition' =&gt; 6);
$data[] = array('volume' =&gt; 67, 'edition' =&gt; 7);

$volume  = array_column($data, 'volume');
$edition = array_column($data, 'edition');

array_multisort($volume, SORT_DESC, $edition, SORT_ASC, $data);
</code></pre>

<hr />

<h1 id="数组元素插入和移除">数组元素插入和移除</h1>

<h2 id="如何往php数组中任意位置加入元素">如何往PHP数组中任意位置加入元素？</h2>

<ul>
  <li>
    <p>array_splice — 把数组中的一部分去掉并用其它值取代。把 input 数组中由 offset 和 length 指定的单元去掉，如果提供了 replacement 参数，则用其中的单元取代。注意 input 中的数字键名不被保留。
<code>array_splice($array, 1, 0, array('Python', 'JAVASCRIPT'));</code></p>
  </li>
  <li>
    <p>array_slice — 从数组中取出一段</p>
  </li>
</ul>

<h2 id="php数组元素的过滤和移除有哪些方法可以实现">PHP数组元素的过滤和移除有哪些方法可以实现？</h2>

<ul>
  <li>array_filter — 用回调函数过滤数组中的单元</li>
</ul>

<blockquote>
  <p>array array_filter ( array $input [, callable $callback = “” ] )<br />
依次将 input 数组中的每个值传递到 callback 函数。如果 callback 函数返回 TRUE，则 input 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p>
</blockquote>

<hr />

<h1 id="数组的排序和对比">数组的排序和对比</h1>

<h2 id="如何巧妙记忆php数组中的排序函数">如何巧妙记忆PHP数组中的排序函数？</h2>

<ul>
  <li>sort() - 以升序对数组排序</li>
  <li>rsort() - 以降序对数组排序</li>
  <li>asort() - 根据值，以升序对关联数组进行排序</li>
  <li>ksort() - 根据键，以升序对关联数组进行排序</li>
  <li>arsort() - 根据值，以降序对关联数组进行排序</li>
  <li>krsort() - 根据键，以降序对关联数组进行排序</li>
</ul>

<h2 id="如何运用array_multisort函数">如何运用<code>array_multisort</code>函数？</h2>

<h2 id="如何对php多维数组和对象数组排序">如何对PHP多维数组和对象数组排序？</h2>

<hr />

<h1 id="数组和数据结构">数组和数据结构</h1>

<h2 id="php数组能够实现哪些数据结构">PHP数组能够实现哪些数据结构？</h2>

<ul>
  <li>堆</li>
  <li>栈</li>
  <li>队列</li>
</ul>

<h2 id="php数组如何进行集合相关的运算">PHP数组如何进行集合相关的运算？</h2>

<ul>
  <li>array_merge 合并一个或多个数组<br />
array array_merge ( array $array1 [, array $… ] )<br />
array_merge() 将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。
如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。然而，如果数组包含数字键名，后面的值将不会覆盖原来的值，而是附加到后面。
如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引。</li>
  <li>array_chunk — 将一个数组分割成多个<br />
array array_chunk ( array $input , int $size [, bool $preserve_keys = false ] )<br />
将一个数组分割成多个数组，其中每个数组的单元数目由 size 决定。最后一个数组的单元数目可能会少于 size 个。</li>
  <li>array_diff 计算数组的差集<br />
array array_diff ( array $array1 , array $array2 [, array $… ] )<br />
对比返回在 array1 中但是不在 array2 及任何其它参数数组中的值。</li>
</ul>

<h2 id="巧妙实现遍历子集">巧妙实现遍历子集</h2>

<pre><code>array_map(function($value) {}, $array);
</code></pre>

<h2 id="php数组如何实现堆栈">PHP数组如何实现堆栈？</h2>

<ul>
  <li>堆 <code>SplHeap</code></li>
  <li>栈 <code>SplStack</code></li>
</ul>

<h2 id="用堆栈解决10进制转换为2进制数">用堆栈解决10进制转换为2进制数</h2>

<pre><code>$n = 254;
$a = [];
while($n &gt; 1) {
	$a[] = $n % 2;
	$n &gt;&gt;= 1;
}
echo implode('', array_reverse($a));
</code></pre>

<h2 id="使用队列的方式解决目录遍历">使用队列的方式解决目录遍历</h2>

<p><strong>递归调用</strong></p>

<pre><code>function recursiveDirectory($dir) {
	if (is_dir($dir) &amp;&amp; $db = opendir($dir)) {
		while ($file = readdir($db)) {
			$path = $dir . '/' . $file;
			if (in_array($file, array('.', '..'))) {
				$files[] = $file;
				continue;
			} elseif (is_dir($path)) {
				RecursiveDirectory($path);
			} elseif (is_file($path)) {
			}
		}	
		closedir($db);
	}
}
</code></pre>

<p><strong>使用队列</strong></p>

<pre><code>function queueDirectory($dir) {
	$queue = array('');
	while (($file = array_shift($queue)) !== null) {
		$path = join(DIRECTORY_SEPARATOR, array($dir, $file));
		if (in_array($file, array('.', '..'))) {
			$files[] = $file;
			continue;
		} elseif (is_dir($path) &amp;&amp; $dh = opendir($path)) {
			while ($file = readdir($dh)) {
				$queue[] = $file;
			}
			closedir($dh);
		} elseif (is_file($path)) {
		}
	}
}
</code></pre>

<p><strong>使用SPL</strong></p>

<pre><code>$objects = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path), RecursiveIteratorIterator::SELF_FIRST);
foreach($objects as $name =&gt; $object){
}
</code></pre>

<h2 id="约瑟夫环问题">“约瑟夫环”问题</h2>

<pre><code>function josephus($n, $m) {
    $i = 1;
    while (count($n) &gt; 1) {
        foreach ($n as $k =&gt; $v) {
            if ($i++ == $m) {
                unset($n[$k]);
                $i = 1;
            }
        }
    }

    return array_pop($n);
}
</code></pre>

<pre><code>function josephus($total, $index) {
    $result = 0;
    for($i=2; $i&lt;= $total; $i++) {
        $result = ($result + $index) % $i;
    }
    $num = $result + 1;
    
    return $num;
}
</code></pre>
<hr />

<h1 id="参考">参考</h1>
<p><a href="http://www.laruence.com/2009/08/23/1065.html">深入理解PHP之数组(遍历顺序)</a><br />
<a href="http://www.laruence.com/2008/11/20/630.html">深入理解PHP原理之foreach</a><br />
<a href="http://www.php-internals.com/book/">深入理解PHP内核</a><br />
<a href="http://www.phpbench.com/">The PHP Benchmark</a><br />
<a href="http://sheriframadan.com/2012/10/a-closer-look-into-php-arrays/">A Closer Look Into PHP Arrays: What You Don’t See</a><br />
<a href="http://www.laruence.com/2008/09/19/520.html">深入理解PHP原理之变量分离/引用(Variables Separation)</a>\</p>

  <address class="signature">
    <a class="author" href="/">Yan Peipan</a>
    <span class="date">18 December 2014</span>
    <span class="location"></span>
  </address>
  <div class="prev-next">
    
    <a href="/2014/12/21/php%E6%96%87%E4%BB%B6%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.html" class="next" title="PHP文件核心编程">Next Post &rarr;</a>
    
    
    <a href="/2014/12/11/%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96.html" class="prev" title="分组聚合实现与优化">&larr; Earlier Post</a>
    
  </div>
</div><!-- End Page -->




    <div id="footer">
      <address>
        <span class="copyright">
          Content by <a href="/sitemap.txt">Yan Peipan</a>.
        </span>
        <span class="engine">
          Powered by <a href="http://github.com/mojombo/jekyll/" title="A static, minimalist CMS">Jekyll</a>
        </span>
      </address>
    </div>
  </div>
  <!--[if IE 6]>
  <script type="text/javascript">
  /*Load jQuery if not already loaded*/ if(typeof jQuery == 'undefined'){ document.write("<script type=\"text/javascript\"   src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js\"></"+"script>"); var __noconflict = true; }
  var IE6UPDATE_OPTIONS = {
  icons_path: "http://static.ie6update.com/hosted/ie6update/images/"
}
</script>
<script type="text/javascript" src="http://static.ie6update.com/hosted/ie6update/ie6update.js"></script>
<![endif]-->


</body>
</html>

