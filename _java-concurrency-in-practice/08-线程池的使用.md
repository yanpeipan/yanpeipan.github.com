---
title: 第7章 取消与关闭
excerpt: 
last_modified_at: '2021-02-02'
toc: true
tags:
- Java
- concurrency
---

## 在任务与执行策略之间的隐性耦合

有些类型的任务需要明确的指明执行策略：

* 依赖性任务。如果提交线程池的任务需要依赖其他任务，那么就隐含的给执行策略带来了约束，此时应小心的避免产生活跃性问题
* 使用线程封闭机制的任务。单线程的 Executor 能够保证任务不会并发执行
* 对响应时间敏感的任务。
* 使用 ThreadLocal 的任务。线程池的线程中不应该使用 ThreadLocal 在任务之间传递值

只有当任务是相同类型并且相互独立时，线程池的性能才能达到最佳。

### 线程饥饿死锁

在单线程 Executor 中任务发生死锁

```java
public class ThreadDeaklock {
  ExecutorService exec = Executors.newSingleThreadExecutor();
  
  public class RenderPageTask implements Callable<String> {
    public String call() throws Exception {
      Future<String> header, footer;
      header = exec.submit(new LoadFileTask("header.html"));
      footer = exec.submit(new LoadFileTask("footer.html"));
      String page = renderBody();
      // 将发生死锁 -- 由于任务在等待子任务的结果
      return header.get() + page + footer.get();
    }
  }
}
```

