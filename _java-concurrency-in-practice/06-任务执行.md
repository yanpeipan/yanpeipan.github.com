---
title: 第6章 任务执行
excerpt: 
last_modified_at: '2021-02-02'
toc: true
tags:
- Java
- concurrency
---

## 在线程中执行任务
当围绕“任务执行”设计应用程序结构时，第一步就是要找出清晰的任务边界。大多数服务应用程序都提供了一种自然的边界选择方式：以独立的客户请求为边界。

### 串行地执行任务
串行处理机制通常都无法提供高吞吐率或快速响应性。
```java
class SingleThreadWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            Socket connection = socket.accept();
            handleRequest(connection);
        }
    }
}
```
### 显示的为任务创建线程
为每个请求创建一个新的线程来提供服务，从而实现更高的响应性
```java
class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run() {
                    handleRequest(connection);
                }
            };
            new Thread(task).start();
        }
    }
}
```
### 无限制创建线程的不足

* 线程生命周期的开销非常高
* 资源消耗：线程多余处理器的数量时线程闲置。闲置线程占用更多内存，给垃圾回收器带来压力，竞争 CPU 资源时产生额外开销。
* 稳定性：OOM

## Executor 框架
任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。通过有界队列防止高负荷的应用程序耗尽内存，线程池简化了线程的管理工作，并且`java.util.concurrent`提供一种灵活的线程池实现作为 Executor 框架的一部分。
```java
public interface Executor {
    void execute(Runnable command);
}
```
Executor 提供了标准的方法将任务的提交过程与执行过程解耦开，并用 Runnable 来表示任务。还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。

Executor 基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。  

### 示例：基于 Executor 的 Web 服务器

```java
class TaskExecutionWebServer {
  private static final int NTHREADS = 100;
  private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);
  
  public static void main(String[] args) throws IOException {
    ServerSocket socket = new ServerSocket(80);
    while (true) {
      final Socket connection = socket.accept();
      Runnable task = new Runnable() {
        public void run() {
          handleRequest(connection);
        }
      };
      exec.execute(task);
    }
  }
}
```

### 执行策略

通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。

### 线程池

是指管理一组同构工作线程的资源池。工作队列（Work Queue）保存了所有等待执行的任务，工作者线程（Worker Thread）从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。  

通过重用现有的线程，分摊线程创建和销售产生的巨大开销，节省线程创建时间从而提高响应性。通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌的状态，同时还可以防止过多的线程相互竞争而使应用程序耗尽内存或失败。

* newFixedThreadPool 固定长度的线程池
* newCachedThreadPool 可缓存的线程池
* newSingleThreadExecutor 一个单线程的 Executor
* newScheduledThreadPool 固定长度的线程池，而且以延迟或定时的方式来执行任务

### Executor的生命周期

