---
title: 第6章 任务执行
excerpt: 
last_modified_at: '2021-02-02'
toc: true
tags:
- Java
- concurrency
---



## 在线程中执行任务

当围绕“任务执行”设计应用程序结构时，第一步就是要找出清晰的任务边界。大多数服务应用程序都提供了一种自然的边界选择方式：以独立的客户请求为边界。

### 串行地执行任务
串行处理机制通常都无法提供高吞吐率或快速响应性。
```java
class SingleThreadWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            Socket connection = socket.accept();
            handleRequest(connection);
        }
    }
}
```
### 显示的为任务创建线程
为每个请求创建一个新的线程来提供服务，从而实现更高的响应性
```java
class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run() {
                    handleRequest(connection);
                }
            };
            new Thread(task).start();
        }
    }
}
```

### 无限制创建线程的不足

* 线程生命周期的开销非常高
* 资源消耗：线程多余处理器的数量时线程闲置。闲置线程占用更多内存，给垃圾回收器带来压力，竞争 CPU 资源时产生额外开销。
* 稳定性：OOM



## Executor 框架

