---
title: 第7章 取消与关闭
excerpt: 
last_modified_at: '2021-02-02'
toc: true
tags:
- Java
- concurrency
---



Java没有提供任何机制来安全的终止线程，但它提供了中断（interruption）协调机制，能够使一个线程终止另外一个线程当前的工作。

生命周期结束（End-of-Lifecycle）的问题会使任务、服务以及程序的设计和实现等过程变得复杂

## 任务取消

* 用户请求取消
* 有时间限制的操作
* 应用程序事件
* 错误
* 关闭

Java 没有一种安全的抢占式方法来停止线程，只有协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。

```java
@ThreadSafe
public class PrimeGenerator implements Runnable {
  @GuardedBy("this")
  private final List<BigInteger> primes = new ArrayList<BigInteger>();
  // “已请求取消（Cancellation Requested）”标志
  private volatile boolean cancelled;
  
  public void run() {
    BigInteger p = BigInteger.ONE;
    while (!cancelled) {
      p = p.nextProbablePrime();
      synchronzied (this) {
        primes.add(p);
      }
    }
  }
  
  public void cancel() { cancelled = true; }
  
  public synchronized List<BigInteger> get() {
    return new ArrayList<BigIntegere>(primes);
  }
}
```

一个仅运行一秒钟的素数生成器

```java
List<BigInteger> aSecondOfPrimes() throws InterruptedException {
  PrimeGenerator generator = new PrimeGenerator();
  new Thread(generator).start();
  try {
    SECONDS.sleep(1);
  } finally {
    generator.cancel();
  }
  return generator.get();
}
```

### 中断

通常，中断是实现取消的最合理的方式

使用取消的任务调用了一个阻塞方法，任务可能永远不会检查取消标志。

不可靠的取消操作将把生产者置于阻塞的操作中

```java
class BrokenPrimeProducer extends Thread {
  private final BlockingQueue<BigInteger> queue;
  private volatile boolean cancelled = false;
  
  BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {
    this.queue = queue;
  }
  
  public void run() {
    try {
      BigInteger p = BigInteger.ONE;
      while (!cancelled) {
        queue.put(p = p.nextProbablePrime());
      }
    } catch (InterruptedException consumed) {}
  }
  
  public void cancel() { cancelled = true; }
}

void consumePrimes() throws InterruptedException {
  BlockingQueue<BigInteger> primes = ...;
  BrokenPrimeProducer producer = new BrokenPrimeProducer(primes);
  producer.start();
  try {
    while (needMorePrimes()) {
      consume(primes.take());
    }
  } finally {
    producer.cancel();
  }
}
```

每个线程都有一个 boolean 类型的中断状态，Thread 中包含了中断线程以及查询线程中断状态的方法

```java
public class Thread {
  public void interrupte() {}
  public boolean isInterrupted() {}
  public static boolean interrupted() {}
}
```

调用 interrupt只是传递了请求中断的消息，在使用静态的 interrupted 时应该小心，因为它会清除当前线程的中断状态。

```java
class PrimeProducer extends Thread {
  private final BlockingQueue<BigInteger> queue;
  
  PrimeProducer(BlockingQueue<BigInteger> queue) {
    this.queue = queue;
  }
  
  public void run() {
    try {
      BigInteger p = BigInteger.ONE;
      while (!Thread.currentThread().isInterrupted()) {
        queue.put(p = p.nextProbablePrime());
      } catch (InterruptedException consumed) {
        
      }
    }
  }
  
  public void cancel() { interrupt(); }
}
```

### 中断策略

最合理的中断策略是某种形式的线程级（Thread-Level）取消操作或服务级（Service-Level）取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。

如果除了将 InterruptedException 传递给调用者外还需要执行其他操作，那么应该在捕捉之后恢复中断状态：Thread.currentThread().interrupt();

由于每个线程拥有各自的中断策略，因此除非知道中断对该线程的含义，否则就不应该中断这个线程

### 响应中断

两种使用策略处理 InterruptedException

* 传递异常
* 恢复中断状态

传递异常：

```java
BlockingQueue<Task> queue;

public Task getNextTask() throws InterruptedExecption {
  return queue.take();
}
```

不可取消的任务在退出前恢复中断

```java
public Task getNextTask(BlockingQueue<Task> queue) {
  boolean interrupted = false;
  try {
    while (true) {
      try {
        return queue.take();
      } catch (InterruptedException e) {
        interrupted = true;
        // 重新尝试
      }
    }
  } finally {
    if (interrupted) {
      Thread.currentThread().interrupt();
    }
  }
}
```







