---
title: 第14章 构建自定义的同步工具
excerpt: 
last_modified_at: '2021-02-02'
toc: true
tags:
- Java
- concurrency
---

创建状态依赖类的最简单方式通常是在类库中现有状在载赖类的基础上进行构造

## 状态依赖性的管理

可阻塞的状态依赖操作的结构

```
// acquire lock on object state
while (precondition dose not hold) {
    release lock
        wait until precondition might hold
        optionally fail if interrupted on timeout expires
            reacquire lock
}
perform action
    release lock
```

有界缓存实现的基类

```java
@ThreadSafe
public abstract class BaseBoundedBuffer<V> {
    @GuardedBy("this")
    private final V[] buf;
    @GuradedBy("this")
    private final int tail;
    @GuardedBy("this")
    private final int head;
    @GuardedBy("this")
    private final int count;
    
    protected BaseBoundedBuffer(int capacity) {
        this.buf = (V[])new Object[capacity];
    }
    protected synchronized final void doPut(V v) {
        buf[tail] = v;
        if (++tail == buf.length) {
            tail = 0;
        }
        ++count;
    }
    protected synchronized final V doTake() {
        V v = buf[head];
        buf[head] = null;
        if (++head == buf.length) {
            head = 0;
        }
        --count;
        return v;
    }
    public synchronized final boolean isFull() {
        return count == buf.length;
    }
    public synchronized final boolean isEmpty() {
        return count == 0;
    }
}
```

### 示例：将前提条件的失败传递给调用者

当不满足前提条件时，有界缓存不会执行相应操作

```java
@ThreadSafe
public class GrumpyBoundedBuffer<V> extends BaseBoundedBuffer<V> {
    public GrumpyBoundedBuffer(int size) {
        super(size);
    }
    
    public synchronized void put(V v) throws BufferFullException {
        if (isFull()) {
            throw new BufferFullException();
        }
        doPut(v);
    }
    public synchronized V take() throws BufferEmptyException {
        if (isEmpty()) {
            throw new BufferEmptyException();
        }
        return doTake();
    }
}
```

### 示例：通过轮询与休眠来实现简单的阻塞

```java
@ThreadSafe
public class SleepyBoundedBuffer<V> extends BaseBoundedBuffer<V> {
    public SleepyBoundedBuffer(int size) {
        super(size);
    }
    public void put(V v) throws InterruptedException {
        while (true) {
            synchronized (this) {
                if (!isFull()) {
                    doPut(v);
                    return;
                }
            }
            Thread.sleep(SLEEP_GRANULARITY);
        }
    }
    public V take() throws InterruptedException {
        while (true) {
            synchronized (this) {
                if (!isEmpty()) {
                    return doTake();
                }
            }
            Thread.sleep(SLEEP_GRANULARITY);
        }
    }
}
```

### 条件队列

使用条件队列实现的有界缓存

```java
@ThreadSafe
public class BoundedBuffer<V> extends BaseBoundedBuffer<V> {
    public BoundedBuffer(int size) {
        super(size);
    }
    
    // 阻塞直到 not-full
    public synchronized void put(V v) throws InterruptedException {
        while (isFull()) {
            wait();
        }
        doPut(v);
        notfiyAll();
    }
    // 阻塞直到 not-empty
    public synchronized V take() throws InterruptedException {
        while (isEmpty()) {
            wait();
        }
        V v = doTake();
        notifyAll();
        return v;
    }
}
```



## 使用条件队列

条件队列使构建高效以及高可响应性的状态依赖类变得更容易， 但同时也很容易被不正确地使用。

### 条件谓词

关键找出对象在哪个条件谓词上等待

每次wait调用都会隐式的与特定的条件谓词关联起来。当调用某个特定条件谓词的wait时，调用者必须已经持有与条件队列相关的锁，并且这个锁必须保持着构成条件谓词的状态变量

### 过早唤醒

内置条件队列可以与多个条件谓词一起使用。当一个线程由于调用 notifyAll 而醒来时，并不意味该线程正在等待的条件谓词已经变成真了。

所以，每当线程从wait中唤醒时，都必须再次测试条件谓词

```java
void stateDependentMethod() throws InterruptedException {
    synchronized (lock) {
        while (!conditionPredicate()) {
            lock.wait();
        }
    }
}
```

当使用条件等待时（Object.wait  或 Condition.await）

* 通常都有一个条件谓词--包括一些对象的状态的测试，线程在执行前必须首先通过这些测试
* 在调用wait之前测试条件谓词，并且从wait中返回时再次进行测试
* 在一个循环中调用wait
* 确保使用与条件队列相关的锁来保护构成条件谓词的各个状态变量
* 当调用wait，notify，notifyAll等方法时，一定要持有与条件队列相关的锁
* 在检查条件谓词之后以及开始执行相关的操作之前，不要释放锁

### 丢失的信号

### 通知

### 示例：阀门类

### 子类的安全问题

### 封装条件队列

### 入口协议与出口协议



## 显式的Condition对象

Condition也是一种广义的内置条件队列

```java
public interface Condition {
    void await() throws InterruptedException;
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    long awaitNanos(long nanosTImeout) throws InterruptedException;
    void awaitUninterruptibly();
    boolean awaitUntil(Date deadline) throws InterruptedException;;
    
    void signal();
    void signalAll();
}
```

Condition比内置条件队列提供了更丰富的功能：在每个锁上可存在多个等待/条件等待可以时可中断或不可中断，基于时限的等待，以及公平的或非公平的队列操作

```java
@ThreadSafe
public class ConditionBoundedBuffer<T> {
    protected final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
    @GuardedBy("lock")
    private final T[] items = (T[])new Object[BUFFER_SIZE];
    @GuardedBy("lock")
    private int tail, head, count;
    
    // 阻塞直到notFull
    public void put(T x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length) {
                notFull.await();
            }
            items[tail] = x;
            if (++tail == items.length) {
                tail = 0;
            }
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }
    // 阻塞直到notEmpty
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await();
            }
            T x = items[head];
            items[head] = null;
            if (++head == items.length) {
                head = 0;
            }
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```



## Synchronized剖析

AQS 是一个用于构建锁和同步器的框架，许多同步器都可以通过 AQS 很容易并且高效地构造出来。

## AbstractQueuedSynchronizer

## java.until.concurrent同步器类中的AQS

