---
title: 第12章 并发程序的测试
excerpt: 
last_modified_at: '2021-02-02'
toc: true
tags:
- Java
- concurrency
---



安全性测试：不发生任何错误的行为

活跃性测试：某个良好的行为终究会发生

性能测试：

* 吞吐量 一组并发任务中已完成任务所占的比例
* 响应性 请求从出发到完成之间的时间（延迟）
* 可伸缩性 增加更多资源的情况下（通常指CPU）吞吐量（或者缓解短缺）的提升情况



## 正确性测试

基于信号量的有界缓存

```java
@ThreadSafe
public class BoundedBuffer<E> {
    private final Semaphore availableItems, availableSpaces;
    @GuardedBy("this")
    private final E[] items;
    @GuardedBy("this")
    private final int putPosition = 0, takePosition = 0;
    
    public BoundedBuffer(int capacity) {
        availableItems = new Semaphore(0);
        availableSpaces = new Semaphore(capacity);
        items = (E[]) new Object[capacity];
    }
    public boolean isEmpty() {
        return availableItems.availablePermits() == 0;
    }
    public boolean isFull() {
        return availableSpace.availablePermits() == 0;
    }
    public void put(E x) throws InterruptedException {
        availableSpace.acquire();
        doInsert(x);
        availableItems.release();
    }
    public E take() throws InterruptedException{
        availableItems.acquire();
        E item = doExtract();
        availableSpace.release();
        return item;
    }
    private synchronized void doInsert(E x) {
        int i = putPosition;
        items[i] = x;
        putPosition = (++i == items.length) ? 0 : i;
    }
    private synchronized E doExtract() {
        int i = takePosition;
        E x = items[i];
        items[i] = null;
        takePosition = (++i == item.length) ? 0 : i;
        return x;
    }
}
```

### 基本的单元测试

不变性条件：新建立的缓存应该是空的，插入N个元素到容量N的缓存中应该是满的

```java
class BoundedBufferTest extends TestCase {
    void testIsEmptyWhenConstructed() {
        BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        assertTure(bb.isEmpty());
        assertFalse(bb.isFull());
    }
    void testIsFullAfterPuts() throws InterruptedException {
        BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        for (int i = 0; i < 10; i++) {
            bb.put(i);
        }
        assertTrue(bb.isFull());
        assertFalse(bb.isEmpty());
    }
}
```

### 对阻塞操作的测试

```java
void testTakeBlockWhenEmpty () {
    final BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
    Thread taker = new Thread() {
        public void run() {
            try {
                int unused = bb.take();
                fail();
            } catch (InterruptedException success) {}
        }
    };
    try {
        taker.start();
        Thread.sleep(LOCKUP_DETECT_TIMEOUT);
        taker.interrupt();
        take.join(LOCKUP_DETECT_TIMEOUT);
        assertFalse(taker.isAlive());
    } catch (Exception unexception) {
        fail();
    }
}
```

Thread.getState验证线程能否在一个条件等待上阻塞并不可靠，JVM可以选择通过自旋来实现阻塞。

### 安全性测试

要开发一个良好的并发测试程序，或许比开发这些程序要测试的类更加困难。

在构建对并发类的安全性测试中，需要解决的关键问题在于，要找出那些容易检查的属性，这些属性在发生错误的情况下极有可能失败，同时又不会使得错误检查代码人为的限制并发性。理想情况下，在测试属性中不需要任何同步机制

避免编译器预先猜测到校验和的值，应该采用随机方式生成测试数据（RNG Random Number Generator)。

与其使用通用RNG，不如使用一些简单的伪随机函数

```java
// 测试生产者-消费者程序
public class PutTakeTest {
    
}
```



### 资源管理的测试

### 使用回调

### 产生更多的交替操作

有一种有用的方法可以提高交替操作的数量， 以便能更有效地搜索程序的状态空阔： 在访问共享状态的操作中，使用 Thread.yield 将产生更多的上下文切换。〈这项技术的有效性与具体的平台相关，因为 JVM 可以将 Thread.yield 作为一个空操作〈no-op)[JLS 17. 9]。如果使用一个睡眠时间较短的 sleep ，那么虽然更慢些，但却更可靠。

两个账户之间转账操作，在两次更新操作之间，所有账户的综合应该等于零，通过调用yield把一些对执行时序敏感的错误暴露出来。这种方法需要在测试中添加一些调用，并在正式环境中删除这些调用。AOP可以降低这些不便性。

```java
public synchronized void transferCredits(Account from, Account to, int amount) {
    from.setBalance(from.getBalance() - amount);
    if (random.nextInt(1000) > THRESHOLD)
        Thread.yield();
    to.setBalance(to.getBalance() + amount);
}
```



## 性能测试

## 避免性能测试的陷阱

## 其他的测试方法

测试的目标不是更多的发现错误，而是提高代码能够按照预期方式工作的可信度。由于找出所有的错误是不现实的，所以质量保证（ Quality Assurance， QA ）的目标应该是在给定的测试资源下实现最高的可信度。

### 代码审查

多人参与的代码审查通常是不可替代的

### 静态分析工具

在一些静态分析工具〈例如，开源的 FindBugs ）中包含了许多错误模式检查器，能够检测出多种常见的编码错误，其中许多错误都很容易在测试与代码审查中遗漏。

### 面向方面的测试技术

AOP可用来确保不变性条件不被破坏，或者与同步策略的某些方面保持一致

### 分析与检测工具

大多数商业分析工具都支持钱程。这些工具在功能与执行效率上存在着差异，但通常都能给出对程序内部的详细信息