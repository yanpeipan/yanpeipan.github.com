---
layout: post
title: "Linux平均负载解疑"
description: ""
category: 
tags: [Linux]
---
{% include JB/setup %}

# 平均负载(Load Average)的定义

## CPU平均负载

RFC 546 (1973)

> [1] The TENEX load average is a measure of CPU demand.  The load
   average is an average of the number of runable processes over a given
   time period.  For example, an hourly load average of 10 would mean
   that (for a single CPU system) at any time during that hour one could
   expect to see 1 process running and 9 others ready to run (i.e., not
   blocked for I/O) waiting for the CPU.

> TENEX load averages是衡量CPU需求的指标。这个值是给定时间内可运行进程数量的平均值。例如，对于单核CPU系统，每小时平均10次意思是在该小时内可以期望看到一个进程正在运行和另外九个等待CPU(即没有被I/O阻塞)处于ready状态的进程。

## 不可中断任务

[oldlinux.org](http://oldlinux.org/Linux.old/mail-archive/) 上1993年的一封邮件:
>
From: Matthias Urlichs <urlichs@smurf.sub.org>  
Subject: Load average broken ?  
Date: Fri, 29 Oct 1993 11:37:23 +0200  
>
The kernel only counts "runnable" processes when computing the load average.
I don't like that; the problem is that processes which are swapping or
waiting on "fast", i.e. noninterruptible, I/O, also consume resources.  
It seems somewhat nonintuitive that the load average goes down when you
replace your fast swap disk with a slow swap disk...  
Anyway, the following patch seems to make the load average much more
consistent WRT the subjective speed of the system. And, most important, the
load is still zero when nobody is doing anything. ;-)

绝大多数类 Unix 系统只统计运行和等待状态的进程。但是在 Linux 中，平均负载也包括处于不可打断的睡眠状态的进程（TASK_UNINTERRUPTIBLE或nr_uninterruptible）——这种状态由希望避免信号中断的代码使用，其中包括阻塞在磁盘I/O和一些锁上的任务。

使用`man ps` (process status)查看：
> ps displays information about a selection of the active processes.  If you want a repetitive update of the selection and the displayed information, use top(1) instead. 
 
> Here are the different values that the s, stat and state output specifiers (header "STAT" or "S") will display to describe the state of a process:
>> D    uninterruptible sleep (usually IO)    
>> R    running or runnable (on run queue)  
>> S    interruptible sleep (waiting for an event to complete)  
>> T    stopped by job control signal  
>> t    stopped by debugger during the tracing  
>> W    paging (not valid since the 2.6.xx kernel)  
>> X    dead (should never be seen)  
>> Z    defunct ("zombie") process, terminated but not reaped by its parent  

注：参见《OPERATING SYSTEM》  A process is an 'active' entity as opposed to program which is considered to be a 'passive' entity. 进程是活跃的，与之相反程序（代码）是不活跃的。所以active processes活跃进程包含所有状态的进程。

## 系统平均负载

使用`man uptime`命令来了解平均负载的详细解释。

>
System  load  averages  is the average number of processes that are either in a runnable or uninterruptable state.  A process in a runnable state is either using the CPU or waiting to use the CPU.  A process in uninterruptable state is waiting for some I/O access, eg waiting for disk.  The averages are taken over the three time intervals.  Load averages are not normalized for the number of CPUs in a system, so a load average of 1 means a single CPU system is loaded all the time while on a  4  CPU  system  it means it was idle 75% of the time.
>
系统负载平均是处于可运行或不可中断状态的进程的平均数量。处于可运行状态的进程要么使用CPU，要么等待使用CPU。处于不可中断状态的进程正在等待一些I/O访问(如等待磁盘)。平均值在三个时间间隔内取。对于系统中的CPU数量，负载平均并不是标准化的，所以负载平均为1意味着一个CPU系统一直在加载，而对于4 CPU系统，负载平均为75%的时间是空闲的。

除此之外还可使用 `w` `top`, 及各种增强版`atop` `htop` `glances`等，或者直接使用`cat /proc/loadavg`命令读取。

## 实现

linux/fs/proc/loadavg.c
```
static int loadavg_proc_show(struct seq_file *m, void *v)
{
	unsigned long avnrun[3];

	get_avenrun(avnrun, FIXED_1/200, 0);

	seq_printf(m, "%lu.%02lu %lu.%02lu %lu.%02lu %ld/%d %d\n",
		LOAD_INT(avnrun[0]), LOAD_FRAC(avnrun[0]),
		LOAD_INT(avnrun[1]), LOAD_FRAC(avnrun[1]),
		LOAD_INT(avnrun[2]), LOAD_FRAC(avnrun[2]),
		nr_running(), nr_threads,
		idr_get_cursor(&task_active_pid_ns(current)->idr) - 1);
	return 0;
}
```

linux/include/linux/sched/loadavg.h
```
#define EXP_1		1884		/* 1/exp(5sec/1min) as fixed-point */
#define EXP_5		2014		/* 1/exp(5sec/5min) */
#define EXP_15		2037		/* 1/exp(5sec/15min) */

/*
 * a1 = a0 * e + a * (1 - e)
 */
static inline unsigned long
calc_load(unsigned long load, unsigned long exp, unsigned long active)
{
	unsigned long newload;

	newload = load * exp + active * (FIXED_1 - exp);
	if (active >= load)
		newload += FIXED_1-1;

	return newload / FIXED_1;
}
```

linux/kernel/sched/loadavg.c
```

/*
 * Global load-average calculations
 *
 * We take a distributed and async approach to calculating the global load-avg
 * in order to minimize overhead.
 *
 * The global load average is an exponentially decaying average of nr_running +
 * nr_uninterruptible.
 *
 * Once every LOAD_FREQ:
 *
 *   nr_active = 0;
 *   for_each_possible_cpu(cpu)
 *	nr_active += cpu_of(cpu)->nr_running + cpu_of(cpu)->nr_uninterruptible;
 *
 *   avenrun[n] = avenrun[0] * exp_n + nr_active * (1 - exp_n)
...
*/

/*
 * calc_load - update the avenrun load estimates 10 ticks after the
 * CPUs have updated calc_load_tasks.
 *
 * Called from the global timer code.
 */
void calc_global_load(unsigned long ticks)
{
	unsigned long sample_window;
	long active, delta;

	sample_window = READ_ONCE(calc_load_update);
	if (time_before(jiffies, sample_window + 10))
		return;

	/*
	 * Fold the 'old' NO_HZ-delta to include all NO_HZ CPUs.
	 */
	delta = calc_load_nohz_fold();
	if (delta)
		atomic_long_add(delta, &calc_load_tasks);

	active = atomic_long_read(&calc_load_tasks);
	active = active > 0 ? active * FIXED_1 : 0;

	avenrun[0] = calc_load(avenrun[0], EXP_1, active);
	avenrun[1] = calc_load(avenrun[1], EXP_5, active);
	avenrun[2] = calc_load(avenrun[2], EXP_15, active);

	WRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);

	/*
	 * In case we went to NO_HZ for multiple LOAD_FREQ intervals
	 * catch up in bulk.
	 */
	calc_global_nohz();
}
```
为了最小化开销，Linux采用分布式和异步的方法来计算全局负载平均分配。全局负载平均值是nr_running + nr_uninterruptible的指数衰减平均值。  
Linux内核定义一个长度为3的双字数组avenrun，双字的低11位用于存放负载的小数部分，高21位用于存放整数部分。

>
注：linux kernel的设计哲学是禁止在内核里使用浮点操作的，这是从性能上的考虑，因为这样做可以省去在用户态与内核态之间进行切换时保存/恢复浮点寄存器 FPU的操作, 内核浮点计算代码块中，必须使用 `kernel_fpu_begin()`和`kernel_fpu_end()`这两个函数包起来。这两个函数的作用是让内核感知不到OS运行过程中有使用硬件浮点寄存器     
指数移动平均（英语：exponential moving average，EMA或EXMA）是以指数式递减加权的移动平均。各数值的加权影响力随时间而指数式递减，越近期的数据加权影响力越重，但较旧的数据也给予一定的加权值

# 指标的三个粒度

## 理解Linux的平均负载
```
uptime
13:17  up 23:48, 5 users, load averages: 2.31 2.44 2.46
```
* 如果平均值是0.0，说明系统处于空闲状态
* 如果1分钟的平均值大于5分钟或者15分钟，说明系统负载正在增加
* 如果1分钟的平均值小于5分钟或者15分钟，说明系统负载正在减小
* 如果这些值大于CPU的个数，说明可能遇到了性能问题 
* 系统平均负载涉及不同的资源类型，因此它们更加模糊，所以不能只除以CPU计数

注：查看CPU个数 `grep 'model name' /proc/cpuinfo | wc -l` )

## 模拟分析

```
apt install sysstat
```

### CPU密集

```
stress -i 1 --timeout 600

watch -d uptime

Every 2.0s: uptime                                                                                                                                                          2018: Wed Dec 19 20:05:44 2018

 20:05:44 up  6:30,  3 users,  load average: 0.57, 0.37, 0.21

mpstat -P ALL 5

20时05分11秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
20时05分16秒  all   12.60    0.00    0.05    0.00    0.00    0.00    0.00    0.00    0.00   87.35
20时05分16秒    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
20时05分16秒    1    0.60    0.00    0.20    0.20    0.00    0.00    0.00    0.00    0.00   99.00
20时05分16秒    2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
20时05分16秒    3    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80
20时05分16秒    4    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
20时05分16秒    5    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
20时05分16秒    6  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
20时05分16秒    7    0.20    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.60
```

### IO密集

```
stress -d 1 --hdd-bytes 1G -t 600

stress-ng -i 1 --hdd 1 --timeout 600

watch -d uptime

mpstat -P ALL 5

pidstat -u 5
```

### 进程竞争

```
stress -c 8 --timeout 600

watch -d vmstat
```

---
* [深入理解load averages](https://juejin.im/post/5b18d47ce51d4506c3354d54)
* [Linux Load Averages: Solving the Mystery](http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html)
* [基础篇：到底应该怎么理解“平均负载”？](https://time.geekbang.org/column/article/69618)
* [What is a Process?](https://www.studytonight.com/operating-system/operating-system-processes)